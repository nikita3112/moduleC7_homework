'use strict';

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = o[Symbol.iterator]();
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

var prompts = require('./prompts');

var passOn = ['suggest', 'format', 'onState', 'validate', 'onRender', 'type'];

var noop = function noop() {};
/**
 * Prompt for a series of questions
 * @param {Array|Object} questions Single question object or Array of question objects
 * @param {Function} [onSubmit] Callback function called on prompt submit
 * @param {Function} [onCancel] Callback function called on cancel/abort
 * @returns {Object} Object with values from user input
 */


function prompt() {
  return _prompt.apply(this, arguments);
}

function _prompt() {
  _prompt = _asyncToGenerator(
  /*#__PURE__*/
  regeneratorRuntime.mark(function _callee2() {
    var questions,
        _ref2,
        _ref2$onSubmit,
        onSubmit,
        _ref2$onCancel,
        onCancel,
        answers,
        override,
        answer,
        question,
        quit,
        name,
        type,
        lastPrompt,
        getFormattedAnswer,
        _iterator,
        _step,
        _question,
        key,
        value,
        _question2,
        _args2 = arguments;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            questions = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : [];
            _ref2 = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {}, _ref2$onSubmit = _ref2.onSubmit, onSubmit = _ref2$onSubmit === void 0 ? noop : _ref2$onSubmit, _ref2$onCancel = _ref2.onCancel, onCancel = _ref2$onCancel === void 0 ? noop : _ref2$onCancel;
            answers = {};
            override = prompt._override || {};
            questions = [].concat(questions);

            getFormattedAnswer =
            /*#__PURE__*/
            function () {
              var _ref = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee(question, answer) {
                var skipValidation,
                    _args = arguments;
                return regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        skipValidation = _args.length > 2 && _args[2] !== undefined ? _args[2] : false;

                        if (!(!skipValidation && question.validate && question.validate(answer) !== true)) {
                          _context.next = 3;
                          break;
                        }

                        return _context.abrupt("return");

                      case 3:
                        if (!question.format) {
                          _context.next = 9;
                          break;
                        }

                        _context.next = 6;
                        return question.format(answer, answers);

                      case 6:
                        _context.t0 = _context.sent;
                        _context.next = 10;
                        break;

                      case 9:
                        _context.t0 = answer;

                      case 10:
                        return _context.abrupt("return", _context.t0);

                      case 11:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));

              return function getFormattedAnswer(_x, _x2) {
                return _ref.apply(this, arguments);
              };
            }();

            _iterator = _createForOfIteratorHelper(questions);
            _context2.prev = 7;

            _iterator.s();

          case 9:
            if ((_step = _iterator.n()).done) {
              _context2.next = 78;
              break;
            }

            question = _step.value;
            _question = question;
            name = _question.name;
            type = _question.type; // evaluate type first and skip if type is a falsy value

            if (!(typeof type === 'function')) {
              _context2.next = 19;
              break;
            }

            _context2.next = 17;
            return type(answer, _objectSpread({}, answers), question);

          case 17:
            type = _context2.sent;
            question['type'] = type;

          case 19:
            if (type) {
              _context2.next = 21;
              break;
            }

            return _context2.abrupt("continue", 76);

          case 21:
            _context2.t0 = regeneratorRuntime.keys(question);

          case 22:
            if ((_context2.t1 = _context2.t0()).done) {
              _context2.next = 37;
              break;
            }

            key = _context2.t1.value;

            if (!passOn.includes(key)) {
              _context2.next = 26;
              break;
            }

            return _context2.abrupt("continue", 22);

          case 26:
            value = question[key];

            if (!(typeof value === 'function')) {
              _context2.next = 33;
              break;
            }

            _context2.next = 30;
            return value(answer, _objectSpread({}, answers), lastPrompt);

          case 30:
            _context2.t2 = _context2.sent;
            _context2.next = 34;
            break;

          case 33:
            _context2.t2 = value;

          case 34:
            question[key] = _context2.t2;
            _context2.next = 22;
            break;

          case 37:
            lastPrompt = question;

            if (!(typeof question.message !== 'string')) {
              _context2.next = 40;
              break;
            }

            throw new Error('prompt message is required');

          case 40:
            // update vars in case they changed
            _question2 = question;
            name = _question2.name;
            type = _question2.type;

            if (!(prompts[type] === void 0)) {
              _context2.next = 45;
              break;
            }

            throw new Error("prompt type (".concat(type, ") is not defined"));

          case 45:
            if (!(override[question.name] !== undefined)) {
              _context2.next = 52;
              break;
            }

            _context2.next = 48;
            return getFormattedAnswer(question, override[question.name]);

          case 48:
            answer = _context2.sent;

            if (!(answer !== undefined)) {
              _context2.next = 52;
              break;
            }

            answers[name] = answer;
            return _context2.abrupt("continue", 76);

          case 52:
            _context2.prev = 52;

            if (!prompt._injected) {
              _context2.next = 57;
              break;
            }

            _context2.t3 = getInjectedAnswer(prompt._injected, question.initial);
            _context2.next = 60;
            break;

          case 57:
            _context2.next = 59;
            return prompts[type](question);

          case 59:
            _context2.t3 = _context2.sent;

          case 60:
            answer = _context2.t3;
            _context2.next = 63;
            return getFormattedAnswer(question, answer, true);

          case 63:
            answers[name] = answer = _context2.sent;
            _context2.next = 66;
            return onSubmit(question, answer, answers);

          case 66:
            quit = _context2.sent;
            _context2.next = 74;
            break;

          case 69:
            _context2.prev = 69;
            _context2.t4 = _context2["catch"](52);
            _context2.next = 73;
            return onCancel(question, answers);

          case 73:
            quit = !_context2.sent;

          case 74:
            if (!quit) {
              _context2.next = 76;
              break;
            }

            return _context2.abrupt("return", answers);

          case 76:
            _context2.next = 9;
            break;

          case 78:
            _context2.next = 83;
            break;

          case 80:
            _context2.prev = 80;
            _context2.t5 = _context2["catch"](7);

            _iterator.e(_context2.t5);

          case 83:
            _context2.prev = 83;

            _iterator.f();

            return _context2.finish(83);

          case 86:
            return _context2.abrupt("return", answers);

          case 87:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[7, 80, 83, 86], [52, 69]]);
  }));
  return _prompt.apply(this, arguments);
}

function getInjectedAnswer(injected, deafultValue) {
  var answer = injected.shift();

  if (answer instanceof Error) {
    throw answer;
  }

  return answer === undefined ? deafultValue : answer;
}

function inject(answers) {
  prompt._injected = (prompt._injected || []).concat(answers);
}

function override(answers) {
  prompt._override = Object.assign({}, answers);
}

module.exports = Object.assign(prompt, {
  prompt: prompt,
  prompts: prompts,
  inject: inject,
  override: override
});