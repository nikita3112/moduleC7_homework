"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var RangeTree =
/*#__PURE__*/
function () {
  function RangeTree(start, end, delta, children) {
    _classCallCheck(this, RangeTree);

    this.start = start;
    this.end = end;
    this.delta = delta;
    this.children = children;
  }
  /**
   * @precodition `ranges` are well-formed and pre-order sorted
   */


  _createClass(RangeTree, [{
    key: "normalize",
    value: function normalize() {
      var children = [];
      var curEnd;
      var head;
      var tail = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _child = _step.value;

          if (head === undefined) {
            head = _child;
          } else if (_child.delta === head.delta && _child.start === curEnd) {
            tail.push(_child);
          } else {
            endChain();
            head = _child;
          }

          curEnd = _child.end;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (head !== undefined) {
        endChain();
      }

      if (children.length === 1) {
        var child = children[0];

        if (child.start === this.start && child.end === this.end) {
          this.delta += child.delta;
          this.children = child.children; // `.lazyCount` is zero for both (both are after normalization)

          return;
        }
      }

      this.children = children;

      function endChain() {
        if (tail.length !== 0) {
          head.end = tail[tail.length - 1].end;
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = tail[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var tailTree = _step2.value;
              var _iteratorNormalCompletion3 = true;
              var _didIteratorError3 = false;
              var _iteratorError3 = undefined;

              try {
                for (var _iterator3 = tailTree.children[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  var subChild = _step3.value;
                  subChild.delta += tailTree.delta - head.delta;
                  head.children.push(subChild);
                }
              } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                    _iterator3["return"]();
                  }
                } finally {
                  if (_didIteratorError3) {
                    throw _iteratorError3;
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          tail.length = 0;
        }

        head.normalize();
        children.push(head);
      }
    }
    /**
     * @precondition `tree.start < value && value < tree.end`
     * @return RangeTree Right part
     */

  }, {
    key: "split",
    value: function split(value) {
      var leftChildLen = this.children.length;
      var mid; // TODO(perf): Binary search (check overhead)

      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];

        if (child.start < value && value < child.end) {
          mid = child.split(value);
          leftChildLen = i + 1;
          break;
        } else if (child.start >= value) {
          leftChildLen = i;
          break;
        }
      }

      var rightLen = this.children.length - leftChildLen;
      var rightChildren = this.children.splice(leftChildLen, rightLen);

      if (mid !== undefined) {
        rightChildren.unshift(mid);
      }

      var result = new RangeTree(value, this.end, this.delta, rightChildren);
      this.end = value;
      return result;
    }
    /**
     * Get the range coverages corresponding to the tree.
     *
     * The ranges are pre-order sorted.
     */

  }, {
    key: "toRanges",
    value: function toRanges() {
      var ranges = []; // Stack of parent trees and counts.

      var stack = [[this, 0]];

      while (stack.length > 0) {
        var _stack$pop = stack.pop(),
            _stack$pop2 = _slicedToArray(_stack$pop, 2),
            cur = _stack$pop2[0],
            parentCount = _stack$pop2[1];

        var count = parentCount + cur.delta;
        ranges.push({
          startOffset: cur.start,
          endOffset: cur.end,
          count: count
        });

        for (var i = cur.children.length - 1; i >= 0; i--) {
          stack.push([cur.children[i], count]);
        }
      }

      return ranges;
    }
  }], [{
    key: "fromSortedRanges",
    value: function fromSortedRanges(ranges) {
      var root; // Stack of parent trees and parent counts.

      var stack = [];
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = ranges[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var range = _step4.value;
          var node = new RangeTree(range.startOffset, range.endOffset, range.count, []);

          if (root === undefined) {
            root = node;
            stack.push([node, range.count]);
            continue;
          }

          var parent = void 0;
          var parentCount = void 0;

          while (true) {
            var _stack = _slicedToArray(stack[stack.length - 1], 2);

            parent = _stack[0];
            parentCount = _stack[1];

            // assert: `top !== undefined` (the ranges are sorted)
            if (range.startOffset < parent.end) {
              break;
            } else {
              stack.pop();
            }
          }

          node.delta -= parentCount;
          parent.children.push(node);
          stack.push([node, range.count]);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return root;
    }
  }]);

  return RangeTree;
}();

exports.RangeTree = RangeTree;