"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var normalize_1 = require("./normalize");

var range_tree_1 = require("./range-tree");
/**
 * Merges a list of process coverages.
 *
 * The result is normalized.
 * The input values may be mutated, it is not safe to use them after passing
 * them to this function.
 * The computation is synchronous.
 *
 * @param processCovs Process coverages to merge.
 * @return Merged process coverage.
 */


function mergeProcessCovs(processCovs) {
  if (processCovs.length === 0) {
    return {
      result: []
    };
  }

  var urlToScripts = new Map();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = processCovs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var processCov = _step.value;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = processCov.result[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var scriptCov = _step3.value;
          var scriptCovs = urlToScripts.get(scriptCov.url);

          if (scriptCovs === undefined) {
            scriptCovs = [];
            urlToScripts.set(scriptCov.url, scriptCovs);
          }

          scriptCovs.push(scriptCov);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  var result = [];
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = urlToScripts.values()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var scripts = _step2.value;
      // assert: `scripts.length > 0`
      result.push(mergeScriptCovs(scripts));
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  var merged = {
    result: result
  };
  normalize_1.normalizeProcessCov(merged);
  return merged;
}

exports.mergeProcessCovs = mergeProcessCovs;
/**
 * Merges a list of matching script coverages.
 *
 * Scripts are matching if they have the same `url`.
 * The result is normalized.
 * The input values may be mutated, it is not safe to use them after passing
 * them to this function.
 * The computation is synchronous.
 *
 * @param scriptCovs Process coverages to merge.
 * @return Merged script coverage, or `undefined` if the input list was empty.
 */

function mergeScriptCovs(scriptCovs) {
  if (scriptCovs.length === 0) {
    return undefined;
  } else if (scriptCovs.length === 1) {
    var _merged = scriptCovs[0];
    normalize_1.deepNormalizeScriptCov(_merged);
    return _merged;
  }

  var first = scriptCovs[0];
  var scriptId = first.scriptId;
  var url = first.url;
  var rangeToFuncs = new Map();
  var _iteratorNormalCompletion4 = true;
  var _didIteratorError4 = false;
  var _iteratorError4 = undefined;

  try {
    for (var _iterator4 = scriptCovs[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
      var scriptCov = _step4.value;
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = scriptCov.functions[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var funcCov = _step6.value;
          var rootRange = stringifyFunctionRootRange(funcCov);
          var funcCovs = rangeToFuncs.get(rootRange);

          if (funcCovs === undefined || // if the entry in rangeToFuncs is function-level granularity and
          // the new coverage is block-level, prefer block-level.
          !funcCovs[0].isBlockCoverage && funcCov.isBlockCoverage) {
            funcCovs = [];
            rangeToFuncs.set(rootRange, funcCovs);
          } else if (funcCovs[0].isBlockCoverage && !funcCov.isBlockCoverage) {
            // if the entry in rangeToFuncs is block-level granularity, we should
            // not append function level granularity.
            continue;
          }

          funcCovs.push(funcCov);
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
            _iterator6["return"]();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError4 = true;
    _iteratorError4 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
        _iterator4["return"]();
      }
    } finally {
      if (_didIteratorError4) {
        throw _iteratorError4;
      }
    }
  }

  var functions = [];
  var _iteratorNormalCompletion5 = true;
  var _didIteratorError5 = false;
  var _iteratorError5 = undefined;

  try {
    for (var _iterator5 = rangeToFuncs.values()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
      var _funcCovs = _step5.value;
      // assert: `funcCovs.length > 0`
      functions.push(mergeFunctionCovs(_funcCovs));
    }
  } catch (err) {
    _didIteratorError5 = true;
    _iteratorError5 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
        _iterator5["return"]();
      }
    } finally {
      if (_didIteratorError5) {
        throw _iteratorError5;
      }
    }
  }

  var merged = {
    scriptId: scriptId,
    url: url,
    functions: functions
  };
  normalize_1.normalizeScriptCov(merged);
  return merged;
}

exports.mergeScriptCovs = mergeScriptCovs;
/**
 * Returns a string representation of the root range of the function.
 *
 * This string can be used to match function with same root range.
 * The string is derived from the start and end offsets of the root range of
 * the function.
 * This assumes that `ranges` is non-empty (true for valid function coverages).
 *
 * @param funcCov Function coverage with the range to stringify
 * @internal
 */

function stringifyFunctionRootRange(funcCov) {
  var rootRange = funcCov.ranges[0];
  return "".concat(rootRange.startOffset.toString(10), ";").concat(rootRange.endOffset.toString(10));
}
/**
 * Merges a list of matching function coverages.
 *
 * Functions are matching if their root ranges have the same span.
 * The result is normalized.
 * The input values may be mutated, it is not safe to use them after passing
 * them to this function.
 * The computation is synchronous.
 *
 * @param funcCovs Function coverages to merge.
 * @return Merged function coverage, or `undefined` if the input list was empty.
 */


function mergeFunctionCovs(funcCovs) {
  if (funcCovs.length === 0) {
    return undefined;
  } else if (funcCovs.length === 1) {
    var _merged2 = funcCovs[0];
    normalize_1.normalizeFunctionCov(_merged2);
    return _merged2;
  }

  var functionName = funcCovs[0].functionName;
  var trees = [];
  var _iteratorNormalCompletion7 = true;
  var _didIteratorError7 = false;
  var _iteratorError7 = undefined;

  try {
    for (var _iterator7 = funcCovs[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
      var funcCov = _step7.value;
      // assert: `fn.ranges.length > 0`
      // assert: `fn.ranges` is sorted
      trees.push(range_tree_1.RangeTree.fromSortedRanges(funcCov.ranges));
    } // assert: `trees.length > 0`

  } catch (err) {
    _didIteratorError7 = true;
    _iteratorError7 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
        _iterator7["return"]();
      }
    } finally {
      if (_didIteratorError7) {
        throw _iteratorError7;
      }
    }
  }

  var mergedTree = mergeRangeTrees(trees);
  normalize_1.normalizeRangeTree(mergedTree);
  var ranges = mergedTree.toRanges();
  var isBlockCoverage = !(ranges.length === 1 && ranges[0].count === 0);
  var merged = {
    functionName: functionName,
    ranges: ranges,
    isBlockCoverage: isBlockCoverage
  }; // assert: `merged` is normalized

  return merged;
}

exports.mergeFunctionCovs = mergeFunctionCovs;
/**
 * @precondition Same `start` and `end` for all the trees
 */

function mergeRangeTrees(trees) {
  if (trees.length <= 1) {
    return trees[0];
  }

  var first = trees[0];
  var delta = 0;
  var _iteratorNormalCompletion8 = true;
  var _didIteratorError8 = false;
  var _iteratorError8 = undefined;

  try {
    for (var _iterator8 = trees[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
      var tree = _step8.value;
      delta += tree.delta;
    }
  } catch (err) {
    _didIteratorError8 = true;
    _iteratorError8 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
        _iterator8["return"]();
      }
    } finally {
      if (_didIteratorError8) {
        throw _iteratorError8;
      }
    }
  }

  var children = mergeRangeTreeChildren(trees);
  return new range_tree_1.RangeTree(first.start, first.end, delta, children);
}

var RangeTreeWithParent = function RangeTreeWithParent(parentIndex, tree) {
  _classCallCheck(this, RangeTreeWithParent);

  this.parentIndex = parentIndex;
  this.tree = tree;
};

var StartEvent =
/*#__PURE__*/
function () {
  function StartEvent(offset, trees) {
    _classCallCheck(this, StartEvent);

    this.offset = offset;
    this.trees = trees;
  }

  _createClass(StartEvent, null, [{
    key: "compare",
    value: function compare(a, b) {
      return a.offset - b.offset;
    }
  }]);

  return StartEvent;
}();

var StartEventQueue =
/*#__PURE__*/
function () {
  function StartEventQueue(queue) {
    _classCallCheck(this, StartEventQueue);

    this.queue = queue;
    this.nextIndex = 0;
    this.pendingOffset = 0;
    this.pendingTrees = undefined;
  }

  _createClass(StartEventQueue, [{
    key: "setPendingOffset",
    value: function setPendingOffset(offset) {
      this.pendingOffset = offset;
    }
  }, {
    key: "pushPendingTree",
    value: function pushPendingTree(tree) {
      if (this.pendingTrees === undefined) {
        this.pendingTrees = [];
      }

      this.pendingTrees.push(tree);
    }
  }, {
    key: "next",
    value: function next() {
      var pendingTrees = this.pendingTrees;
      var nextEvent = this.queue[this.nextIndex];

      if (pendingTrees === undefined) {
        this.nextIndex++;
        return nextEvent;
      } else if (nextEvent === undefined) {
        this.pendingTrees = undefined;
        return new StartEvent(this.pendingOffset, pendingTrees);
      } else {
        if (this.pendingOffset < nextEvent.offset) {
          this.pendingTrees = undefined;
          return new StartEvent(this.pendingOffset, pendingTrees);
        } else {
          if (this.pendingOffset === nextEvent.offset) {
            this.pendingTrees = undefined;
            var _iteratorNormalCompletion9 = true;
            var _didIteratorError9 = false;
            var _iteratorError9 = undefined;

            try {
              for (var _iterator9 = pendingTrees[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                var tree = _step9.value;
                nextEvent.trees.push(tree);
              }
            } catch (err) {
              _didIteratorError9 = true;
              _iteratorError9 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion9 && _iterator9["return"] != null) {
                  _iterator9["return"]();
                }
              } finally {
                if (_didIteratorError9) {
                  throw _iteratorError9;
                }
              }
            }
          }

          this.nextIndex++;
          return nextEvent;
        }
      }
    }
  }], [{
    key: "fromParentTrees",
    value: function fromParentTrees(parentTrees) {
      var startToTrees = new Map();
      var _iteratorNormalCompletion10 = true;
      var _didIteratorError10 = false;
      var _iteratorError10 = undefined;

      try {
        for (var _iterator10 = parentTrees.entries()[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
          var _step10$value = _slicedToArray(_step10.value, 2),
              parentIndex = _step10$value[0],
              parentTree = _step10$value[1];

          var _iteratorNormalCompletion12 = true;
          var _didIteratorError12 = false;
          var _iteratorError12 = undefined;

          try {
            for (var _iterator12 = parentTree.children[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
              var child = _step12.value;
              var trees = startToTrees.get(child.start);

              if (trees === undefined) {
                trees = [];
                startToTrees.set(child.start, trees);
              }

              trees.push(new RangeTreeWithParent(parentIndex, child));
            }
          } catch (err) {
            _didIteratorError12 = true;
            _iteratorError12 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion12 && _iterator12["return"] != null) {
                _iterator12["return"]();
              }
            } finally {
              if (_didIteratorError12) {
                throw _iteratorError12;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError10 = true;
        _iteratorError10 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion10 && _iterator10["return"] != null) {
            _iterator10["return"]();
          }
        } finally {
          if (_didIteratorError10) {
            throw _iteratorError10;
          }
        }
      }

      var queue = [];
      var _iteratorNormalCompletion11 = true;
      var _didIteratorError11 = false;
      var _iteratorError11 = undefined;

      try {
        for (var _iterator11 = startToTrees[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
          var _step11$value = _slicedToArray(_step11.value, 2),
              startOffset = _step11$value[0],
              _trees = _step11$value[1];

          queue.push(new StartEvent(startOffset, _trees));
        }
      } catch (err) {
        _didIteratorError11 = true;
        _iteratorError11 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion11 && _iterator11["return"] != null) {
            _iterator11["return"]();
          }
        } finally {
          if (_didIteratorError11) {
            throw _iteratorError11;
          }
        }
      }

      queue.sort(StartEvent.compare);
      return new StartEventQueue(queue);
    }
  }]);

  return StartEventQueue;
}();

function mergeRangeTreeChildren(parentTrees) {
  var result = [];
  var startEventQueue = StartEventQueue.fromParentTrees(parentTrees);
  var parentToNested = new Map();
  var openRange;

  while (true) {
    var event = startEventQueue.next();

    if (event === undefined) {
      break;
    }

    if (openRange !== undefined && openRange.end <= event.offset) {
      result.push(nextChild(openRange, parentToNested));
      openRange = undefined;
    }

    if (openRange === undefined) {
      var openRangeEnd = event.offset + 1;
      var _iteratorNormalCompletion13 = true;
      var _didIteratorError13 = false;
      var _iteratorError13 = undefined;

      try {
        for (var _iterator13 = event.trees[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
          var _step13$value = _step13.value,
              parentIndex = _step13$value.parentIndex,
              tree = _step13$value.tree;
          openRangeEnd = Math.max(openRangeEnd, tree.end);
          insertChild(parentToNested, parentIndex, tree);
        }
      } catch (err) {
        _didIteratorError13 = true;
        _iteratorError13 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion13 && _iterator13["return"] != null) {
            _iterator13["return"]();
          }
        } finally {
          if (_didIteratorError13) {
            throw _iteratorError13;
          }
        }
      }

      startEventQueue.setPendingOffset(openRangeEnd);
      openRange = {
        start: event.offset,
        end: openRangeEnd
      };
    } else {
      var _iteratorNormalCompletion14 = true;
      var _didIteratorError14 = false;
      var _iteratorError14 = undefined;

      try {
        for (var _iterator14 = event.trees[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
          var _step14$value = _step14.value,
              _parentIndex = _step14$value.parentIndex,
              _tree = _step14$value.tree;

          if (_tree.end > openRange.end) {
            var right = _tree.split(openRange.end);

            startEventQueue.pushPendingTree(new RangeTreeWithParent(_parentIndex, right));
          }

          insertChild(parentToNested, _parentIndex, _tree);
        }
      } catch (err) {
        _didIteratorError14 = true;
        _iteratorError14 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion14 && _iterator14["return"] != null) {
            _iterator14["return"]();
          }
        } finally {
          if (_didIteratorError14) {
            throw _iteratorError14;
          }
        }
      }
    }
  }

  if (openRange !== undefined) {
    result.push(nextChild(openRange, parentToNested));
  }

  return result;
}

function insertChild(parentToNested, parentIndex, tree) {
  var nested = parentToNested.get(parentIndex);

  if (nested === undefined) {
    nested = [];
    parentToNested.set(parentIndex, nested);
  }

  nested.push(tree);
}

function nextChild(openRange, parentToNested) {
  var matchingTrees = [];
  var _iteratorNormalCompletion15 = true;
  var _didIteratorError15 = false;
  var _iteratorError15 = undefined;

  try {
    for (var _iterator15 = parentToNested.values()[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
      var nested = _step15.value;

      if (nested.length === 1 && nested[0].start === openRange.start && nested[0].end === openRange.end) {
        matchingTrees.push(nested[0]);
      } else {
        matchingTrees.push(new range_tree_1.RangeTree(openRange.start, openRange.end, 0, nested));
      }
    }
  } catch (err) {
    _didIteratorError15 = true;
    _iteratorError15 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion15 && _iterator15["return"] != null) {
        _iterator15["return"]();
      }
    } finally {
      if (_didIteratorError15) {
        throw _iteratorError15;
      }
    }
  }

  parentToNested.clear();
  return mergeRangeTrees(matchingTrees);
}