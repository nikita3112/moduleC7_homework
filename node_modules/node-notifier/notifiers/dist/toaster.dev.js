"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Wrapper for the toaster (https://github.com/nels-o/toaster)
 */
var path = require('path');

var notifier = path.resolve(__dirname, '../vendor/snoreToast/snoretoast');

var utils = require('../lib/utils');

var Balloon = require('./balloon');

var os = require('os');

var _require = require('uuid'),
    uuid = _require.v4;

var EventEmitter = require('events').EventEmitter;

var util = require('util');

var fallback;
var PIPE_NAME = 'notifierPipe';
var PIPE_PATH_PREFIX = '\\\\.\\pipe\\';
module.exports = WindowsToaster;

function WindowsToaster(options) {
  options = utils.clone(options || {});

  if (!(this instanceof WindowsToaster)) {
    return new WindowsToaster(options);
  }

  this.options = options;
  EventEmitter.call(this);
}

util.inherits(WindowsToaster, EventEmitter);

function noop() {}

function parseResult(data) {
  if (!data) {
    return {};
  }

  return data.split(';').reduce(function (acc, cur) {
    var split = cur.split('=');

    if (split && split.length === 2) {
      acc[split[0]] = split[1];
    }

    return acc;
  }, {});
}

function getPipeName() {
  return "".concat(PIPE_PATH_PREFIX).concat(PIPE_NAME, "-").concat(uuid());
}

function notifyRaw(options, callback) {
  var _this = this;

  options = utils.clone(options || {});
  callback = callback || noop;
  var is64Bit = os.arch() === 'x64';
  var resultBuffer;
  var server = {
    namedPipe: getPipeName()
  };

  if (typeof options === 'string') {
    options = {
      title: 'node-notifier',
      message: options
    };
  }

  if (typeof callback !== 'function') {
    throw new TypeError('The second argument must be a function callback. You have passed ' + (typeof fn === "undefined" ? "undefined" : _typeof(fn)));
  }

  var snoreToastResultParser = function snoreToastResultParser(err, callback) {
    /* Possible exit statuses from SnoreToast, we only want to include err if it's -1 code
    Exit Status     :  Exit Code
    Failed          : -1
     Success         :  0
    Hidden          :  1
    Dismissed       :  2
    TimedOut        :  3
    ButtonPressed   :  4
    TextEntered     :  5
    */
    var result = parseResult(resultBuffer && resultBuffer.toString('utf16le')); // parse action

    if (result.action === 'buttonClicked' && result.button) {
      result.activationType = result.button;
    } else if (result.action) {
      result.activationType = result.action;
    }

    if (err && err.code === -1) {
      callback(err, result);
    }

    callback(null, result); // https://github.com/mikaelbr/node-notifier/issues/334
    // Due to an issue with snoretoast not using stdio and pipe
    // when notifications are disabled, make sure named pipe server
    // is closed before exiting.

    server.instance && server.instance.close();
  };

  var actionJackedCallback = function actionJackedCallback(err) {
    return snoreToastResultParser(err, utils.actionJackerDecorator(_this, options, callback, function (data) {
      return data || false;
    }));
  };

  options.title = options.title || 'Node Notification:';

  if (typeof options.message === 'undefined' && typeof options.close === 'undefined') {
    callback(new Error('Message or ID to close is required.'));
    return this;
  }

  if (!utils.isWin8() && !utils.isWSL() && !!this.options.withFallback) {
    fallback = fallback || new Balloon(this.options);
    return fallback.notify(options, callback);
  } // Add pipeName option, to get the output


  utils.createNamedPipe(server).then(function (out) {
    resultBuffer = out;
    options.pipeName = server.namedPipe;
    options = utils.mapToWin8(options);
    var argsList = utils.constructArgumentList(options, {
      explicitTrue: true,
      wrapper: '',
      keepNewlines: true,
      noEscape: true
    });
    var notifierWithArch = notifier + '-x' + (is64Bit ? '64' : '86') + '.exe';
    utils.fileCommand(_this.options.customPath || notifierWithArch, argsList, actionJackedCallback);
  });
  return this;
}

Object.defineProperty(WindowsToaster.prototype, 'notify', {
  get: function get() {
    if (!this._notify) this._notify = notifyRaw.bind(this);
    return this._notify;
  }
});