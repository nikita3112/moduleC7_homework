'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function path() {
  var data = _interopRequireWildcard(require('path'));

  path = function path() {
    return data;
  };

  return data;
}

function _chalk() {
  var data = _interopRequireDefault(require('chalk'));

  _chalk = function _chalk() {
    return data;
  };

  return data;
}

function _slash() {
  var data = _interopRequireDefault(require('slash'));

  _slash = function _slash() {
    return data;
  };

  return data;
}

function _jestUtil() {
  var data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

var _ModuleNotFoundError = _interopRequireDefault(require('./ModuleNotFoundError'));

var _defaultResolver = _interopRequireWildcard(require('./defaultResolver'));

var _isBuiltinModule = _interopRequireDefault(require('./isBuiltinModule'));

var _nodeModulesPaths = _interopRequireDefault(require('./nodeModulesPaths'));

var _shouldLoadAsEsm = _interopRequireWildcard(require('./shouldLoadAsEsm'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== 'function') return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var NATIVE_PLATFORM = 'native'; // We might be inside a symlink.

var resolvedCwd = (0, _jestUtil().tryRealpath)(process.cwd());
var NODE_PATH = process.env.NODE_PATH;
var nodePaths = NODE_PATH ? NODE_PATH.split(path().delimiter).filter(Boolean) // The resolver expects absolute paths.
.map(function (p) {
  return path().resolve(resolvedCwd, p);
}) : undefined;

var Resolver =
/*#__PURE__*/
function () {
  function Resolver(moduleMap, options) {
    _classCallCheck(this, Resolver);

    _defineProperty(this, '_options', void 0);

    _defineProperty(this, '_moduleMap', void 0);

    _defineProperty(this, '_moduleIDCache', void 0);

    _defineProperty(this, '_moduleNameCache', void 0);

    _defineProperty(this, '_modulePathCache', void 0);

    _defineProperty(this, '_supportsNativePlatform', void 0);

    this._options = {
      defaultPlatform: options.defaultPlatform,
      extensions: options.extensions,
      hasCoreModules: options.hasCoreModules === undefined ? true : options.hasCoreModules,
      moduleDirectories: options.moduleDirectories || ['node_modules'],
      moduleNameMapper: options.moduleNameMapper,
      modulePaths: options.modulePaths,
      platforms: options.platforms,
      resolver: options.resolver,
      rootDir: options.rootDir
    };
    this._supportsNativePlatform = options.platforms ? options.platforms.includes(NATIVE_PLATFORM) : false;
    this._moduleMap = moduleMap;
    this._moduleIDCache = new Map();
    this._moduleNameCache = new Map();
    this._modulePathCache = new Map();
  }

  _createClass(Resolver, [{
    key: "resolveModuleFromDirIfExists",
    // unstable as it should be replaced by https://github.com/nodejs/modules/issues/393, and we don't want people to use it
    value: function resolveModuleFromDirIfExists(dirname, moduleName, options) {
      var _this = this;

      var paths = options && options.paths || this._options.modulePaths;
      var moduleDirectory = this._options.moduleDirectories;
      var key = dirname + path().delimiter + moduleName;
      var defaultPlatform = this._options.defaultPlatform;

      var extensions = this._options.extensions.slice();

      var module;

      if (this._supportsNativePlatform) {
        extensions.unshift.apply(extensions, _toConsumableArray(this._options.extensions.map(function (ext) {
          return '.' + NATIVE_PLATFORM + ext;
        })));
      }

      if (defaultPlatform) {
        extensions.unshift.apply(extensions, _toConsumableArray(this._options.extensions.map(function (ext) {
          return '.' + defaultPlatform + ext;
        })));
      } // 1. If we have already resolved this module for this directory name,
      // return a value from the cache.


      var cacheResult = this._moduleNameCache.get(key);

      if (cacheResult) {
        return cacheResult;
      } // 2. Check if the module is a haste module.


      module = this.getModule(moduleName);

      if (module) {
        this._moduleNameCache.set(key, module);

        return module;
      } // 3. Check if the module is a node module and resolve it based on
      // the node module resolution algorithm. If skipNodeResolution is given we
      // ignore all modules that look like node modules (ie. are not relative
      // requires). This enables us to speed up resolution when we build a
      // dependency graph because we don't have to look at modules that may not
      // exist and aren't mocked.


      var skipResolution = options && options.skipNodeResolution && !moduleName.includes(path().sep);

      var resolveNodeModule = function resolveNodeModule(name) {
        var throwIfNotFound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        return Resolver.findNodeModule(name, {
          basedir: dirname,
          extensions: extensions,
          moduleDirectory: moduleDirectory,
          paths: paths,
          resolver: _this._options.resolver,
          rootDir: _this._options.rootDir,
          throwIfNotFound: throwIfNotFound
        });
      };

      if (!skipResolution) {
        module = resolveNodeModule(moduleName, Boolean(process.versions.pnp));

        if (module) {
          this._moduleNameCache.set(key, module);

          return module;
        }
      } // 4. Resolve "haste packages" which are `package.json` files outside of
      // `node_modules` folders anywhere in the file system.


      var parts = moduleName.split('/');
      var hastePackage = this.getPackage(parts.shift());

      if (hastePackage) {
        try {
          var _module = path().join.apply(path(), [path().dirname(hastePackage)].concat(parts)); // try resolving with custom resolver first to support extensions,
          // then fallback to require.resolve


          var resolvedModule = resolveNodeModule(_module) || require.resolve(_module);

          this._moduleNameCache.set(key, resolvedModule);

          return resolvedModule;
        } catch (_unused) {}
      }

      return null;
    }
  }, {
    key: "resolveModule",
    value: function resolveModule(from, moduleName, options) {
      var dirname = path().dirname(from);
      var module = this.resolveStubModuleName(from, moduleName) || this.resolveModuleFromDirIfExists(dirname, moduleName, options);
      if (module) return module; // 5. Throw an error if the module could not be found. `resolve.sync` only
      // produces an error based on the dirname but we have the actual current
      // module name available.

      var relativePath = (0, _slash()["default"])(path().relative(this._options.rootDir, from)) || '.';
      throw new _ModuleNotFoundError["default"]("Cannot find module '".concat(moduleName, "' from '").concat(relativePath, "'"), moduleName);
    }
  }, {
    key: "_isAliasModule",
    value: function _isAliasModule(moduleName) {
      var moduleNameMapper = this._options.moduleNameMapper;

      if (!moduleNameMapper) {
        return false;
      }

      return moduleNameMapper.some(function (_ref) {
        var regex = _ref.regex;
        return regex.test(moduleName);
      });
    }
  }, {
    key: "isCoreModule",
    value: function isCoreModule(moduleName) {
      return this._options.hasCoreModules && (0, _isBuiltinModule["default"])(moduleName) && !this._isAliasModule(moduleName);
    }
  }, {
    key: "getModule",
    value: function getModule(name) {
      return this._moduleMap.getModule(name, this._options.defaultPlatform, this._supportsNativePlatform);
    }
  }, {
    key: "getModulePath",
    value: function getModulePath(from, moduleName) {
      if (moduleName[0] !== '.' || path().isAbsolute(moduleName)) {
        return moduleName;
      }

      return path().normalize(path().dirname(from) + '/' + moduleName);
    }
  }, {
    key: "getPackage",
    value: function getPackage(name) {
      return this._moduleMap.getPackage(name, this._options.defaultPlatform, this._supportsNativePlatform);
    }
  }, {
    key: "getMockModule",
    value: function getMockModule(from, name) {
      var mock = this._moduleMap.getMockModule(name);

      if (mock) {
        return mock;
      } else {
        var moduleName = this.resolveStubModuleName(from, name);

        if (moduleName) {
          return this.getModule(moduleName) || moduleName;
        }
      }

      return null;
    }
  }, {
    key: "getModulePaths",
    value: function getModulePaths(from) {
      var cachedModule = this._modulePathCache.get(from);

      if (cachedModule) {
        return cachedModule;
      }

      var moduleDirectory = this._options.moduleDirectories;
      var paths = (0, _nodeModulesPaths["default"])(from, {
        moduleDirectory: moduleDirectory
      });

      if (paths[paths.length - 1] === undefined) {
        // circumvent node-resolve bug that adds `undefined` as last item.
        paths.pop();
      }

      this._modulePathCache.set(from, paths);

      return paths;
    }
  }, {
    key: "getModuleID",
    value: function getModuleID(virtualMocks, from, _moduleName) {
      var moduleName = _moduleName || '';
      var key = from + path().delimiter + moduleName;

      var cachedModuleID = this._moduleIDCache.get(key);

      if (cachedModuleID) {
        return cachedModuleID;
      }

      var moduleType = this._getModuleType(moduleName);

      var absolutePath = this._getAbsolutePath(virtualMocks, from, moduleName);

      var mockPath = this._getMockPath(from, moduleName);

      var sep = path().delimiter;
      var id = moduleType + sep + (absolutePath ? absolutePath + sep : '') + (mockPath ? mockPath + sep : '');

      this._moduleIDCache.set(key, id);

      return id;
    }
  }, {
    key: "_getModuleType",
    value: function _getModuleType(moduleName) {
      return this.isCoreModule(moduleName) ? 'node' : 'user';
    }
  }, {
    key: "_getAbsolutePath",
    value: function _getAbsolutePath(virtualMocks, from, moduleName) {
      if (this.isCoreModule(moduleName)) {
        return moduleName;
      }

      return this._isModuleResolved(from, moduleName) ? this.getModule(moduleName) : this._getVirtualMockPath(virtualMocks, from, moduleName);
    }
  }, {
    key: "_getMockPath",
    value: function _getMockPath(from, moduleName) {
      return !this.isCoreModule(moduleName) ? this.getMockModule(from, moduleName) : null;
    }
  }, {
    key: "_getVirtualMockPath",
    value: function _getVirtualMockPath(virtualMocks, from, moduleName) {
      var virtualMockPath = this.getModulePath(from, moduleName);
      return virtualMocks[virtualMockPath] ? virtualMockPath : moduleName ? this.resolveModule(from, moduleName) : from;
    }
  }, {
    key: "_isModuleResolved",
    value: function _isModuleResolved(from, moduleName) {
      return !!(this.getModule(moduleName) || this.getMockModule(from, moduleName));
    }
  }, {
    key: "resolveStubModuleName",
    value: function resolveStubModuleName(from, moduleName) {
      var _this2 = this;

      var dirname = path().dirname(from);
      var paths = this._options.modulePaths;

      var extensions = this._options.extensions.slice();

      var moduleDirectory = this._options.moduleDirectories;
      var moduleNameMapper = this._options.moduleNameMapper;
      var resolver = this._options.resolver;
      var defaultPlatform = this._options.defaultPlatform;

      if (this._supportsNativePlatform) {
        extensions.unshift.apply(extensions, _toConsumableArray(this._options.extensions.map(function (ext) {
          return '.' + NATIVE_PLATFORM + ext;
        })));
      }

      if (defaultPlatform) {
        extensions.unshift.apply(extensions, _toConsumableArray(this._options.extensions.map(function (ext) {
          return '.' + defaultPlatform + ext;
        })));
      }

      if (moduleNameMapper) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = moduleNameMapper[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = _step.value,
                mappedModuleName = _step$value.moduleName,
                regex = _step$value.regex;

            if (regex.test(moduleName)) {
              var _ret = function () {
                // Note: once a moduleNameMapper matches the name, it must result
                // in a module, or else an error is thrown.
                var matches = moduleName.match(regex);
                var mapModuleName = matches ? function (moduleName) {
                  return moduleName.replace(/\$([0-9]+)/g, function (_, index) {
                    return matches[parseInt(index, 10)];
                  });
                } : function (moduleName) {
                  return moduleName;
                };
                var possibleModuleNames = Array.isArray(mappedModuleName) ? mappedModuleName : [mappedModuleName];
                var module = null;
                var _iteratorNormalCompletion2 = true;
                var _didIteratorError2 = false;
                var _iteratorError2 = undefined;

                try {
                  for (var _iterator2 = possibleModuleNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    var possibleModuleName = _step2.value;
                    var updatedName = mapModuleName(possibleModuleName);
                    module = _this2.getModule(updatedName) || Resolver.findNodeModule(updatedName, {
                      basedir: dirname,
                      extensions: extensions,
                      moduleDirectory: moduleDirectory,
                      paths: paths,
                      resolver: resolver,
                      rootDir: _this2._options.rootDir
                    });

                    if (module) {
                      break;
                    }
                  }
                } catch (err) {
                  _didIteratorError2 = true;
                  _iteratorError2 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                      _iterator2["return"]();
                    }
                  } finally {
                    if (_didIteratorError2) {
                      throw _iteratorError2;
                    }
                  }
                }

                if (!module) {
                  throw createNoMappedModuleFoundError(moduleName, mapModuleName, mappedModuleName, regex, resolver);
                }

                return {
                  v: module
                };
              }();

              if (_typeof(_ret) === "object") return _ret.v;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      return null;
    }
  }], [{
    key: "tryCastModuleNotFoundError",
    value: function tryCastModuleNotFoundError(error) {
      if (error instanceof _ModuleNotFoundError["default"]) {
        return error;
      }

      var casted = error;

      if (casted.code === 'MODULE_NOT_FOUND') {
        return _ModuleNotFoundError["default"].duckType(casted);
      }

      return null;
    }
  }, {
    key: "clearDefaultResolverCache",
    value: function clearDefaultResolverCache() {
      (0, _defaultResolver.clearDefaultResolverCache)();
      (0, _shouldLoadAsEsm.clearCachedLookups)();
    }
  }, {
    key: "findNodeModule",
    value: function findNodeModule(path, options) {
      var resolver = options.resolver ? require(options.resolver) : _defaultResolver["default"];
      var paths = options.paths;

      try {
        return resolver(path, {
          basedir: options.basedir,
          browser: options.browser,
          defaultResolver: _defaultResolver["default"],
          extensions: options.extensions,
          moduleDirectory: options.moduleDirectory,
          paths: paths ? (nodePaths || []).concat(paths) : nodePaths,
          rootDir: options.rootDir
        });
      } catch (e) {
        if (options.throwIfNotFound) {
          throw e;
        }
      }

      return null;
    }
  }]);

  return Resolver;
}();

_defineProperty(Resolver, 'ModuleNotFoundError', _ModuleNotFoundError["default"]);

_defineProperty(Resolver, 'unstable_shouldLoadAsEsm', _shouldLoadAsEsm["default"]);

var createNoMappedModuleFoundError = function createNoMappedModuleFoundError(moduleName, mapModuleName, mappedModuleName, regex, resolver) {
  var mappedAs = Array.isArray(mappedModuleName) ? JSON.stringify(mappedModuleName.map(mapModuleName), null, 2) : mappedModuleName;
  var original = Array.isArray(mappedModuleName) ? JSON.stringify(mappedModuleName, null, 6) // using 6 because of misalignment when nested below
  .slice(0, -1) + '    ]' /// align last bracket correctly as well
  : mappedModuleName;
  var error = new Error(_chalk()["default"].red("".concat(_chalk()["default"].bold('Configuration error'), ":\n\nCould not locate module ").concat(_chalk()["default"].bold(moduleName), " mapped as:\n").concat(_chalk()["default"].bold(mappedAs), ".\n\nPlease check your configuration for these entries:\n{\n  \"moduleNameMapper\": {\n    \"").concat(regex.toString(), "\": \"").concat(_chalk()["default"].bold(original), "\"\n  },\n  \"resolver\": ").concat(_chalk()["default"].bold(String(resolver)), "\n}")));
  error.name = '';
  return error;
};

module.exports = Resolver;