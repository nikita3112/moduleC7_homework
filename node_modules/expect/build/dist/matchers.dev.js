'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

var _jestGetType = _interopRequireDefault(require('jest-get-type'));

var _jestMatcherUtils = require('jest-matcher-utils');

var _jasmineUtils = require('./jasmineUtils');

var _print = require('./print');

var _utils = require('./utils');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

/* eslint-disable local/ban-types-eventually */
// Omit colon and one or more spaces, so can call getLabelPrinter.


var EXPECTED_LABEL = 'Expected';
var RECEIVED_LABEL = 'Received';
var EXPECTED_VALUE_LABEL = 'Expected value';
var RECEIVED_VALUE_LABEL = 'Received value'; // The optional property of matcher context is true if undefined.

var isExpand = function isExpand(expand) {
  return expand !== false;
};

var toStrictEqualTesters = [_utils.iterableEquality, _utils.typeEquality, _utils.sparseArrayEquality];
var matchers = {
  toBe: function toBe(received, expected) {
    var _this = this;

    var matcherName = 'toBe';
    var options = {
      comment: 'Object.is equality',
      isNot: this.isNot,
      promise: this.promise
    };
    var pass = Object.is(received, expected);
    var message = pass ? function () {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + "Expected: not ".concat((0, _jestMatcherUtils.printExpected)(expected));
    } : function () {
      var expectedType = (0, _jestGetType["default"])(expected);
      var deepEqualityName = null;

      if (expectedType !== 'map' && expectedType !== 'set') {
        // If deep equality passes when referential identity fails,
        // but exclude map and set until review of their equality logic.
        if ((0, _jasmineUtils.equals)(received, expected, toStrictEqualTesters, true)) {
          deepEqualityName = 'toStrictEqual';
        } else if ((0, _jasmineUtils.equals)(received, expected, [_utils.iterableEquality])) {
          deepEqualityName = 'toEqual';
        }
      }

      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + (deepEqualityName !== null ? (0, _jestMatcherUtils.DIM_COLOR)("If it should pass with deep equality, replace \"".concat(matcherName, "\" with \"").concat(deepEqualityName, "\"")) + '\n\n' : '') + (0, _jestMatcherUtils.printDiffOrStringify)(expected, received, EXPECTED_LABEL, RECEIVED_LABEL, isExpand(_this.expand));
    }; // Passing the actual and expected objects so that a custom reporter
    // could access them, for example in order to display a custom visual diff,
    // or create a different error message

    return {
      actual: received,
      expected: expected,
      message: message,
      name: matcherName,
      pass: pass
    };
  },
  toBeCloseTo: function toBeCloseTo(received, expected) {
    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
    var matcherName = 'toBeCloseTo';
    var secondArgument = arguments.length === 3 ? 'precision' : undefined;
    var isNot = this.isNot;
    var options = {
      isNot: isNot,
      promise: this.promise,
      secondArgument: secondArgument,
      secondArgumentColor: function secondArgumentColor(arg) {
        return arg;
      }
    };

    if (typeof expected !== 'number') {
      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options), "".concat((0, _jestMatcherUtils.EXPECTED_COLOR)('expected'), " value must be a number"), (0, _jestMatcherUtils.printWithType)('Expected', expected, _jestMatcherUtils.printExpected)));
    }

    if (typeof received !== 'number') {
      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options), "".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), " value must be a number"), (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));
    }

    var pass = false;
    var expectedDiff = 0;
    var receivedDiff = 0;

    if (received === Infinity && expected === Infinity) {
      pass = true; // Infinity - Infinity is NaN
    } else if (received === -Infinity && expected === -Infinity) {
      pass = true; // -Infinity - -Infinity is NaN
    } else {
      expectedDiff = Math.pow(10, -precision) / 2;
      receivedDiff = Math.abs(expected - received);
      pass = receivedDiff < expectedDiff;
    }

    var message = pass ? function () {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + "Expected: not ".concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + (receivedDiff === 0 ? '' : "Received:     ".concat((0, _jestMatcherUtils.printReceived)(received), "\n") + '\n' + (0, _print.printCloseTo)(receivedDiff, expectedDiff, precision, isNot));
    } : function () {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + "Expected: ".concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + "Received: ".concat((0, _jestMatcherUtils.printReceived)(received), "\n") + '\n' + (0, _print.printCloseTo)(receivedDiff, expectedDiff, precision, isNot);
    };
    return {
      message: message,
      pass: pass
    };
  },
  toBeDefined: function toBeDefined(received, expected) {
    var matcherName = 'toBeDefined';
    var options = {
      isNot: this.isNot,
      promise: this.promise
    };
    (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);
    var pass = received !== void 0;

    var message = function message() {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, '', options) + '\n\n' + "Received: ".concat((0, _jestMatcherUtils.printReceived)(received));
    };

    return {
      message: message,
      pass: pass
    };
  },
  toBeFalsy: function toBeFalsy(received, expected) {
    var matcherName = 'toBeFalsy';
    var options = {
      isNot: this.isNot,
      promise: this.promise
    };
    (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);
    var pass = !received;

    var message = function message() {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, '', options) + '\n\n' + "Received: ".concat((0, _jestMatcherUtils.printReceived)(received));
    };

    return {
      message: message,
      pass: pass
    };
  },
  toBeGreaterThan: function toBeGreaterThan(received, expected) {
    var matcherName = 'toBeGreaterThan';
    var isNot = this.isNot;
    var options = {
      isNot: isNot,
      promise: this.promise
    };
    (0, _jestMatcherUtils.ensureNumbers)(received, expected, matcherName, options);
    var pass = received > expected;

    var message = function message() {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + "Expected:".concat(isNot ? ' not' : '', " > ").concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + "Received:".concat(isNot ? '    ' : '', "   ").concat((0, _jestMatcherUtils.printReceived)(received));
    };

    return {
      message: message,
      pass: pass
    };
  },
  toBeGreaterThanOrEqual: function toBeGreaterThanOrEqual(received, expected) {
    var matcherName = 'toBeGreaterThanOrEqual';
    var isNot = this.isNot;
    var options = {
      isNot: isNot,
      promise: this.promise
    };
    (0, _jestMatcherUtils.ensureNumbers)(received, expected, matcherName, options);
    var pass = received >= expected;

    var message = function message() {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + "Expected:".concat(isNot ? ' not' : '', " >= ").concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + "Received:".concat(isNot ? '    ' : '', "    ").concat((0, _jestMatcherUtils.printReceived)(received));
    };

    return {
      message: message,
      pass: pass
    };
  },
  toBeInstanceOf: function toBeInstanceOf(received, expected) {
    var matcherName = 'toBeInstanceOf';
    var options = {
      isNot: this.isNot,
      promise: this.promise
    };

    if (typeof expected !== 'function') {
      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options), "".concat((0, _jestMatcherUtils.EXPECTED_COLOR)('expected'), " value must be a function"), (0, _jestMatcherUtils.printWithType)('Expected', expected, _jestMatcherUtils.printExpected)));
    }

    var pass = received instanceof expected;
    var message = pass ? function () {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + (0, _print.printExpectedConstructorNameNot)('Expected constructor', expected) + (typeof received.constructor === 'function' && received.constructor !== expected ? (0, _print.printReceivedConstructorNameNot)('Received constructor', received.constructor, expected) : '');
    } : function () {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + (0, _print.printExpectedConstructorName)('Expected constructor', expected) + (_jestGetType["default"].isPrimitive(received) || Object.getPrototypeOf(received) === null ? "\nReceived value has no prototype\nReceived value: ".concat((0, _jestMatcherUtils.printReceived)(received)) : typeof received.constructor !== 'function' ? "\nReceived value: ".concat((0, _jestMatcherUtils.printReceived)(received)) : (0, _print.printReceivedConstructorName)('Received constructor', received.constructor));
    };
    return {
      message: message,
      pass: pass
    };
  },
  toBeLessThan: function toBeLessThan(received, expected) {
    var matcherName = 'toBeLessThan';
    var isNot = this.isNot;
    var options = {
      isNot: isNot,
      promise: this.promise
    };
    (0, _jestMatcherUtils.ensureNumbers)(received, expected, matcherName, options);
    var pass = received < expected;

    var message = function message() {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + "Expected:".concat(isNot ? ' not' : '', " < ").concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + "Received:".concat(isNot ? '    ' : '', "   ").concat((0, _jestMatcherUtils.printReceived)(received));
    };

    return {
      message: message,
      pass: pass
    };
  },
  toBeLessThanOrEqual: function toBeLessThanOrEqual(received, expected) {
    var matcherName = 'toBeLessThanOrEqual';
    var isNot = this.isNot;
    var options = {
      isNot: isNot,
      promise: this.promise
    };
    (0, _jestMatcherUtils.ensureNumbers)(received, expected, matcherName, options);
    var pass = received <= expected;

    var message = function message() {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + "Expected:".concat(isNot ? ' not' : '', " <= ").concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + "Received:".concat(isNot ? '    ' : '', "    ").concat((0, _jestMatcherUtils.printReceived)(received));
    };

    return {
      message: message,
      pass: pass
    };
  },
  toBeNaN: function toBeNaN(received, expected) {
    var matcherName = 'toBeNaN';
    var options = {
      isNot: this.isNot,
      promise: this.promise
    };
    (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);
    var pass = Number.isNaN(received);

    var message = function message() {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, '', options) + '\n\n' + "Received: ".concat((0, _jestMatcherUtils.printReceived)(received));
    };

    return {
      message: message,
      pass: pass
    };
  },
  toBeNull: function toBeNull(received, expected) {
    var matcherName = 'toBeNull';
    var options = {
      isNot: this.isNot,
      promise: this.promise
    };
    (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);
    var pass = received === null;

    var message = function message() {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, '', options) + '\n\n' + "Received: ".concat((0, _jestMatcherUtils.printReceived)(received));
    };

    return {
      message: message,
      pass: pass
    };
  },
  toBeTruthy: function toBeTruthy(received, expected) {
    var matcherName = 'toBeTruthy';
    var options = {
      isNot: this.isNot,
      promise: this.promise
    };
    (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);
    var pass = !!received;

    var message = function message() {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, '', options) + '\n\n' + "Received: ".concat((0, _jestMatcherUtils.printReceived)(received));
    };

    return {
      message: message,
      pass: pass
    };
  },
  toBeUndefined: function toBeUndefined(received, expected) {
    var matcherName = 'toBeUndefined';
    var options = {
      isNot: this.isNot,
      promise: this.promise
    };
    (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);
    var pass = received === void 0;

    var message = function message() {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, '', options) + '\n\n' + "Received: ".concat((0, _jestMatcherUtils.printReceived)(received));
    };

    return {
      message: message,
      pass: pass
    };
  },
  toContain: function toContain(received, expected) {
    var matcherName = 'toContain';
    var isNot = this.isNot;
    var options = {
      comment: 'indexOf',
      isNot: isNot,
      promise: this.promise
    };

    if (received == null) {
      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options), "".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), " value must not be null nor undefined"), (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));
    }

    if (typeof received === 'string') {
      var _index = received.indexOf(String(expected));

      var _pass = _index !== -1;

      var _message = function _message() {
        var labelExpected = "Expected ".concat(typeof expected === 'string' ? 'substring' : 'value');
        var labelReceived = 'Received string';
        var printLabel = (0, _jestMatcherUtils.getLabelPrinter)(labelExpected, labelReceived);
        return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + "".concat(printLabel(labelExpected)).concat(isNot ? 'not ' : '').concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + "".concat(printLabel(labelReceived)).concat(isNot ? '    ' : '').concat(isNot ? (0, _print.printReceivedStringContainExpectedSubstring)(received, _index, String(expected).length) : (0, _jestMatcherUtils.printReceived)(received));
      };

      return {
        message: _message,
        pass: _pass
      };
    }

    var indexable = Array.from(received);
    var index = indexable.indexOf(expected);
    var pass = index !== -1;

    var message = function message() {
      var labelExpected = 'Expected value';
      var labelReceived = "Received ".concat((0, _jestGetType["default"])(received));
      var printLabel = (0, _jestMatcherUtils.getLabelPrinter)(labelExpected, labelReceived);
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + "".concat(printLabel(labelExpected)).concat(isNot ? 'not ' : '').concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + "".concat(printLabel(labelReceived)).concat(isNot ? '    ' : '').concat(isNot && Array.isArray(received) ? (0, _print.printReceivedArrayContainExpectedItem)(received, index) : (0, _jestMatcherUtils.printReceived)(received)) + (!isNot && indexable.findIndex(function (item) {
        return (0, _jasmineUtils.equals)(item, expected, [_utils.iterableEquality]);
      }) !== -1 ? "\n\n".concat(_jestMatcherUtils.SUGGEST_TO_CONTAIN_EQUAL) : '');
    };

    return {
      message: message,
      pass: pass
    };
  },
  toContainEqual: function toContainEqual(received, expected) {
    var matcherName = 'toContainEqual';
    var isNot = this.isNot;
    var options = {
      comment: 'deep equality',
      isNot: isNot,
      promise: this.promise
    };

    if (received == null) {
      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options), "".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), " value must not be null nor undefined"), (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));
    }

    var index = Array.from(received).findIndex(function (item) {
      return (0, _jasmineUtils.equals)(item, expected, [_utils.iterableEquality]);
    });
    var pass = index !== -1;

    var message = function message() {
      var labelExpected = 'Expected value';
      var labelReceived = "Received ".concat((0, _jestGetType["default"])(received));
      var printLabel = (0, _jestMatcherUtils.getLabelPrinter)(labelExpected, labelReceived);
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + "".concat(printLabel(labelExpected)).concat(isNot ? 'not ' : '').concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + "".concat(printLabel(labelReceived)).concat(isNot ? '    ' : '').concat(isNot && Array.isArray(received) ? (0, _print.printReceivedArrayContainExpectedItem)(received, index) : (0, _jestMatcherUtils.printReceived)(received));
    };

    return {
      message: message,
      pass: pass
    };
  },
  toEqual: function toEqual(received, expected) {
    var _this2 = this;

    var matcherName = 'toEqual';
    var options = {
      comment: 'deep equality',
      isNot: this.isNot,
      promise: this.promise
    };
    var pass = (0, _jasmineUtils.equals)(received, expected, [_utils.iterableEquality]);
    var message = pass ? function () {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + "Expected: not ".concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + ((0, _jestMatcherUtils.stringify)(expected) !== (0, _jestMatcherUtils.stringify)(received) ? "Received:     ".concat((0, _jestMatcherUtils.printReceived)(received)) : '');
    } : function () {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + (0, _jestMatcherUtils.printDiffOrStringify)(expected, received, EXPECTED_LABEL, RECEIVED_LABEL, isExpand(_this2.expand));
    }; // Passing the actual and expected objects so that a custom reporter
    // could access them, for example in order to display a custom visual diff,
    // or create a different error message

    return {
      actual: received,
      expected: expected,
      message: message,
      name: matcherName,
      pass: pass
    };
  },
  toHaveLength: function toHaveLength(received, expected) {
    var matcherName = 'toHaveLength';
    var isNot = this.isNot;
    var options = {
      isNot: isNot,
      promise: this.promise
    };

    if (typeof (received === null || received === void 0 ? void 0 : received.length) !== 'number') {
      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options), "".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), " value must have a length property whose value must be a number"), (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));
    }

    (0, _jestMatcherUtils.ensureExpectedIsNonNegativeInteger)(expected, matcherName, options);
    var pass = received.length === expected;

    var message = function message() {
      var labelExpected = 'Expected length';
      var labelReceivedLength = 'Received length';
      var labelReceivedValue = "Received ".concat((0, _jestGetType["default"])(received));
      var printLabel = (0, _jestMatcherUtils.getLabelPrinter)(labelExpected, labelReceivedLength, labelReceivedValue);
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + "".concat(printLabel(labelExpected)).concat(isNot ? 'not ' : '').concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + (isNot ? '' : "".concat(printLabel(labelReceivedLength)).concat((0, _jestMatcherUtils.printReceived)(received.length), "\n")) + "".concat(printLabel(labelReceivedValue)).concat(isNot ? '    ' : '').concat((0, _jestMatcherUtils.printReceived)(received));
    };

    return {
      message: message,
      pass: pass
    };
  },
  toHaveProperty: function toHaveProperty(received, expectedPath, expectedValue) {
    var _this3 = this;

    var matcherName = 'toHaveProperty';
    var expectedArgument = 'path';
    var hasValue = arguments.length === 3;
    var options = {
      isNot: this.isNot,
      promise: this.promise,
      secondArgument: hasValue ? 'value' : ''
    };

    if (received === null || received === undefined) {
      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options), "".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), " value must not be null nor undefined"), (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));
    }

    var expectedPathType = (0, _jestGetType["default"])(expectedPath);

    if (expectedPathType !== 'string' && expectedPathType !== 'array') {
      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options), "".concat((0, _jestMatcherUtils.EXPECTED_COLOR)('expected'), " path must be a string or array"), (0, _jestMatcherUtils.printWithType)('Expected', expectedPath, _jestMatcherUtils.printExpected)));
    }

    var expectedPathLength = typeof expectedPath === 'string' ? expectedPath.split('.').length : expectedPath.length;

    if (expectedPathType === 'array' && expectedPathLength === 0) {
      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options), "".concat((0, _jestMatcherUtils.EXPECTED_COLOR)('expected'), " path must not be an empty array"), (0, _jestMatcherUtils.printWithType)('Expected', expectedPath, _jestMatcherUtils.printExpected)));
    }

    var result = (0, _utils.getPath)(received, expectedPath);
    var lastTraversedObject = result.lastTraversedObject,
        hasEndProp = result.hasEndProp;
    var receivedPath = result.traversedPath;
    var hasCompletePath = receivedPath.length === expectedPathLength;
    var receivedValue = hasCompletePath ? result.value : lastTraversedObject;
    var pass = hasValue ? (0, _jasmineUtils.equals)(result.value, expectedValue, [_utils.iterableEquality]) : Boolean(hasEndProp); // theoretically undefined if empty path
    // Remove type cast if we rewrite getPath as iterative algorithm.
    // Delete this unique report if future breaking change
    // removes the edge case that expected value undefined
    // also matches absence of a property with the key path.

    if (pass && !hasCompletePath) {
      var _message2 = function _message2() {
        return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options) + '\n\n' + "Expected path: ".concat((0, _jestMatcherUtils.printExpected)(expectedPath), "\n") + "Received path: ".concat((0, _jestMatcherUtils.printReceived)(expectedPathType === 'array' || receivedPath.length === 0 ? receivedPath : receivedPath.join('.')), "\n\n") + "Expected value: not ".concat((0, _jestMatcherUtils.printExpected)(expectedValue), "\n") + "Received value:     ".concat((0, _jestMatcherUtils.printReceived)(receivedValue), "\n\n") + (0, _jestMatcherUtils.DIM_COLOR)('Because a positive assertion passes for expected value undefined if the property does not exist, this negative assertion fails unless the property does exist and has a defined value');
      };

      return {
        message: _message2,
        pass: pass
      };
    }

    var message = pass ? function () {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options) + '\n\n' + (hasValue ? "Expected path: ".concat((0, _jestMatcherUtils.printExpected)(expectedPath), "\n\n") + "Expected value: not ".concat((0, _jestMatcherUtils.printExpected)(expectedValue)) + ((0, _jestMatcherUtils.stringify)(expectedValue) !== (0, _jestMatcherUtils.stringify)(receivedValue) ? "\nReceived value:     ".concat((0, _jestMatcherUtils.printReceived)(receivedValue)) : '') : "Expected path: not ".concat((0, _jestMatcherUtils.printExpected)(expectedPath), "\n\n") + "Received value: ".concat((0, _jestMatcherUtils.printReceived)(receivedValue)));
    } : function () {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options) + '\n\n' + "Expected path: ".concat((0, _jestMatcherUtils.printExpected)(expectedPath), "\n") + (hasCompletePath ? '\n' + (0, _jestMatcherUtils.printDiffOrStringify)(expectedValue, receivedValue, EXPECTED_VALUE_LABEL, RECEIVED_VALUE_LABEL, isExpand(_this3.expand)) : "Received path: ".concat((0, _jestMatcherUtils.printReceived)(expectedPathType === 'array' || receivedPath.length === 0 ? receivedPath : receivedPath.join('.')), "\n\n") + (hasValue ? "Expected value: ".concat((0, _jestMatcherUtils.printExpected)(expectedValue), "\n") : '') + "Received value: ".concat((0, _jestMatcherUtils.printReceived)(receivedValue)));
    };
    return {
      message: message,
      pass: pass
    };
  },
  toMatch: function toMatch(received, expected) {
    var matcherName = 'toMatch';
    var options = {
      isNot: this.isNot,
      promise: this.promise
    };

    if (typeof received !== 'string') {
      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options), "".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), " value must be a string"), (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));
    }

    if (!(typeof expected === 'string') && !(expected && typeof expected.test === 'function')) {
      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options), "".concat((0, _jestMatcherUtils.EXPECTED_COLOR)('expected'), " value must be a string or regular expression"), (0, _jestMatcherUtils.printWithType)('Expected', expected, _jestMatcherUtils.printExpected)));
    }

    var pass = typeof expected === 'string' ? received.includes(expected) : new RegExp(expected).test(received);
    var message = pass ? function () {
      return typeof expected === 'string' ? (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + "Expected substring: not ".concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + "Received string:        ".concat((0, _print.printReceivedStringContainExpectedSubstring)(received, received.indexOf(expected), expected.length)) : (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + "Expected pattern: not ".concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + "Received string:      ".concat((0, _print.printReceivedStringContainExpectedResult)(received, typeof expected.exec === 'function' ? expected.exec(received) : null));
    } : function () {
      var labelExpected = "Expected ".concat(typeof expected === 'string' ? 'substring' : 'pattern');
      var labelReceived = 'Received string';
      var printLabel = (0, _jestMatcherUtils.getLabelPrinter)(labelExpected, labelReceived);
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + "".concat(printLabel(labelExpected)).concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + "".concat(printLabel(labelReceived)).concat((0, _jestMatcherUtils.printReceived)(received));
    };
    return {
      message: message,
      pass: pass
    };
  },
  toMatchObject: function toMatchObject(received, expected) {
    var _this4 = this;

    var matcherName = 'toMatchObject';
    var options = {
      isNot: this.isNot,
      promise: this.promise
    };

    if (_typeof(received) !== 'object' || received === null) {
      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options), "".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), " value must be a non-null object"), (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));
    }

    if (_typeof(expected) !== 'object' || expected === null) {
      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options), "".concat((0, _jestMatcherUtils.EXPECTED_COLOR)('expected'), " value must be a non-null object"), (0, _jestMatcherUtils.printWithType)('Expected', expected, _jestMatcherUtils.printExpected)));
    }

    var pass = (0, _jasmineUtils.equals)(received, expected, [_utils.iterableEquality, _utils.subsetEquality]);
    var message = pass ? function () {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + "Expected: not ".concat((0, _jestMatcherUtils.printExpected)(expected)) + ((0, _jestMatcherUtils.stringify)(expected) !== (0, _jestMatcherUtils.stringify)(received) ? "\nReceived:     ".concat((0, _jestMatcherUtils.printReceived)(received)) : '');
    } : function () {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + (0, _jestMatcherUtils.printDiffOrStringify)(expected, (0, _utils.getObjectSubset)(received, expected), EXPECTED_LABEL, RECEIVED_LABEL, isExpand(_this4.expand));
    };
    return {
      message: message,
      pass: pass
    };
  },
  toStrictEqual: function toStrictEqual(received, expected) {
    var _this5 = this;

    var matcherName = 'toStrictEqual';
    var options = {
      comment: 'deep equality',
      isNot: this.isNot,
      promise: this.promise
    };
    var pass = (0, _jasmineUtils.equals)(received, expected, toStrictEqualTesters, true);
    var message = pass ? function () {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + "Expected: not ".concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + ((0, _jestMatcherUtils.stringify)(expected) !== (0, _jestMatcherUtils.stringify)(received) ? "Received:     ".concat((0, _jestMatcherUtils.printReceived)(received)) : '');
    } : function () {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, undefined, undefined, options) + '\n\n' + (0, _jestMatcherUtils.printDiffOrStringify)(expected, received, EXPECTED_LABEL, RECEIVED_LABEL, isExpand(_this5.expand));
    }; // Passing the actual and expected objects so that a custom reporter
    // could access them, for example in order to display a custom visual diff,
    // or create a different error message

    return {
      actual: received,
      expected: expected,
      message: message,
      name: matcherName,
      pass: pass
    };
  }
};
var _default = matchers;
exports["default"] = _default;