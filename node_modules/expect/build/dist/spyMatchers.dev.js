'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

var _jestGetType = _interopRequireDefault(require('jest-get-type'));

var _jestMatcherUtils = require('jest-matcher-utils');

var _jasmineUtils = require('./jasmineUtils');

var _utils = require('./utils');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// The optional property of matcher context is true if undefined.


var isExpand = function isExpand(expand) {
  return expand !== false;
};

var PRINT_LIMIT = 3;
var NO_ARGUMENTS = 'called with 0 arguments';

var printExpectedArgs = function printExpectedArgs(expected) {
  return expected.length === 0 ? NO_ARGUMENTS : expected.map(function (arg) {
    return (0, _jestMatcherUtils.printExpected)(arg);
  }).join(', ');
};

var printReceivedArgs = function printReceivedArgs(received, expected) {
  return received.length === 0 ? NO_ARGUMENTS : received.map(function (arg, i) {
    return Array.isArray(expected) && i < expected.length && isEqualValue(expected[i], arg) ? printCommon(arg) : (0, _jestMatcherUtils.printReceived)(arg);
  }).join(', ');
};

var printCommon = function printCommon(val) {
  return (0, _jestMatcherUtils.DIM_COLOR)((0, _jestMatcherUtils.stringify)(val));
};

var isEqualValue = function isEqualValue(expected, received) {
  return (0, _jasmineUtils.equals)(expected, received, [_utils.iterableEquality]);
};

var isEqualCall = function isEqualCall(expected, received) {
  return isEqualValue(expected, received);
};

var isEqualReturn = function isEqualReturn(expected, result) {
  return result.type === 'return' && isEqualValue(expected, result.value);
};

var countReturns = function countReturns(results) {
  return results.reduce(function (n, result) {
    return result.type === 'return' ? n + 1 : n;
  }, 0);
};

var printNumberOfReturns = function printNumberOfReturns(countReturns, countCalls) {
  return "\nNumber of returns: ".concat((0, _jestMatcherUtils.printReceived)(countReturns)) + (countCalls !== countReturns ? "\nNumber of calls:   ".concat((0, _jestMatcherUtils.printReceived)(countCalls)) : '');
}; // Given a label, return a function which given a string,
// right-aligns it preceding the colon in the label.


var getRightAlignedPrinter = function getRightAlignedPrinter(label) {
  // Assume that the label contains a colon.
  var index = label.indexOf(':');
  var suffix = label.slice(index);
  return function (string, isExpectedCall) {
    return (isExpectedCall ? '->' + ' '.repeat(Math.max(0, index - 2 - string.length)) : ' '.repeat(Math.max(index - string.length))) + string + suffix;
  };
};

var printReceivedCallsNegative = function printReceivedCallsNegative(expected, indexedCalls, isOnlyCall, iExpectedCall) {
  if (indexedCalls.length === 0) {
    return '';
  }

  var label = 'Received:     ';

  if (isOnlyCall) {
    return label + printReceivedArgs(indexedCalls[0], expected) + '\n';
  }

  var printAligned = getRightAlignedPrinter(label);
  return 'Received\n' + indexedCalls.reduce(function (printed, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        i = _ref2[0],
        args = _ref2[1];

    return printed + printAligned(String(i + 1), i === iExpectedCall) + printReceivedArgs(args, expected) + '\n';
  }, '');
};

var printExpectedReceivedCallsPositive = function printExpectedReceivedCallsPositive(expected, indexedCalls, expand, isOnlyCall, iExpectedCall) {
  var expectedLine = "Expected: ".concat(printExpectedArgs(expected), "\n");

  if (indexedCalls.length === 0) {
    return expectedLine;
  }

  var label = 'Received: ';

  if (isOnlyCall && (iExpectedCall === 0 || iExpectedCall === undefined)) {
    var received = indexedCalls[0][1];

    if (isLineDiffableCall(expected, received)) {
      // Display diff without indentation.
      var lines = [(0, _jestMatcherUtils.EXPECTED_COLOR)('- Expected'), (0, _jestMatcherUtils.RECEIVED_COLOR)('+ Received'), ''];
      var length = Math.max(expected.length, received.length);

      for (var i = 0; i < length; i += 1) {
        if (i < expected.length && i < received.length) {
          if (isEqualValue(expected[i], received[i])) {
            lines.push("  ".concat(printCommon(received[i]), ","));
            continue;
          }

          if (isLineDiffableArg(expected[i], received[i])) {
            var difference = (0, _jestMatcherUtils.diff)(expected[i], received[i], {
              expand: expand
            });

            if (typeof difference === 'string' && difference.includes('- Expected') && difference.includes('+ Received')) {
              // Omit annotation in case multiple args have diff.
              lines.push(difference.split('\n').slice(3).join('\n') + ',');
              continue;
            }
          }
        }

        if (i < expected.length) {
          lines.push((0, _jestMatcherUtils.EXPECTED_COLOR)('- ' + (0, _jestMatcherUtils.stringify)(expected[i])) + ',');
        }

        if (i < received.length) {
          lines.push((0, _jestMatcherUtils.RECEIVED_COLOR)('+ ' + (0, _jestMatcherUtils.stringify)(received[i])) + ',');
        }
      }

      return lines.join('\n') + '\n';
    }

    return expectedLine + label + printReceivedArgs(received, expected) + '\n';
  }

  var printAligned = getRightAlignedPrinter(label);
  return expectedLine + 'Received\n' + indexedCalls.reduce(function (printed, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        i = _ref4[0],
        received = _ref4[1];

    var aligned = printAligned(String(i + 1), i === iExpectedCall);
    return printed + ((i === iExpectedCall || iExpectedCall === undefined) && isLineDiffableCall(expected, received) ? aligned.replace(': ', '\n') + printDiffCall(expected, received, expand) : aligned + printReceivedArgs(received, expected)) + '\n';
  }, '');
};

var indentation = 'Received'.replace(/\w/g, ' ');

var printDiffCall = function printDiffCall(expected, received, expand) {
  return received.map(function (arg, i) {
    if (i < expected.length) {
      if (isEqualValue(expected[i], arg)) {
        return indentation + '  ' + printCommon(arg) + ',';
      }

      if (isLineDiffableArg(expected[i], arg)) {
        var difference = (0, _jestMatcherUtils.diff)(expected[i], arg, {
          expand: expand
        });

        if (typeof difference === 'string' && difference.includes('- Expected') && difference.includes('+ Received')) {
          // Display diff with indentation.
          // Omit annotation in case multiple args have diff.
          return difference.split('\n').slice(3).map(function (line) {
            return indentation + line;
          }).join('\n') + ',';
        }
      }
    } // Display + only if received arg has no corresponding expected arg.


    return indentation + (i < expected.length ? '  ' + (0, _jestMatcherUtils.printReceived)(arg) : (0, _jestMatcherUtils.RECEIVED_COLOR)('+ ' + (0, _jestMatcherUtils.stringify)(arg))) + ',';
  }).join('\n');
};

var isLineDiffableCall = function isLineDiffableCall(expected, received) {
  return expected.some(function (arg, i) {
    return i < received.length && isLineDiffableArg(arg, received[i]);
  });
}; // Almost redundant with function in jest-matcher-utils,
// except no line diff for any strings.


var isLineDiffableArg = function isLineDiffableArg(expected, received) {
  var expectedType = (0, _jestGetType["default"])(expected);
  var receivedType = (0, _jestGetType["default"])(received);

  if (expectedType !== receivedType) {
    return false;
  }

  if (_jestGetType["default"].isPrimitive(expected)) {
    return false;
  }

  if (expectedType === 'date' || expectedType === 'function' || expectedType === 'regexp') {
    return false;
  }

  if (expected instanceof Error && received instanceof Error) {
    return false;
  }

  if (expectedType === 'object' && typeof expected.asymmetricMatch === 'function') {
    return false;
  }

  if (receivedType === 'object' && typeof received.asymmetricMatch === 'function') {
    return false;
  }

  return true;
};

var printResult = function printResult(result, expected) {
  return result.type === 'throw' ? 'function call threw an error' : result.type === 'incomplete' ? 'function call has not returned yet' : isEqualValue(expected, result.value) ? printCommon(result.value) : (0, _jestMatcherUtils.printReceived)(result.value);
}; // Return either empty string or one line per indexed result,
// so additional empty line can separate from `Number of returns` which follows.


var printReceivedResults = function printReceivedResults(label, expected, indexedResults, isOnlyCall, iExpectedCall) {
  if (indexedResults.length === 0) {
    return '';
  }

  if (isOnlyCall && (iExpectedCall === 0 || iExpectedCall === undefined)) {
    return label + printResult(indexedResults[0][1], expected) + '\n';
  }

  var printAligned = getRightAlignedPrinter(label);
  return label.replace(':', '').trim() + '\n' + indexedResults.reduce(function (printed, _ref5) {
    var _ref6 = _slicedToArray(_ref5, 2),
        i = _ref6[0],
        result = _ref6[1];

    return printed + printAligned(String(i + 1), i === iExpectedCall) + printResult(result, expected) + '\n';
  }, '');
};

var createToBeCalledMatcher = function createToBeCalledMatcher(matcherName) {
  return function (received, expected) {
    var expectedArgument = '';
    var options = {
      isNot: this.isNot,
      promise: this.promise
    };
    (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);
    ensureMockOrSpy(received, matcherName, expectedArgument, options);
    var receivedIsSpy = isSpy(received);
    var receivedName = receivedIsSpy ? 'spy' : received.getMockName();
    var count = receivedIsSpy ? received.calls.count() : received.mock.calls.length;
    var calls = receivedIsSpy ? received.calls.all().map(function (x) {
      return x.args;
    }) : received.mock.calls;
    var pass = count > 0;
    var message = pass ? function () {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\n\n' + "Expected number of calls: ".concat((0, _jestMatcherUtils.printExpected)(0), "\n") + "Received number of calls: ".concat((0, _jestMatcherUtils.printReceived)(count), "\n\n") + calls.reduce(function (lines, args, i) {
        if (lines.length < PRINT_LIMIT) {
          lines.push("".concat(i + 1, ": ").concat(printReceivedArgs(args)));
        }

        return lines;
      }, []).join('\n');
    } : function () {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\n\n' + "Expected number of calls: >= ".concat((0, _jestMatcherUtils.printExpected)(1), "\n") + "Received number of calls:    ".concat((0, _jestMatcherUtils.printReceived)(count));
    };
    return {
      message: message,
      pass: pass
    };
  };
};

var createToReturnMatcher = function createToReturnMatcher(matcherName) {
  return function (received, expected) {
    var expectedArgument = '';
    var options = {
      isNot: this.isNot,
      promise: this.promise
    };
    (0, _jestMatcherUtils.ensureNoExpected)(expected, matcherName, options);
    ensureMock(received, matcherName, expectedArgument, options);
    var receivedName = received.getMockName(); // Count return values that correspond only to calls that returned

    var count = received.mock.results.reduce(function (n, result) {
      return result.type === 'return' ? n + 1 : n;
    }, 0);
    var pass = count > 0;
    var message = pass ? function () {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\n\n' + "Expected number of returns: ".concat((0, _jestMatcherUtils.printExpected)(0), "\n") + "Received number of returns: ".concat((0, _jestMatcherUtils.printReceived)(count), "\n\n") + received.mock.results.reduce(function (lines, result, i) {
        if (result.type === 'return' && lines.length < PRINT_LIMIT) {
          lines.push("".concat(i + 1, ": ").concat((0, _jestMatcherUtils.printReceived)(result.value)));
        }

        return lines;
      }, []).join('\n') + (received.mock.calls.length !== count ? "\n\nReceived number of calls:   ".concat((0, _jestMatcherUtils.printReceived)(received.mock.calls.length)) : '');
    } : function () {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\n\n' + "Expected number of returns: >= ".concat((0, _jestMatcherUtils.printExpected)(1), "\n") + "Received number of returns:    ".concat((0, _jestMatcherUtils.printReceived)(count)) + (received.mock.calls.length !== count ? "\nReceived number of calls:      ".concat((0, _jestMatcherUtils.printReceived)(received.mock.calls.length)) : '');
    };
    return {
      message: message,
      pass: pass
    };
  };
};

var createToBeCalledTimesMatcher = function createToBeCalledTimesMatcher(matcherName) {
  return function (received, expected) {
    var expectedArgument = 'expected';
    var options = {
      isNot: this.isNot,
      promise: this.promise
    };
    (0, _jestMatcherUtils.ensureExpectedIsNonNegativeInteger)(expected, matcherName, options);
    ensureMockOrSpy(received, matcherName, expectedArgument, options);
    var receivedIsSpy = isSpy(received);
    var receivedName = receivedIsSpy ? 'spy' : received.getMockName();
    var count = receivedIsSpy ? received.calls.count() : received.mock.calls.length;
    var pass = count === expected;
    var message = pass ? function () {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + "\n\n" + "Expected number of calls: not ".concat((0, _jestMatcherUtils.printExpected)(expected));
    } : function () {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\n\n' + "Expected number of calls: ".concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + "Received number of calls: ".concat((0, _jestMatcherUtils.printReceived)(count));
    };
    return {
      message: message,
      pass: pass
    };
  };
};

var createToReturnTimesMatcher = function createToReturnTimesMatcher(matcherName) {
  return function (received, expected) {
    var expectedArgument = 'expected';
    var options = {
      isNot: this.isNot,
      promise: this.promise
    };
    (0, _jestMatcherUtils.ensureExpectedIsNonNegativeInteger)(expected, matcherName, options);
    ensureMock(received, matcherName, expectedArgument, options);
    var receivedName = received.getMockName(); // Count return values that correspond only to calls that returned

    var count = received.mock.results.reduce(function (n, result) {
      return result.type === 'return' ? n + 1 : n;
    }, 0);
    var pass = count === expected;
    var message = pass ? function () {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + "\n\n" + "Expected number of returns: not ".concat((0, _jestMatcherUtils.printExpected)(expected)) + (received.mock.calls.length !== count ? "\n\nReceived number of calls:       ".concat((0, _jestMatcherUtils.printReceived)(received.mock.calls.length)) : '');
    } : function () {
      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\n\n' + "Expected number of returns: ".concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + "Received number of returns: ".concat((0, _jestMatcherUtils.printReceived)(count)) + (received.mock.calls.length !== count ? "\nReceived number of calls:   ".concat((0, _jestMatcherUtils.printReceived)(received.mock.calls.length)) : '');
    };
    return {
      message: message,
      pass: pass
    };
  };
};

var createToBeCalledWithMatcher = function createToBeCalledWithMatcher(matcherName) {
  return function (received) {
    var _this = this;

    for (var _len = arguments.length, expected = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      expected[_key - 1] = arguments[_key];
    }

    var expectedArgument = '...expected';
    var options = {
      isNot: this.isNot,
      promise: this.promise
    };
    ensureMockOrSpy(received, matcherName, expectedArgument, options);
    var receivedIsSpy = isSpy(received);
    var receivedName = receivedIsSpy ? 'spy' : received.getMockName();
    var calls = receivedIsSpy ? received.calls.all().map(function (x) {
      return x.args;
    }) : received.mock.calls;
    var pass = calls.some(function (call) {
      return isEqualCall(expected, call);
    });
    var message = pass ? function () {
      // Some examples of calls that are equal to expected value.
      var indexedCalls = [];
      var i = 0;

      while (i < calls.length && indexedCalls.length < PRINT_LIMIT) {
        if (isEqualCall(expected, calls[i])) {
          indexedCalls.push([i, calls[i]]);
        }

        i += 1;
      }

      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\n\n' + "Expected: not ".concat(printExpectedArgs(expected), "\n") + (calls.length === 1 && (0, _jestMatcherUtils.stringify)(calls[0]) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedCallsNegative(expected, indexedCalls, calls.length === 1)) + "\nNumber of calls: ".concat((0, _jestMatcherUtils.printReceived)(calls.length));
    } : function () {
      // Some examples of calls that are not equal to expected value.
      var indexedCalls = [];
      var i = 0;

      while (i < calls.length && indexedCalls.length < PRINT_LIMIT) {
        indexedCalls.push([i, calls[i]]);
        i += 1;
      }

      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\n\n' + printExpectedReceivedCallsPositive(expected, indexedCalls, isExpand(_this.expand), calls.length === 1) + "\nNumber of calls: ".concat((0, _jestMatcherUtils.printReceived)(calls.length));
    };
    return {
      message: message,
      pass: pass
    };
  };
};

var createToReturnWithMatcher = function createToReturnWithMatcher(matcherName) {
  return function (received, expected) {
    var expectedArgument = 'expected';
    var options = {
      isNot: this.isNot,
      promise: this.promise
    };
    ensureMock(received, matcherName, expectedArgument, options);
    var receivedName = received.getMockName();
    var _received$mock = received.mock,
        calls = _received$mock.calls,
        results = _received$mock.results;
    var pass = results.some(function (result) {
      return isEqualReturn(expected, result);
    });
    var message = pass ? function () {
      // Some examples of results that are equal to expected value.
      var indexedResults = [];
      var i = 0;

      while (i < results.length && indexedResults.length < PRINT_LIMIT) {
        if (isEqualReturn(expected, results[i])) {
          indexedResults.push([i, results[i]]);
        }

        i += 1;
      }

      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\n\n' + "Expected: not ".concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + (results.length === 1 && results[0].type === 'return' && (0, _jestMatcherUtils.stringify)(results[0].value) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedResults('Received:     ', expected, indexedResults, results.length === 1)) + printNumberOfReturns(countReturns(results), calls.length);
    } : function () {
      // Some examples of results that are not equal to expected value.
      var indexedResults = [];
      var i = 0;

      while (i < results.length && indexedResults.length < PRINT_LIMIT) {
        indexedResults.push([i, results[i]]);
        i += 1;
      }

      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\n\n' + "Expected: ".concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + printReceivedResults('Received: ', expected, indexedResults, results.length === 1) + printNumberOfReturns(countReturns(results), calls.length);
    };
    return {
      message: message,
      pass: pass
    };
  };
};

var createLastCalledWithMatcher = function createLastCalledWithMatcher(matcherName) {
  return function (received) {
    var _this2 = this;

    for (var _len2 = arguments.length, expected = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      expected[_key2 - 1] = arguments[_key2];
    }

    var expectedArgument = '...expected';
    var options = {
      isNot: this.isNot,
      promise: this.promise
    };
    ensureMockOrSpy(received, matcherName, expectedArgument, options);
    var receivedIsSpy = isSpy(received);
    var receivedName = receivedIsSpy ? 'spy' : received.getMockName();
    var calls = receivedIsSpy ? received.calls.all().map(function (x) {
      return x.args;
    }) : received.mock.calls;
    var iLast = calls.length - 1;
    var pass = iLast >= 0 && isEqualCall(expected, calls[iLast]);
    var message = pass ? function () {
      var indexedCalls = [];

      if (iLast > 0) {
        // Display preceding call as context.
        indexedCalls.push([iLast - 1, calls[iLast - 1]]);
      }

      indexedCalls.push([iLast, calls[iLast]]);
      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\n\n' + "Expected: not ".concat(printExpectedArgs(expected), "\n") + (calls.length === 1 && (0, _jestMatcherUtils.stringify)(calls[0]) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedCallsNegative(expected, indexedCalls, calls.length === 1, iLast)) + "\nNumber of calls: ".concat((0, _jestMatcherUtils.printReceived)(calls.length));
    } : function () {
      var indexedCalls = [];

      if (iLast >= 0) {
        if (iLast > 0) {
          var i = iLast - 1; // Is there a preceding call that is equal to expected args?

          while (i >= 0 && !isEqualCall(expected, calls[i])) {
            i -= 1;
          }

          if (i < 0) {
            i = iLast - 1; // otherwise, preceding call
          }

          indexedCalls.push([i, calls[i]]);
        }

        indexedCalls.push([iLast, calls[iLast]]);
      }

      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\n\n' + printExpectedReceivedCallsPositive(expected, indexedCalls, isExpand(_this2.expand), calls.length === 1, iLast) + "\nNumber of calls: ".concat((0, _jestMatcherUtils.printReceived)(calls.length));
    };
    return {
      message: message,
      pass: pass
    };
  };
};

var createLastReturnedMatcher = function createLastReturnedMatcher(matcherName) {
  return function (received, expected) {
    var expectedArgument = 'expected';
    var options = {
      isNot: this.isNot,
      promise: this.promise
    };
    ensureMock(received, matcherName, expectedArgument, options);
    var receivedName = received.getMockName();
    var _received$mock2 = received.mock,
        calls = _received$mock2.calls,
        results = _received$mock2.results;
    var iLast = results.length - 1;
    var pass = iLast >= 0 && isEqualReturn(expected, results[iLast]);
    var message = pass ? function () {
      var indexedResults = [];

      if (iLast > 0) {
        // Display preceding result as context.
        indexedResults.push([iLast - 1, results[iLast - 1]]);
      }

      indexedResults.push([iLast, results[iLast]]);
      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\n\n' + "Expected: not ".concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + (results.length === 1 && results[0].type === 'return' && (0, _jestMatcherUtils.stringify)(results[0].value) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedResults('Received:     ', expected, indexedResults, results.length === 1, iLast)) + printNumberOfReturns(countReturns(results), calls.length);
    } : function () {
      var indexedResults = [];

      if (iLast >= 0) {
        if (iLast > 0) {
          var i = iLast - 1; // Is there a preceding result that is equal to expected value?

          while (i >= 0 && !isEqualReturn(expected, results[i])) {
            i -= 1;
          }

          if (i < 0) {
            i = iLast - 1; // otherwise, preceding result
          }

          indexedResults.push([i, results[i]]);
        }

        indexedResults.push([iLast, results[iLast]]);
      }

      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\n\n' + "Expected: ".concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + printReceivedResults('Received: ', expected, indexedResults, results.length === 1, iLast) + printNumberOfReturns(countReturns(results), calls.length);
    };
    return {
      message: message,
      pass: pass
    };
  };
};

var createNthCalledWithMatcher = function createNthCalledWithMatcher(matcherName) {
  return function (received, nth) {
    var _this3 = this;

    for (var _len3 = arguments.length, expected = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
      expected[_key3 - 2] = arguments[_key3];
    }

    var expectedArgument = 'n';
    var options = {
      expectedColor: function expectedColor(arg) {
        return arg;
      },
      isNot: this.isNot,
      promise: this.promise,
      secondArgument: '...expected'
    };
    ensureMockOrSpy(received, matcherName, expectedArgument, options);

    if (!Number.isSafeInteger(nth) || nth < 1) {
      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options), "".concat(expectedArgument, " must be a positive integer"), (0, _jestMatcherUtils.printWithType)(expectedArgument, nth, _jestMatcherUtils.stringify)));
    }

    var receivedIsSpy = isSpy(received);
    var receivedName = receivedIsSpy ? 'spy' : received.getMockName();
    var calls = receivedIsSpy ? received.calls.all().map(function (x) {
      return x.args;
    }) : received.mock.calls;
    var length = calls.length;
    var iNth = nth - 1;
    var pass = iNth < length && isEqualCall(expected, calls[iNth]);
    var message = pass ? function () {
      // Display preceding and following calls,
      // in case assertions fails because index is off by one.
      var indexedCalls = [];

      if (iNth - 1 >= 0) {
        indexedCalls.push([iNth - 1, calls[iNth - 1]]);
      }

      indexedCalls.push([iNth, calls[iNth]]);

      if (iNth + 1 < length) {
        indexedCalls.push([iNth + 1, calls[iNth + 1]]);
      }

      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\n\n' + "n: ".concat(nth, "\n") + "Expected: not ".concat(printExpectedArgs(expected), "\n") + (calls.length === 1 && (0, _jestMatcherUtils.stringify)(calls[0]) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedCallsNegative(expected, indexedCalls, calls.length === 1, iNth)) + "\nNumber of calls: ".concat((0, _jestMatcherUtils.printReceived)(calls.length));
    } : function () {
      // Display preceding and following calls:
      // * nearest call that is equal to expected args
      // * otherwise, adjacent call
      // in case assertions fails because of index, especially off by one.
      var indexedCalls = [];

      if (iNth < length) {
        if (iNth - 1 >= 0) {
          var i = iNth - 1; // Is there a preceding call that is equal to expected args?

          while (i >= 0 && !isEqualCall(expected, calls[i])) {
            i -= 1;
          }

          if (i < 0) {
            i = iNth - 1; // otherwise, adjacent call
          }

          indexedCalls.push([i, calls[i]]);
        }

        indexedCalls.push([iNth, calls[iNth]]);

        if (iNth + 1 < length) {
          var _i2 = iNth + 1; // Is there a following call that is equal to expected args?


          while (_i2 < length && !isEqualCall(expected, calls[_i2])) {
            _i2 += 1;
          }

          if (_i2 >= length) {
            _i2 = iNth + 1; // otherwise, adjacent call
          }

          indexedCalls.push([_i2, calls[_i2]]);
        }
      } else if (length > 0) {
        // The number of received calls is fewer than the expected number.
        var _i3 = length - 1; // Is there a call that is equal to expected args?


        while (_i3 >= 0 && !isEqualCall(expected, calls[_i3])) {
          _i3 -= 1;
        }

        if (_i3 < 0) {
          _i3 = length - 1; // otherwise, last call
        }

        indexedCalls.push([_i3, calls[_i3]]);
      }

      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\n\n' + "n: ".concat(nth, "\n") + printExpectedReceivedCallsPositive(expected, indexedCalls, isExpand(_this3.expand), calls.length === 1, iNth) + "\nNumber of calls: ".concat((0, _jestMatcherUtils.printReceived)(calls.length));
    };
    return {
      message: message,
      pass: pass
    };
  };
};

var createNthReturnedWithMatcher = function createNthReturnedWithMatcher(matcherName) {
  return function (received, nth, expected) {
    var expectedArgument = 'n';
    var options = {
      expectedColor: function expectedColor(arg) {
        return arg;
      },
      isNot: this.isNot,
      promise: this.promise,
      secondArgument: 'expected'
    };
    ensureMock(received, matcherName, expectedArgument, options);

    if (!Number.isSafeInteger(nth) || nth < 1) {
      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options), "".concat(expectedArgument, " must be a positive integer"), (0, _jestMatcherUtils.printWithType)(expectedArgument, nth, _jestMatcherUtils.stringify)));
    }

    var receivedName = received.getMockName();
    var _received$mock3 = received.mock,
        calls = _received$mock3.calls,
        results = _received$mock3.results;
    var length = results.length;
    var iNth = nth - 1;
    var pass = iNth < length && isEqualReturn(expected, results[iNth]);
    var message = pass ? function () {
      // Display preceding and following results,
      // in case assertions fails because index is off by one.
      var indexedResults = [];

      if (iNth - 1 >= 0) {
        indexedResults.push([iNth - 1, results[iNth - 1]]);
      }

      indexedResults.push([iNth, results[iNth]]);

      if (iNth + 1 < length) {
        indexedResults.push([iNth + 1, results[iNth + 1]]);
      }

      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\n\n' + "n: ".concat(nth, "\n") + "Expected: not ".concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + (results.length === 1 && results[0].type === 'return' && (0, _jestMatcherUtils.stringify)(results[0].value) === (0, _jestMatcherUtils.stringify)(expected) ? '' : printReceivedResults('Received:     ', expected, indexedResults, results.length === 1, iNth)) + printNumberOfReturns(countReturns(results), calls.length);
    } : function () {
      // Display preceding and following results:
      // * nearest result that is equal to expected value
      // * otherwise, adjacent result
      // in case assertions fails because of index, especially off by one.
      var indexedResults = [];

      if (iNth < length) {
        if (iNth - 1 >= 0) {
          var i = iNth - 1; // Is there a preceding result that is equal to expected value?

          while (i >= 0 && !isEqualReturn(expected, results[i])) {
            i -= 1;
          }

          if (i < 0) {
            i = iNth - 1; // otherwise, adjacent result
          }

          indexedResults.push([i, results[i]]);
        }

        indexedResults.push([iNth, results[iNth]]);

        if (iNth + 1 < length) {
          var _i4 = iNth + 1; // Is there a following result that is equal to expected value?


          while (_i4 < length && !isEqualReturn(expected, results[_i4])) {
            _i4 += 1;
          }

          if (_i4 >= length) {
            _i4 = iNth + 1; // otherwise, adjacent result
          }

          indexedResults.push([_i4, results[_i4]]);
        }
      } else if (length > 0) {
        // The number of received calls is fewer than the expected number.
        var _i5 = length - 1; // Is there a result that is equal to expected value?


        while (_i5 >= 0 && !isEqualReturn(expected, results[_i5])) {
          _i5 -= 1;
        }

        if (_i5 < 0) {
          _i5 = length - 1; // otherwise, last result
        }

        indexedResults.push([_i5, results[_i5]]);
      }

      return (0, _jestMatcherUtils.matcherHint)(matcherName, receivedName, expectedArgument, options) + '\n\n' + "n: ".concat(nth, "\n") + "Expected: ".concat((0, _jestMatcherUtils.printExpected)(expected), "\n") + printReceivedResults('Received: ', expected, indexedResults, results.length === 1, iNth) + printNumberOfReturns(countReturns(results), calls.length);
    };
    return {
      message: message,
      pass: pass
    };
  };
};

var spyMatchers = {
  lastCalledWith: createLastCalledWithMatcher('lastCalledWith'),
  lastReturnedWith: createLastReturnedMatcher('lastReturnedWith'),
  nthCalledWith: createNthCalledWithMatcher('nthCalledWith'),
  nthReturnedWith: createNthReturnedWithMatcher('nthReturnedWith'),
  toBeCalled: createToBeCalledMatcher('toBeCalled'),
  toBeCalledTimes: createToBeCalledTimesMatcher('toBeCalledTimes'),
  toBeCalledWith: createToBeCalledWithMatcher('toBeCalledWith'),
  toHaveBeenCalled: createToBeCalledMatcher('toHaveBeenCalled'),
  toHaveBeenCalledTimes: createToBeCalledTimesMatcher('toHaveBeenCalledTimes'),
  toHaveBeenCalledWith: createToBeCalledWithMatcher('toHaveBeenCalledWith'),
  toHaveBeenLastCalledWith: createLastCalledWithMatcher('toHaveBeenLastCalledWith'),
  toHaveBeenNthCalledWith: createNthCalledWithMatcher('toHaveBeenNthCalledWith'),
  toHaveLastReturnedWith: createLastReturnedMatcher('toHaveLastReturnedWith'),
  toHaveNthReturnedWith: createNthReturnedWithMatcher('toHaveNthReturnedWith'),
  toHaveReturned: createToReturnMatcher('toHaveReturned'),
  toHaveReturnedTimes: createToReturnTimesMatcher('toHaveReturnedTimes'),
  toHaveReturnedWith: createToReturnWithMatcher('toHaveReturnedWith'),
  toReturn: createToReturnMatcher('toReturn'),
  toReturnTimes: createToReturnTimesMatcher('toReturnTimes'),
  toReturnWith: createToReturnWithMatcher('toReturnWith')
};

var isMock = function isMock(received) {
  return received != null && received._isMockFunction === true;
};

var isSpy = function isSpy(received) {
  return received != null && received.calls != null && typeof received.calls.all === 'function' && typeof received.calls.count === 'function';
};

var ensureMockOrSpy = function ensureMockOrSpy(received, matcherName, expectedArgument, options) {
  if (!isMock(received) && !isSpy(received)) {
    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options), "".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), " value must be a mock or spy function"), (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));
  }
};

var ensureMock = function ensureMock(received, matcherName, expectedArgument, options) {
  if (!isMock(received)) {
    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, expectedArgument, options), "".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), " value must be a mock function"), (0, _jestMatcherUtils.printWithType)('Received', received, _jestMatcherUtils.printReceived)));
  }
};

var _default = spyMatchers;
exports["default"] = _default;