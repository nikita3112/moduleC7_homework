'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function path() {
  var data = _interopRequireWildcard(require('path'));

  path = function path() {
    return data;
  };

  return data;
}

function _jestSnapshot() {
  var data = require('jest-snapshot');

  _jestSnapshot = function _jestSnapshot() {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== 'function') return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
/**
 * DependencyResolver is used to resolve the direct dependencies of a module or
 * to retrieve a list of all transitive inverse dependencies.
 */


var DependencyResolver =
/*#__PURE__*/
function () {
  function DependencyResolver(resolver, hasteFS, snapshotResolver) {
    _classCallCheck(this, DependencyResolver);

    _defineProperty(this, '_hasteFS', void 0);

    _defineProperty(this, '_resolver', void 0);

    _defineProperty(this, '_snapshotResolver', void 0);

    this._resolver = resolver;
    this._hasteFS = hasteFS;
    this._snapshotResolver = snapshotResolver;
  }

  _createClass(DependencyResolver, [{
    key: "resolve",
    value: function resolve(file, options) {
      var _this = this;

      var dependencies = this._hasteFS.getDependencies(file);

      if (!dependencies) {
        return [];
      }

      return dependencies.reduce(function (acc, dependency) {
        if (_this._resolver.isCoreModule(dependency)) {
          return acc;
        }

        var resolvedDependency;
        var resolvedMockDependency;

        try {
          resolvedDependency = _this._resolver.resolveModule(file, dependency, options);
        } catch (_unused) {
          try {
            resolvedDependency = _this._resolver.getMockModule(file, dependency);
          } catch (_unused2) {// leave resolvedDependency as undefined if nothing can be found
          }
        }

        if (!resolvedDependency) {
          return acc;
        }

        acc.push(resolvedDependency); // If we resolve a dependency, then look for a mock dependency
        // of the same name in that dependency's directory.

        try {
          resolvedMockDependency = _this._resolver.getMockModule(resolvedDependency, path().basename(dependency));
        } catch (_unused3) {// leave resolvedMockDependency as undefined if nothing can be found
        }

        if (resolvedMockDependency) {
          var dependencyMockDir = path().resolve(path().dirname(resolvedDependency), '__mocks__');
          resolvedMockDependency = path().resolve(resolvedMockDependency); // make sure mock is in the correct directory

          if (dependencyMockDir === path().dirname(resolvedMockDependency)) {
            acc.push(resolvedMockDependency);
          }
        }

        return acc;
      }, []);
    }
  }, {
    key: "resolveInverseModuleMap",
    value: function resolveInverseModuleMap(paths, filter, options) {
      if (!paths.size) {
        return [];
      }

      var collectModules = function collectModules(related, moduleMap, changed) {
        var visitedModules = new Set();
        var result = [];

        while (changed.size) {
          changed = new Set(moduleMap.reduce(function (acc, module) {
            if (visitedModules.has(module.file) || !module.dependencies.some(function (dep) {
              return changed.has(dep);
            })) {
              return acc;
            }

            var file = module.file;

            if (filter(file)) {
              result.push(module);
              related["delete"](file);
            }

            visitedModules.add(file);
            acc.push(file);
            return acc;
          }, []));
        }

        return result.concat(Array.from(related).map(function (file) {
          return {
            dependencies: [],
            file: file
          };
        }));
      };

      var relatedPaths = new Set();
      var changed = new Set();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = paths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _path = _step.value;

          if (this._hasteFS.exists(_path)) {
            var modulePath = (0, _jestSnapshot().isSnapshotPath)(_path) ? this._snapshotResolver.resolveTestPath(_path) : _path;
            changed.add(modulePath);

            if (filter(modulePath)) {
              relatedPaths.add(modulePath);
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var modules = [];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this._hasteFS.getAbsoluteFileIterator()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var file = _step2.value;
          modules.push({
            dependencies: this.resolve(file, options),
            file: file
          });
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return collectModules(relatedPaths, modules, changed);
    }
  }, {
    key: "resolveInverse",
    value: function resolveInverse(paths, filter, options) {
      return this.resolveInverseModuleMap(paths, filter, options).map(function (module) {
        return module.file;
      });
    }
  }]);

  return DependencyResolver;
}();

module.exports = DependencyResolver;