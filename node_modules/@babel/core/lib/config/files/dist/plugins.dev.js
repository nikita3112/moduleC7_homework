"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolvePlugin = resolvePlugin;
exports.resolvePreset = resolvePreset;
exports.loadPlugin = loadPlugin;
exports.loadPreset = loadPreset;

function _debug() {
  var data = _interopRequireDefault(require("debug"));

  _debug = function _debug() {
    return data;
  };

  return data;
}

function _path() {
  var data = _interopRequireDefault(require("path"));

  _path = function _path() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var debug = (0, _debug()["default"])("babel:config:loading:files:plugins");
var EXACT_RE = /^module:/;
var BABEL_PLUGIN_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-plugin-)/;
var BABEL_PRESET_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-preset-)/;
var BABEL_PLUGIN_ORG_RE = /^(@babel\/)(?!plugin-|[^/]+\/)/;
var BABEL_PRESET_ORG_RE = /^(@babel\/)(?!preset-|[^/]+\/)/;
var OTHER_PLUGIN_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/;
var OTHER_PRESET_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/;
var OTHER_ORG_DEFAULT_RE = /^(@(?!babel$)[^/]+)$/;

function resolvePlugin(name, dirname) {
  return resolveStandardizedName("plugin", name, dirname);
}

function resolvePreset(name, dirname) {
  return resolveStandardizedName("preset", name, dirname);
}

function loadPlugin(name, dirname) {
  var filepath = resolvePlugin(name, dirname);

  if (!filepath) {
    throw new Error("Plugin ".concat(name, " not found relative to ").concat(dirname));
  }

  var value = requireModule("plugin", filepath);
  debug("Loaded plugin %o from %o.", name, dirname);
  return {
    filepath: filepath,
    value: value
  };
}

function loadPreset(name, dirname) {
  var filepath = resolvePreset(name, dirname);

  if (!filepath) {
    throw new Error("Preset ".concat(name, " not found relative to ").concat(dirname));
  }

  var value = requireModule("preset", filepath);
  debug("Loaded preset %o from %o.", name, dirname);
  return {
    filepath: filepath,
    value: value
  };
}

function standardizeName(type, name) {
  if (_path()["default"].isAbsolute(name)) return name;
  var isPreset = type === "preset";
  return name.replace(isPreset ? BABEL_PRESET_PREFIX_RE : BABEL_PLUGIN_PREFIX_RE, "babel-".concat(type, "-")).replace(isPreset ? BABEL_PRESET_ORG_RE : BABEL_PLUGIN_ORG_RE, "$1".concat(type, "-")).replace(isPreset ? OTHER_PRESET_ORG_RE : OTHER_PLUGIN_ORG_RE, "$1babel-".concat(type, "-")).replace(OTHER_ORG_DEFAULT_RE, "$1/babel-".concat(type)).replace(EXACT_RE, "");
}

function resolveStandardizedName(type, name) {
  var dirname = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : process.cwd();
  var standardizedName = standardizeName(type, name);

  try {
    return (parseFloat(process.versions.node) >= 8.9 ? require.resolve : function (r, _ref) {
      var _ref$paths = _slicedToArray(_ref.paths, 1),
          b = _ref$paths[0];

      var M = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : require("module");

      var f = M._findPath(r, M._nodeModulePaths(b).concat(b));

      if (f) return f;
      f = new Error("Cannot resolve module '".concat(r, "'"));
      f.code = "MODULE_NOT_FOUND";
      throw f;
    })(standardizedName, {
      paths: [dirname]
    });
  } catch (e) {
    if (e.code !== "MODULE_NOT_FOUND") throw e;

    if (standardizedName !== name) {
      var resolvedOriginal = false;

      try {
        (parseFloat(process.versions.node) >= 8.9 ? require.resolve : function (r, _ref2) {
          var _ref2$paths = _slicedToArray(_ref2.paths, 1),
              b = _ref2$paths[0];

          var M = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : require("module");

          var f = M._findPath(r, M._nodeModulePaths(b).concat(b));

          if (f) return f;
          f = new Error("Cannot resolve module '".concat(r, "'"));
          f.code = "MODULE_NOT_FOUND";
          throw f;
        })(name, {
          paths: [dirname]
        });
        resolvedOriginal = true;
      } catch (_unused) {}

      if (resolvedOriginal) {
        e.message += "\n- If you want to resolve \"".concat(name, "\", use \"module:").concat(name, "\"");
      }
    }

    var resolvedBabel = false;

    try {
      (parseFloat(process.versions.node) >= 8.9 ? require.resolve : function (r, _ref3) {
        var _ref3$paths = _slicedToArray(_ref3.paths, 1),
            b = _ref3$paths[0];

        var M = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : require("module");

        var f = M._findPath(r, M._nodeModulePaths(b).concat(b));

        if (f) return f;
        f = new Error("Cannot resolve module '".concat(r, "'"));
        f.code = "MODULE_NOT_FOUND";
        throw f;
      })(standardizeName(type, "@babel/" + name), {
        paths: [dirname]
      });
      resolvedBabel = true;
    } catch (_unused2) {}

    if (resolvedBabel) {
      e.message += "\n- Did you mean \"@babel/".concat(name, "\"?");
    }

    var resolvedOppositeType = false;
    var oppositeType = type === "preset" ? "plugin" : "preset";

    try {
      (parseFloat(process.versions.node) >= 8.9 ? require.resolve : function (r, _ref4) {
        var _ref4$paths = _slicedToArray(_ref4.paths, 1),
            b = _ref4$paths[0];

        var M = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : require("module");

        var f = M._findPath(r, M._nodeModulePaths(b).concat(b));

        if (f) return f;
        f = new Error("Cannot resolve module '".concat(r, "'"));
        f.code = "MODULE_NOT_FOUND";
        throw f;
      })(standardizeName(oppositeType, name), {
        paths: [dirname]
      });
      resolvedOppositeType = true;
    } catch (_unused3) {}

    if (resolvedOppositeType) {
      e.message += "\n- Did you accidentally pass a ".concat(oppositeType, " as a ").concat(type, "?");
    }

    throw e;
  }
}

var LOADING_MODULES = new Set();

function requireModule(type, name) {
  if (LOADING_MODULES.has(name)) {
    throw new Error("Reentrant ".concat(type, " detected trying to load \"").concat(name, "\". This module is not ignored ") + "and is trying to load itself while compiling itself, leading to a dependency cycle. " + 'We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.');
  }

  try {
    LOADING_MODULES.add(name);
    return require(name);
  } finally {
    LOADING_MODULES["delete"](name);
  }
}