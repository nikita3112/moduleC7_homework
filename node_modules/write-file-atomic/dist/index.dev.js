'use strict';

module.exports = writeFile;
module.exports.sync = writeFileSync;
module.exports._getTmpname = getTmpname; // for testing

module.exports._cleanupOnExit = cleanupOnExit;

var fs = require('fs');

var MurmurHash3 = require('imurmurhash');

var onExit = require('signal-exit');

var path = require('path');

var isTypedArray = require('is-typedarray');

var typedArrayToBuffer = require('typedarray-to-buffer');

var _require = require('util'),
    promisify = _require.promisify;

var activeFiles = {}; // if we run inside of a worker_thread, `process.pid` is not unique

/* istanbul ignore next */

var threadId = function getId() {
  try {
    var workerThreads = require('worker_threads'); /// if we are in main thread, this is set to `0`


    return workerThreads.threadId;
  } catch (e) {
    // worker_threads are not available, fallback to 0
    return 0;
  }
}();

var invocations = 0;

function getTmpname(filename) {
  return filename + '.' + MurmurHash3(__filename).hash(String(process.pid)).hash(String(threadId)).hash(String(++invocations)).result();
}

function cleanupOnExit(tmpfile) {
  return function () {
    try {
      fs.unlinkSync(typeof tmpfile === 'function' ? tmpfile() : tmpfile);
    } catch (_) {}
  };
}

function serializeActiveFile(absoluteName) {
  return new Promise(function (resolve) {
    // make a queue if it doesn't already exist
    if (!activeFiles[absoluteName]) activeFiles[absoluteName] = [];
    activeFiles[absoluteName].push(resolve); // add this job to the queue

    if (activeFiles[absoluteName].length === 1) resolve(); // kick off the first one
  });
} // https://github.com/isaacs/node-graceful-fs/blob/master/polyfills.js#L315-L342


function isChownErrOk(err) {
  if (err.code === 'ENOSYS') {
    return true;
  }

  var nonroot = !process.getuid || process.getuid() !== 0;

  if (nonroot) {
    if (err.code === 'EINVAL' || err.code === 'EPERM') {
      return true;
    }
  }

  return false;
}

function writeFileAsync(filename, data) {
  var options,
      fd,
      tmpfile,
      removeOnExitHandler,
      absoluteName,
      truename,
      stats,
      _args = arguments;
  return regeneratorRuntime.async(function writeFileAsync$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};

          if (typeof options === 'string') {
            options = {
              encoding: options
            };
          }

          /* istanbul ignore next -- The closure only gets called when onExit triggers */
          removeOnExitHandler = onExit(cleanupOnExit(function () {
            return tmpfile;
          }));
          absoluteName = path.resolve(filename);
          _context.prev = 4;
          _context.next = 7;
          return regeneratorRuntime.awrap(serializeActiveFile(absoluteName));

        case 7:
          _context.next = 9;
          return regeneratorRuntime.awrap(promisify(fs.realpath)(filename)["catch"](function () {
            return filename;
          }));

        case 9:
          truename = _context.sent;
          tmpfile = getTmpname(truename);

          if (!(!options.mode || !options.chown)) {
            _context.next = 16;
            break;
          }

          _context.next = 14;
          return regeneratorRuntime.awrap(promisify(fs.stat)(truename)["catch"](function () {}));

        case 14:
          stats = _context.sent;

          if (stats) {
            if (options.mode == null) {
              options.mode = stats.mode;
            }

            if (options.chown == null && process.getuid) {
              options.chown = {
                uid: stats.uid,
                gid: stats.gid
              };
            }
          }

        case 16:
          _context.next = 18;
          return regeneratorRuntime.awrap(promisify(fs.open)(tmpfile, 'w', options.mode));

        case 18:
          fd = _context.sent;

          if (!options.tmpfileCreated) {
            _context.next = 22;
            break;
          }

          _context.next = 22;
          return regeneratorRuntime.awrap(options.tmpfileCreated(tmpfile));

        case 22:
          if (isTypedArray(data)) {
            data = typedArrayToBuffer(data);
          }

          if (!Buffer.isBuffer(data)) {
            _context.next = 28;
            break;
          }

          _context.next = 26;
          return regeneratorRuntime.awrap(promisify(fs.write)(fd, data, 0, data.length, 0));

        case 26:
          _context.next = 31;
          break;

        case 28:
          if (!(data != null)) {
            _context.next = 31;
            break;
          }

          _context.next = 31;
          return regeneratorRuntime.awrap(promisify(fs.write)(fd, String(data), 0, String(options.encoding || 'utf8')));

        case 31:
          if (!(options.fsync !== false)) {
            _context.next = 34;
            break;
          }

          _context.next = 34;
          return regeneratorRuntime.awrap(promisify(fs.fsync)(fd));

        case 34:
          _context.next = 36;
          return regeneratorRuntime.awrap(promisify(fs.close)(fd));

        case 36:
          fd = null;

          if (!options.chown) {
            _context.next = 40;
            break;
          }

          _context.next = 40;
          return regeneratorRuntime.awrap(promisify(fs.chown)(tmpfile, options.chown.uid, options.chown.gid)["catch"](function (err) {
            if (!isChownErrOk(err)) {
              throw err;
            }
          }));

        case 40:
          if (!options.mode) {
            _context.next = 43;
            break;
          }

          _context.next = 43;
          return regeneratorRuntime.awrap(promisify(fs.chmod)(tmpfile, options.mode)["catch"](function (err) {
            if (!isChownErrOk(err)) {
              throw err;
            }
          }));

        case 43:
          _context.next = 45;
          return regeneratorRuntime.awrap(promisify(fs.rename)(tmpfile, truename));

        case 45:
          _context.prev = 45;

          if (!fd) {
            _context.next = 49;
            break;
          }

          _context.next = 49;
          return regeneratorRuntime.awrap(promisify(fs.close)(fd)["catch"](
          /* istanbul ignore next */
          function () {}));

        case 49:
          removeOnExitHandler();
          _context.next = 52;
          return regeneratorRuntime.awrap(promisify(fs.unlink)(tmpfile)["catch"](function () {}));

        case 52:
          activeFiles[absoluteName].shift(); // remove the element added by serializeSameFile

          if (activeFiles[absoluteName].length > 0) {
            activeFiles[absoluteName][0](); // start next job if one is pending
          } else delete activeFiles[absoluteName];

          return _context.finish(45);

        case 55:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[4,, 45, 55]]);
}

function writeFile(filename, data, options, callback) {
  if (options instanceof Function) {
    callback = options;
    options = {};
  }

  var promise = writeFileAsync(filename, data, options);

  if (callback) {
    promise.then(callback, callback);
  }

  return promise;
}

function writeFileSync(filename, data, options) {
  if (typeof options === 'string') options = {
    encoding: options
  };else if (!options) options = {};

  try {
    filename = fs.realpathSync(filename);
  } catch (ex) {// it's ok, it'll happen on a not yet existing file
  }

  var tmpfile = getTmpname(filename);

  if (!options.mode || !options.chown) {
    // Either mode or chown is not explicitly set
    // Default behavior is to copy it from original file
    try {
      var stats = fs.statSync(filename);
      options = Object.assign({}, options);

      if (!options.mode) {
        options.mode = stats.mode;
      }

      if (!options.chown && process.getuid) {
        options.chown = {
          uid: stats.uid,
          gid: stats.gid
        };
      }
    } catch (ex) {// ignore stat errors
    }
  }

  var fd;
  var cleanup = cleanupOnExit(tmpfile);
  var removeOnExitHandler = onExit(cleanup);
  var threw = true;

  try {
    fd = fs.openSync(tmpfile, 'w', options.mode || 438);

    if (options.tmpfileCreated) {
      options.tmpfileCreated(tmpfile);
    }

    if (isTypedArray(data)) {
      data = typedArrayToBuffer(data);
    }

    if (Buffer.isBuffer(data)) {
      fs.writeSync(fd, data, 0, data.length, 0);
    } else if (data != null) {
      fs.writeSync(fd, String(data), 0, String(options.encoding || 'utf8'));
    }

    if (options.fsync !== false) {
      fs.fsyncSync(fd);
    }

    fs.closeSync(fd);
    fd = null;

    if (options.chown) {
      try {
        fs.chownSync(tmpfile, options.chown.uid, options.chown.gid);
      } catch (err) {
        if (!isChownErrOk(err)) {
          throw err;
        }
      }
    }

    if (options.mode) {
      try {
        fs.chmodSync(tmpfile, options.mode);
      } catch (err) {
        if (!isChownErrOk(err)) {
          throw err;
        }
      }
    }

    fs.renameSync(tmpfile, filename);
    threw = false;
  } finally {
    if (fd) {
      try {
        fs.closeSync(fd);
      } catch (ex) {// ignore close errors at this stage, error may have closed fd already.
      }
    }

    removeOnExitHandler();

    if (threw) {
      cleanup();
    }
  }
}