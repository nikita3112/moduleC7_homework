'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = treeProcessor;
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

function treeProcessor(options) {
  var nodeComplete = options.nodeComplete,
      nodeStart = options.nodeStart,
      queueRunnerFactory = options.queueRunnerFactory,
      runnableIds = options.runnableIds,
      tree = options.tree;

  function isEnabled(node, parentEnabled) {
    return parentEnabled || runnableIds.indexOf(node.id) !== -1;
  }

  function getNodeHandler(node, parentEnabled) {
    var enabled = isEnabled(node, parentEnabled);
    return node.children ? getNodeWithChildrenHandler(node, enabled) : getNodeWithoutChildrenHandler(node, enabled);
  }

  function getNodeWithoutChildrenHandler(node, enabled) {
    return function fn() {
      var done = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};
      node.execute(done, enabled);
    };
  }

  function getNodeWithChildrenHandler(node, enabled) {
    return function fn() {
      var done,
          _args = arguments;
      return regeneratorRuntime.async(function fn$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              done = _args.length > 0 && _args[0] !== undefined ? _args[0] : function () {};
              nodeStart(node);
              _context.next = 4;
              return regeneratorRuntime.awrap(queueRunnerFactory({
                onException: function onException(error) {
                  return node.onException(error);
                },
                queueableFns: wrapChildren(node, enabled),
                userContext: node.sharedUserContext()
              }));

            case 4:
              nodeComplete(node);
              done();

            case 6:
            case "end":
              return _context.stop();
          }
        }
      });
    };
  }

  function hasNoEnabledTest(node) {
    if (node.children) {
      return node.children.every(hasNoEnabledTest);
    }

    return node.disabled || node.markedPending;
  }

  function wrapChildren(node, enabled) {
    if (!node.children) {
      throw new Error('`node.children` is not defined.');
    }

    var children = node.children.map(function (child) {
      return {
        fn: getNodeHandler(child, enabled)
      };
    });

    if (hasNoEnabledTest(node)) {
      return children;
    }

    return node.beforeAllFns.concat(children).concat(node.afterAllFns);
  }

  var treeHandler = getNodeHandler(tree, false);
  return treeHandler();
}