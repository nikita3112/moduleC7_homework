'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = queueRunner;

var _jestUtil = require('jest-util');

var _PCancelable = _interopRequireDefault(require('./PCancelable'));

var _pTimeout = _interopRequireDefault(require('./pTimeout'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var _Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;

var _Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;

var Promise = global[_Symbol["for"]('jest-native-promise')] || global.Promise;

function queueRunner(options) {
  var token = new _PCancelable["default"](function (onCancel, resolve) {
    onCancel(resolve);
  });

  var mapper = function mapper(_ref) {
    var fn = _ref.fn,
        timeout = _ref.timeout,
        _ref$initError = _ref.initError,
        initError = _ref$initError === void 0 ? new Error() : _ref$initError;
    var promise = new Promise(function (resolve) {
      var next = function next() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var err = args[0];

        if (err) {
          options.fail.apply(null, args);
        }

        resolve();
      };

      next.fail = function () {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        options.fail.apply(null, args);
        resolve();
      };

      try {
        fn.call(options.userContext, next);
      } catch (e) {
        options.onException(e);
        resolve();
      }
    });
    promise = Promise.race([promise, token]);

    if (!timeout) {
      return promise;
    }

    var timeoutMs = timeout();
    return (0, _pTimeout["default"])(promise, timeoutMs, options.clearTimeout, options.setTimeout, function () {
      initError.message = 'Timeout - Async callback was not invoked within the ' + (0, _jestUtil.formatTime)(timeoutMs) + ' timeout specified by jest.setTimeout.';
      initError.stack = initError.message + initError.stack;
      options.onException(initError);
    });
  };

  var result = options.queueableFns.reduce(function (promise, fn) {
    return promise.then(function () {
      return mapper(fn);
    });
  }, Promise.resolve());
  return {
    cancel: token.cancel.bind(token),
    "catch": result["catch"].bind(result),
    then: result.then.bind(result)
  };
}