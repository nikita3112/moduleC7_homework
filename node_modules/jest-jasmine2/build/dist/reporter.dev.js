'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

var _testResult = require('@jest/test-result');

var _jestMessageUtil = require('jest-message-util');

var _Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;

var _Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;

var jestNow = global[_Symbol["for"]('jest-native-now')] || global.Date.now;

var _Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;

var Promise = global[_Symbol["for"]('jest-native-promise')] || global.Promise;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var Jasmine2Reporter =
/*#__PURE__*/
function () {
  function Jasmine2Reporter(globalConfig, config, testPath) {
    var _this = this;

    _classCallCheck(this, Jasmine2Reporter);

    _defineProperty(this, '_testResults', void 0);

    _defineProperty(this, '_globalConfig', void 0);

    _defineProperty(this, '_config', void 0);

    _defineProperty(this, '_currentSuites', void 0);

    _defineProperty(this, '_resolve', void 0);

    _defineProperty(this, '_resultsPromise', void 0);

    _defineProperty(this, '_startTimes', void 0);

    _defineProperty(this, '_testPath', void 0);

    this._globalConfig = globalConfig;
    this._config = config;
    this._testPath = testPath;
    this._testResults = [];
    this._currentSuites = [];
    this._resolve = null;
    this._resultsPromise = new Promise(function (resolve) {
      return _this._resolve = resolve;
    });
    this._startTimes = new Map();
  }

  _createClass(Jasmine2Reporter, [{
    key: "jasmineStarted",
    value: function jasmineStarted(_runDetails) {}
  }, {
    key: "specStarted",
    value: function specStarted(spec) {
      this._startTimes.set(spec.id, jestNow());
    }
  }, {
    key: "specDone",
    value: function specDone(result) {
      this._testResults.push(this._extractSpecResults(result, this._currentSuites.slice(0)));
    }
  }, {
    key: "suiteStarted",
    value: function suiteStarted(suite) {
      this._currentSuites.push(suite.description);
    }
  }, {
    key: "suiteDone",
    value: function suiteDone(_result) {
      this._currentSuites.pop();
    }
  }, {
    key: "jasmineDone",
    value: function jasmineDone(_runDetails) {
      var numFailingTests = 0;
      var numPassingTests = 0;
      var numPendingTests = 0;
      var numTodoTests = 0;
      var testResults = this._testResults;
      testResults.forEach(function (testResult) {
        if (testResult.status === 'failed') {
          numFailingTests++;
        } else if (testResult.status === 'pending') {
          numPendingTests++;
        } else if (testResult.status === 'todo') {
          numTodoTests++;
        } else {
          numPassingTests++;
        }
      });

      var testResult = _objectSpread({}, (0, _testResult.createEmptyTestResult)(), {
        console: null,
        failureMessage: (0, _jestMessageUtil.formatResultsErrors)(testResults, this._config, this._globalConfig, this._testPath),
        numFailingTests: numFailingTests,
        numPassingTests: numPassingTests,
        numPendingTests: numPendingTests,
        numTodoTests: numTodoTests,
        snapshot: {
          added: 0,
          fileDeleted: false,
          matched: 0,
          unchecked: 0,
          unmatched: 0,
          updated: 0
        },
        testFilePath: this._testPath,
        testResults: testResults
      });

      this._resolve(testResult);
    }
  }, {
    key: "getResults",
    value: function getResults() {
      return this._resultsPromise;
    }
  }, {
    key: "_addMissingMessageToStack",
    value: function _addMissingMessageToStack(stack, message) {
      // Some errors (e.g. Angular injection error) don't prepend error.message
      // to stack, instead the first line of the stack is just plain 'Error'
      var ERROR_REGEX = /^Error:?\s*\n/;

      if (stack && message && !stack.includes(message)) {
        return message + stack.replace(ERROR_REGEX, '\n');
      }

      return stack;
    }
  }, {
    key: "_extractSpecResults",
    value: function _extractSpecResults(specResult, ancestorTitles) {
      var _this2 = this;

      var start = this._startTimes.get(specResult.id);

      var duration = start ? jestNow() - start : undefined;
      var status = specResult.status === 'disabled' ? 'pending' : specResult.status;
      var location = specResult.__callsite ? {
        column: specResult.__callsite.getColumnNumber(),
        line: specResult.__callsite.getLineNumber()
      } : null;
      var results = {
        ancestorTitles: ancestorTitles,
        duration: duration,
        failureDetails: [],
        failureMessages: [],
        fullName: specResult.fullName,
        location: location,
        numPassingAsserts: 0,
        // Jasmine2 only returns an array of failed asserts.
        status: status,
        title: specResult.description
      };
      specResult.failedExpectations.forEach(function (failed) {
        var message = !failed.matcherName && typeof failed.stack === 'string' ? _this2._addMissingMessageToStack(failed.stack, failed.message) : failed.message || '';
        results.failureMessages.push(message);
        results.failureDetails.push(failed);
      });
      return results;
    }
  }]);

  return Jasmine2Reporter;
}();

exports["default"] = Jasmine2Reporter;