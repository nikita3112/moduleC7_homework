'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

var _expect = require('expect');

var _jestSnapshot = require('jest-snapshot');
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// Get suppressed errors form  jest-matchers that weren't throw during
// test execution and add them to the test result, potentially failing
// a passing test.


var addSuppressedErrors = function addSuppressedErrors(result) {
  var _ref = (0, _expect.getState)(),
      suppressedErrors = _ref.suppressedErrors;

  (0, _expect.setState)({
    suppressedErrors: []
  });

  if (suppressedErrors.length) {
    result.status = 'failed';
    result.failedExpectations = suppressedErrors.map(function (error) {
      return {
        actual: '',
        // passing error for custom test reporters
        error: error,
        expected: '',
        matcherName: '',
        message: error.message,
        passed: false,
        stack: error.stack
      };
    });
  }
};

var addAssertionErrors = function addAssertionErrors(result) {
  var assertionErrors = (0, _expect.extractExpectedAssertionsErrors)();

  if (assertionErrors.length) {
    var jasmineErrors = assertionErrors.map(function (_ref2) {
      var actual = _ref2.actual,
          error = _ref2.error,
          expected = _ref2.expected;
      return {
        actual: actual,
        expected: expected,
        message: error.stack,
        passed: false
      };
    });
    result.status = 'failed';
    result.failedExpectations = result.failedExpectations.concat(jasmineErrors);
  }
};

var patchJasmine = function patchJasmine() {
  global.jasmine.Spec = function (realSpec) {
    var Spec =
    /*#__PURE__*/
    function (_realSpec) {
      _inherits(Spec, _realSpec);

      function Spec(attr) {
        _classCallCheck(this, Spec);

        var resultCallback = attr.resultCallback;

        attr.resultCallback = function (result) {
          addSuppressedErrors(result);
          addAssertionErrors(result);
          resultCallback.call(attr, result);
        };

        var onStart = attr.onStart;

        attr.onStart = function (context) {
          (0, _expect.setState)({
            currentTestName: context.getFullName()
          });
          onStart && onStart.call(attr, context);
        };

        return _possibleConstructorReturn(this, _getPrototypeOf(Spec).call(this, attr));
      }

      return Spec;
    }(realSpec);

    return Spec;
  }(global.jasmine.Spec);
};

var _default = function _default(_ref3) {
  var config = _ref3.config,
      globalConfig = _ref3.globalConfig,
      localRequire = _ref3.localRequire,
      testPath = _ref3.testPath;
  // Jest tests snapshotSerializers in order preceding built-in serializers.
  // Therefore, add in reverse because the last added is the first tested.
  config.snapshotSerializers.concat().reverse().forEach(function (path) {
    (0, _jestSnapshot.addSerializer)(localRequire(path));
  });
  patchJasmine();
  var expand = globalConfig.expand,
      updateSnapshot = globalConfig.updateSnapshot;
  var snapshotResolver = (0, _jestSnapshot.buildSnapshotResolver)(config);
  var snapshotPath = snapshotResolver.resolveSnapshotPath(testPath);
  var snapshotState = new _jestSnapshot.SnapshotState(snapshotPath, {
    expand: expand,
    getBabelTraverse: function getBabelTraverse() {
      return require('@babel/traverse')["default"];
    },
    getPrettier: function getPrettier() {
      return config.prettierPath ? require(config.prettierPath) : null;
    },
    updateSnapshot: updateSnapshot
  }); // @ts-expect-error: snapshotState is a jest extension of `expect`

  (0, _expect.setState)({
    snapshotState: snapshotState,
    testPath: testPath
  }); // Return it back to the outer scope (test runner outside the VM).

  return snapshotState;
};

exports["default"] = _default;