'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var path = _interopRequireWildcard(require('path'));

var _sourceMap = require('@jest/source-map');

var _each = _interopRequireDefault(require('./each'));

var _errorOnPrivate = require('./errorOnPrivate');

var _jasmineAsyncInstall = _interopRequireDefault(require('./jasmineAsyncInstall'));

var _reporter = _interopRequireDefault(require('./reporter'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== 'function') return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var JASMINE = require.resolve('./jasmine/jasmineLight');

var jestEachBuildDir = path.dirname(require.resolve('jest-each'));

function jasmine2(globalConfig, config, environment, runtime, testPath) {
  var _runtime$unstable_sho2, reporter, jasmineFactory, jasmine, env, jasmineInterface, wrapIt, snapshotState, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _path, _runtime$unstable_sho, _esm, testNameRegex, esm, results;

  return regeneratorRuntime.async(function jasmine2$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          reporter = new _reporter["default"](globalConfig, config, testPath);
          jasmineFactory = runtime.requireInternalModule(JASMINE);
          jasmine = jasmineFactory.create({
            process: process,
            testPath: testPath,
            testTimeout: globalConfig.testTimeout
          });
          env = jasmine.getEnv();
          jasmineInterface = jasmineFactory._interface(jasmine, env);
          Object.assign(environment.global, jasmineInterface);
          env.addReporter(jasmineInterface.jsApiReporter); // TODO: Remove config option if V8 exposes some way of getting location of caller
          // in a future version

          if (config.testLocationInResults === true) {
            wrapIt = function wrapIt(original) {
              var wrapped = function wrapped(testName, fn, timeout) {
                var _stack$getFileName;

                var sourcemaps = runtime.getSourceMaps();
                var stack = (0, _sourceMap.getCallsite)(1, sourcemaps);
                var it = original(testName, fn, timeout);

                if ((_stack$getFileName = stack.getFileName()) === null || _stack$getFileName === void 0 ? void 0 : _stack$getFileName.startsWith(jestEachBuildDir)) {
                  stack = (0, _sourceMap.getCallsite)(4, sourcemaps);
                } // @ts-expect-error


                it.result.__callsite = stack;
                return it;
              };

              return wrapped;
            };

            environment.global.it = wrapIt(environment.global.it);
            environment.global.xit = wrapIt(environment.global.xit);
            environment.global.fit = wrapIt(environment.global.fit);
          }

          (0, _jasmineAsyncInstall["default"])(globalConfig, environment.global);
          (0, _each["default"])(environment);
          environment.global.test = environment.global.it;
          environment.global.it.only = environment.global.fit;
          environment.global.it.todo = env.todo;
          environment.global.it.skip = environment.global.xit;
          environment.global.xtest = environment.global.xit;
          environment.global.describe.skip = environment.global.xdescribe;
          environment.global.describe.only = environment.global.fdescribe;

          if (config.timers === 'fake' || config.timers === 'legacy') {
            environment.fakeTimers.useFakeTimers();
          } else if (config.timers === 'modern') {
            environment.fakeTimersModern.useFakeTimers();
          }

          env.beforeEach(function () {
            if (config.resetModules) {
              runtime.resetModules();
            }

            if (config.clearMocks) {
              runtime.clearAllMocks();
            }

            if (config.resetMocks) {
              runtime.resetAllMocks();

              if (config.timers === 'fake' || config.timers === 'legacy') {
                environment.fakeTimers.useFakeTimers();
              }
            }

            if (config.restoreMocks) {
              runtime.restoreAllMocks();
            }
          });
          env.addReporter(reporter);
          runtime.requireInternalModule(path.resolve(__dirname, './jestExpect.js'))["default"]({
            expand: globalConfig.expand
          });

          if (globalConfig.errorOnDeprecated) {
            (0, _errorOnPrivate.installErrorOnPrivate)(environment.global);
          } else {
            Object.defineProperty(jasmine, 'DEFAULT_TIMEOUT_INTERVAL', {
              configurable: true,
              enumerable: true,
              get: function get() {
                return this._DEFAULT_TIMEOUT_INTERVAL;
              },
              set: function set(value) {
                this._DEFAULT_TIMEOUT_INTERVAL = value;
              }
            });
          }

          snapshotState = runtime.requireInternalModule(path.resolve(__dirname, './setup_jest_globals.js'))["default"]({
            config: config,
            globalConfig: globalConfig,
            localRequire: runtime.requireModule.bind(runtime),
            testPath: testPath
          });
          _iteratorNormalCompletion = true;
          _didIteratorError = false;
          _iteratorError = undefined;
          _context.prev = 26;
          _iterator = config.setupFilesAfterEnv[Symbol.iterator]();

        case 28:
          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
            _context.next = 40;
            break;
          }

          _path = _step.value;
          // TODO: remove ? in Jest 26
          _esm = (_runtime$unstable_sho = runtime.unstable_shouldLoadAsEsm) === null || _runtime$unstable_sho === void 0 ? void 0 : _runtime$unstable_sho.call(runtime, _path);

          if (!_esm) {
            _context.next = 36;
            break;
          }

          _context.next = 34;
          return regeneratorRuntime.awrap(runtime.unstable_importModule(_path));

        case 34:
          _context.next = 37;
          break;

        case 36:
          runtime.requireModule(_path);

        case 37:
          _iteratorNormalCompletion = true;
          _context.next = 28;
          break;

        case 40:
          _context.next = 46;
          break;

        case 42:
          _context.prev = 42;
          _context.t0 = _context["catch"](26);
          _didIteratorError = true;
          _iteratorError = _context.t0;

        case 46:
          _context.prev = 46;
          _context.prev = 47;

          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }

        case 49:
          _context.prev = 49;

          if (!_didIteratorError) {
            _context.next = 52;
            break;
          }

          throw _iteratorError;

        case 52:
          return _context.finish(49);

        case 53:
          return _context.finish(46);

        case 54:
          if (globalConfig.enabledTestsMap) {
            env.specFilter = function (spec) {
              var suiteMap = globalConfig.enabledTestsMap && globalConfig.enabledTestsMap[spec.result.testPath];
              return suiteMap && suiteMap[spec.result.fullName] || false;
            };
          } else if (globalConfig.testNamePattern) {
            testNameRegex = new RegExp(globalConfig.testNamePattern, 'i');

            env.specFilter = function (spec) {
              return testNameRegex.test(spec.getFullName());
            };
          } // TODO: remove ? in Jest 26


          esm = (_runtime$unstable_sho2 = runtime.unstable_shouldLoadAsEsm) === null || _runtime$unstable_sho2 === void 0 ? void 0 : _runtime$unstable_sho2.call(runtime, testPath);

          if (!esm) {
            _context.next = 61;
            break;
          }

          _context.next = 59;
          return regeneratorRuntime.awrap(runtime.unstable_importModule(testPath));

        case 59:
          _context.next = 62;
          break;

        case 61:
          runtime.requireModule(testPath);

        case 62:
          _context.next = 64;
          return regeneratorRuntime.awrap(env.execute());

        case 64:
          _context.next = 66;
          return regeneratorRuntime.awrap(reporter.getResults());

        case 66:
          results = _context.sent;
          return _context.abrupt("return", addSnapshotData(results, snapshotState));

        case 68:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[26, 42, 46, 54], [47,, 49, 53]]);
}

var addSnapshotData = function addSnapshotData(results, snapshotState) {
  results.testResults.forEach(function (_ref) {
    var fullName = _ref.fullName,
        status = _ref.status;

    if (status === 'pending' || status === 'failed') {
      // if test is skipped or failed, we don't want to mark
      // its snapshots as obsolete.
      snapshotState.markSnapshotsAsCheckedForTest(fullName);
    }
  });
  var uncheckedCount = snapshotState.getUncheckedCount();
  var uncheckedKeys = snapshotState.getUncheckedKeys();

  if (uncheckedCount) {
    snapshotState.removeUncheckedKeys();
  }

  var status = snapshotState.save();
  results.snapshot.fileDeleted = status.deleted;
  results.snapshot.added = snapshotState.added;
  results.snapshot.matched = snapshotState.matched;
  results.snapshot.unmatched = snapshotState.unmatched;
  results.snapshot.updated = snapshotState.updated;
  results.snapshot.unchecked = !status.deleted ? uncheckedCount : 0; // Copy the array to prevent memory leaks

  results.snapshot.uncheckedKeys = Array.from(uncheckedKeys);
  return results;
};

module.exports = jasmine2;