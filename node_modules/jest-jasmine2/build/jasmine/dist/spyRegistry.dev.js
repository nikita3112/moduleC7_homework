'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

var _CallTracker = _interopRequireDefault(require('./CallTracker'));

var _SpyStrategy = _interopRequireDefault(require('./SpyStrategy'));

var _createSpy = _interopRequireDefault(require('./createSpy'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var formatErrorMsg = function formatErrorMsg(domain, usage) {
  var usageDefinition = usage ? '\nUsage: ' + usage : '';
  return function (msg) {
    return domain + ' : ' + msg + usageDefinition;
  };
};

function isSpy(putativeSpy) {
  if (!putativeSpy) {
    return false;
  }

  return putativeSpy.and instanceof _SpyStrategy["default"] && putativeSpy.calls instanceof _CallTracker["default"];
}

var getErrorMsg = formatErrorMsg('<spyOn>', 'spyOn(<object>, <methodName>)');

var SpyRegistry = function SpyRegistry() {
  var _this = this;

  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$currentSpies = _ref.currentSpies,
      currentSpies = _ref$currentSpies === void 0 ? function () {
    return [];
  } : _ref$currentSpies;

  _classCallCheck(this, SpyRegistry);

  _defineProperty(this, 'allowRespy', void 0);

  _defineProperty(this, 'spyOn', void 0);

  _defineProperty(this, 'clearSpies', void 0);

  _defineProperty(this, 'respy', void 0);

  _defineProperty(this, '_spyOnProperty', void 0);

  this.allowRespy = function (allow) {
    this.respy = allow;
  };

  this.spyOn = function (obj, methodName, accessType) {
    if (accessType) {
      return _this._spyOnProperty(obj, methodName, accessType);
    }

    if (obj === void 0) {
      throw new Error(getErrorMsg('could not find an object to spy upon for ' + methodName + '()'));
    }

    if (methodName === void 0) {
      throw new Error(getErrorMsg('No method name supplied'));
    }

    if (obj[methodName] === void 0) {
      throw new Error(getErrorMsg(methodName + '() method does not exist'));
    }

    if (obj[methodName] && isSpy(obj[methodName])) {
      if (_this.respy) {
        return obj[methodName];
      } else {
        throw new Error(getErrorMsg(methodName + ' has already been spied upon'));
      }
    }

    var descriptor;

    try {
      descriptor = Object.getOwnPropertyDescriptor(obj, methodName);
    } catch (_unused) {// IE 8 doesn't support `definePropery` on non-DOM nodes
    }

    if (descriptor && !(descriptor.writable || descriptor.set)) {
      throw new Error(getErrorMsg(methodName + ' is not declared writable or has no setter'));
    }

    var originalMethod = obj[methodName];
    var spiedMethod = (0, _createSpy["default"])(methodName, originalMethod);
    var restoreStrategy;

    if (Object.prototype.hasOwnProperty.call(obj, methodName)) {
      restoreStrategy = function restoreStrategy() {
        obj[methodName] = originalMethod;
      };
    } else {
      restoreStrategy = function restoreStrategy() {
        if (!delete obj[methodName]) {
          obj[methodName] = originalMethod;
        }
      };
    }

    currentSpies().push({
      restoreObjectToOriginalState: restoreStrategy
    });
    obj[methodName] = spiedMethod;
    return spiedMethod;
  };

  this._spyOnProperty = function (obj, propertyName) {
    var accessType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'get';

    if (!obj) {
      throw new Error(getErrorMsg('could not find an object to spy upon for ' + propertyName));
    }

    if (!propertyName) {
      throw new Error(getErrorMsg('No property name supplied'));
    }

    var descriptor;

    try {
      descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
    } catch (_unused2) {// IE 8 doesn't support `definePropery` on non-DOM nodes
    }

    if (!descriptor) {
      throw new Error(getErrorMsg(propertyName + ' property does not exist'));
    }

    if (!descriptor.configurable) {
      throw new Error(getErrorMsg(propertyName + ' is not declared configurable'));
    }

    if (!descriptor[accessType]) {
      throw new Error(getErrorMsg('Property ' + propertyName + ' does not have access type ' + accessType));
    }

    if (obj[propertyName] && isSpy(obj[propertyName])) {
      if (this.respy) {
        return obj[propertyName];
      } else {
        throw new Error(getErrorMsg(propertyName + ' has already been spied upon'));
      }
    }

    var originalDescriptor = descriptor;
    var spiedProperty = (0, _createSpy["default"])(propertyName, descriptor[accessType]);
    var restoreStrategy;

    if (Object.prototype.hasOwnProperty.call(obj, propertyName)) {
      restoreStrategy = function restoreStrategy() {
        Object.defineProperty(obj, propertyName, originalDescriptor);
      };
    } else {
      restoreStrategy = function restoreStrategy() {
        delete obj[propertyName];
      };
    }

    currentSpies().push({
      restoreObjectToOriginalState: restoreStrategy
    });

    var spiedDescriptor = _objectSpread({}, descriptor, _defineProperty2({}, accessType, spiedProperty));

    Object.defineProperty(obj, propertyName, spiedDescriptor);
    return spiedProperty;
  };

  this.clearSpies = function () {
    var spies = currentSpies();

    for (var i = spies.length - 1; i >= 0; i--) {
      var spyEntry = spies[i];
      spyEntry.restoreObjectToOriginalState();
    }
  };
};

exports["default"] = SpyRegistry;