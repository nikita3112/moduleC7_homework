'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = _default;

var _assert = require('assert');

var _chalk = _interopRequireDefault(require('chalk'));

var _jestMessageUtil = require('jest-message-util');

var _jestUtil = require('jest-util');

var _assertionErrorMessage = _interopRequireDefault(require('../assertionErrorMessage'));

var _isError = _interopRequireDefault(require('../isError'));

var _queueRunner = _interopRequireDefault(require('../queueRunner'));

var _treeProcessor = _interopRequireDefault(require('../treeProcessor'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _default(j$) {
  var _temp;

  return _temp = function Env(_options) {
    var _this = this;

    _classCallCheck(this, Env);

    _defineProperty(this, 'specFilter', void 0);

    _defineProperty(this, 'catchExceptions', void 0);

    _defineProperty(this, 'throwOnExpectationFailure', void 0);

    _defineProperty(this, 'catchingExceptions', void 0);

    _defineProperty(this, 'topSuite', void 0);

    _defineProperty(this, 'fail', void 0);

    _defineProperty(this, 'pending', void 0);

    _defineProperty(this, 'afterAll', void 0);

    _defineProperty(this, 'fit', void 0);

    _defineProperty(this, 'throwingExpectationFailures', void 0);

    _defineProperty(this, 'randomizeTests', void 0);

    _defineProperty(this, 'randomTests', void 0);

    _defineProperty(this, 'seed', void 0);

    _defineProperty(this, 'execute', void 0);

    _defineProperty(this, 'fdescribe', void 0);

    _defineProperty(this, 'spyOn', void 0);

    _defineProperty(this, 'beforeEach', void 0);

    _defineProperty(this, 'afterEach', void 0);

    _defineProperty(this, 'clearReporters', void 0);

    _defineProperty(this, 'addReporter', void 0);

    _defineProperty(this, 'it', void 0);

    _defineProperty(this, 'xdescribe', void 0);

    _defineProperty(this, 'xit', void 0);

    _defineProperty(this, 'beforeAll', void 0);

    _defineProperty(this, 'todo', void 0);

    _defineProperty(this, 'provideFallbackReporter', void 0);

    _defineProperty(this, 'allowRespy', void 0);

    _defineProperty(this, 'describe', void 0);

    var totalSpecsDefined = 0;
    var catchExceptions = true;
    var realSetTimeout = global.setTimeout;
    var realClearTimeout = global.clearTimeout;
    var runnableResources = {};
    var currentlyExecutingSuites = [];
    var currentSpec = null;
    var throwOnExpectationFailure = false;
    var random = false;
    var seed = null;
    var nextSpecId = 0;
    var nextSuiteId = 0;

    var getNextSpecId = function getNextSpecId() {
      return 'spec' + nextSpecId++;
    };

    var getNextSuiteId = function getNextSuiteId() {
      return 'suite' + nextSuiteId++;
    };

    var topSuite = new j$.Suite({
      id: getNextSuiteId(),
      description: '',
      getTestPath: function getTestPath() {
        return j$.testPath;
      }
    });
    var currentDeclarationSuite = topSuite;

    var currentSuite = function currentSuite() {
      return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];
    };

    var currentRunnable = function currentRunnable() {
      return currentSpec || currentSuite();
    };

    var reporter = new j$.ReportDispatcher(['jasmineStarted', 'jasmineDone', 'suiteStarted', 'suiteDone', 'specStarted', 'specDone']);

    this.specFilter = function () {
      return true;
    };

    var defaultResourcesForRunnable = function defaultResourcesForRunnable(id, _parentRunnableId) {
      var resources = {
        spies: []
      };
      runnableResources[id] = resources;
    };

    var clearResourcesForRunnable = function clearResourcesForRunnable(id) {
      spyRegistry.clearSpies();
      delete runnableResources[id];
    };

    var beforeAndAfterFns = function beforeAndAfterFns(suite) {
      return function () {
        var afters = [];
        var befores = [];

        while (suite) {
          befores = befores.concat(suite.beforeFns);
          afters = afters.concat(suite.afterFns);
          suite = suite.parentSuite;
        }

        return {
          befores: befores.reverse(),
          afters: afters
        };
      };
    };

    var _getSpecName = function getSpecName(spec, suite) {
      var fullName = [spec.description];
      var suiteFullName = suite.getFullName();

      if (suiteFullName !== '') {
        fullName.unshift(suiteFullName);
      }

      return fullName.join(' ');
    };

    this.catchExceptions = function (value) {
      catchExceptions = !!value;
      return catchExceptions;
    };

    this.catchingExceptions = function () {
      return catchExceptions;
    };

    this.throwOnExpectationFailure = function (value) {
      throwOnExpectationFailure = !!value;
    };

    this.throwingExpectationFailures = function () {
      return throwOnExpectationFailure;
    };

    this.randomizeTests = function (value) {
      random = !!value;
    };

    this.randomTests = function () {
      return random;
    };

    this.seed = function (value) {
      if (value) {
        seed = value;
      }

      return seed;
    };

    var queueRunnerFactory = function queueRunnerFactory(options) {
      options.clearTimeout = realClearTimeout;
      options.fail = _this.fail;
      options.setTimeout = realSetTimeout;
      return (0, _queueRunner["default"])(options);
    };

    this.topSuite = function () {
      return topSuite;
    };

    var uncaught = function uncaught(err) {
      if (currentSpec) {
        currentSpec.onException(err);
        currentSpec.cancel();
      } else {
        console.error('Unhandled error');
        console.error(err.stack);
      }
    };

    var oldListenersException;
    var oldListenersRejection;

    var executionSetup = function executionSetup() {
      // Need to ensure we are the only ones handling these exceptions.
      oldListenersException = process.listeners('uncaughtException').slice();
      oldListenersRejection = process.listeners('unhandledRejection').slice();
      j$.process.removeAllListeners('uncaughtException');
      j$.process.removeAllListeners('unhandledRejection');
      j$.process.on('uncaughtException', uncaught);
      j$.process.on('unhandledRejection', uncaught);
    };

    var executionTeardown = function executionTeardown() {
      j$.process.removeListener('uncaughtException', uncaught);
      j$.process.removeListener('unhandledRejection', uncaught); // restore previous exception handlers

      oldListenersException.forEach(function (listener) {
        j$.process.on('uncaughtException', listener);
      });
      oldListenersRejection.forEach(function (listener) {
        j$.process.on('unhandledRejection', listener);
      });
    };

    this.execute = function _callee(runnablesToRun) {
      var suiteTree,
          lastDeclarationSuite,
          _args = arguments;
      return regeneratorRuntime.async(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              suiteTree = _args.length > 1 && _args[1] !== undefined ? _args[1] : topSuite;

              if (!runnablesToRun) {
                if (focusedRunnables.length) {
                  runnablesToRun = focusedRunnables;
                } else {
                  runnablesToRun = [suiteTree.id];
                }
              }

              if (currentlyExecutingSuites.length === 0) {
                executionSetup();
              }

              lastDeclarationSuite = currentDeclarationSuite;
              _context.next = 6;
              return regeneratorRuntime.awrap((0, _treeProcessor["default"])({
                nodeComplete: function nodeComplete(suite) {
                  if (!suite.disabled) {
                    clearResourcesForRunnable(suite.id);
                  }

                  currentlyExecutingSuites.pop();

                  if (suite === topSuite) {
                    reporter.jasmineDone({
                      failedExpectations: topSuite.result.failedExpectations
                    });
                  } else {
                    reporter.suiteDone(suite.getResult());
                  }
                },
                nodeStart: function nodeStart(suite) {
                  currentlyExecutingSuites.push(suite);
                  defaultResourcesForRunnable(suite.id, suite.parentSuite && suite.parentSuite.id);

                  if (suite === topSuite) {
                    reporter.jasmineStarted({
                      totalSpecsDefined: totalSpecsDefined
                    });
                  } else {
                    reporter.suiteStarted(suite.result);
                  }
                },
                queueRunnerFactory: queueRunnerFactory,
                runnableIds: runnablesToRun,
                tree: suiteTree
              }));

            case 6:
              currentDeclarationSuite = lastDeclarationSuite;

              if (currentlyExecutingSuites.length === 0) {
                executionTeardown();
              }

            case 8:
            case "end":
              return _context.stop();
          }
        }
      });
    };

    this.addReporter = function (reporterToAdd) {
      reporter.addReporter(reporterToAdd);
    };

    this.provideFallbackReporter = function (reporterToAdd) {
      reporter.provideFallbackReporter(reporterToAdd);
    };

    this.clearReporters = function () {
      reporter.clearReporters();
    };

    var spyRegistry = new j$.SpyRegistry({
      currentSpies: function currentSpies() {
        if (!currentRunnable()) {
          throw new Error('Spies must be created in a before function or a spec');
        }

        return runnableResources[currentRunnable().id].spies;
      }
    });

    this.allowRespy = function (allow) {
      spyRegistry.allowRespy(allow);
    };

    this.spyOn = function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return spyRegistry.spyOn.apply(spyRegistry, args);
    };

    var suiteFactory = function suiteFactory(description) {
      var suite = new j$.Suite({
        id: getNextSuiteId(),
        description: description,
        parentSuite: currentDeclarationSuite,
        throwOnExpectationFailure: throwOnExpectationFailure,
        getTestPath: function getTestPath() {
          return j$.testPath;
        }
      });
      return suite;
    };

    this.describe = function (description, specDefinitions) {
      var suite = suiteFactory(description);

      if (specDefinitions === undefined) {
        throw new Error("Missing second argument. It must be a callback function.");
      }

      if (typeof specDefinitions !== 'function') {
        throw new Error("Invalid second argument, ".concat(specDefinitions, ". It must be a callback function."));
      }

      if (specDefinitions.length > 0) {
        throw new Error('describe does not expect any arguments');
      }

      if (currentDeclarationSuite.markedPending) {
        suite.pend();
      }

      if (currentDeclarationSuite.markedTodo) {
        // @ts-expect-error TODO Possible error: Suite does not have todo method
        suite.todo();
      }

      addSpecsToSuite(suite, specDefinitions);
      return suite;
    };

    this.xdescribe = function (description, specDefinitions) {
      var suite = suiteFactory(description);
      suite.pend();
      addSpecsToSuite(suite, specDefinitions);
      return suite;
    };

    var focusedRunnables = [];

    this.fdescribe = function (description, specDefinitions) {
      var suite = suiteFactory(description);
      suite.isFocused = true;
      focusedRunnables.push(suite.id);
      unfocusAncestor();
      addSpecsToSuite(suite, specDefinitions);
      return suite;
    };

    var addSpecsToSuite = function addSpecsToSuite(suite, specDefinitions) {
      var parentSuite = currentDeclarationSuite;
      parentSuite.addChild(suite);
      currentDeclarationSuite = suite;
      var declarationError = undefined;
      var describeReturnValue;

      try {
        describeReturnValue = specDefinitions.call(suite);
      } catch (e) {
        declarationError = e;
      } // TODO throw in Jest 25: declarationError = new Error


      if ((0, _jestUtil.isPromise)(describeReturnValue)) {
        console.log((0, _jestMessageUtil.formatExecError)(new Error(_chalk["default"].yellow('Returning a Promise from "describe" is not supported. Tests must be defined synchronously.\n' + 'Returning a value from "describe" will fail the test in a future version of Jest.')), {
          rootDir: '',
          testMatch: []
        }, {
          noStackTrace: false
        }));
      } else if (describeReturnValue !== undefined) {
        console.log((0, _jestMessageUtil.formatExecError)(new Error(_chalk["default"].yellow('A "describe" callback must not return a value.\n' + 'Returning a value from "describe" will fail the test in a future version of Jest.')), {
          rootDir: '',
          testMatch: []
        }, {
          noStackTrace: false
        }));
      }

      if (declarationError) {
        _this.it('encountered a declaration exception', function () {
          throw declarationError;
        });
      }

      currentDeclarationSuite = parentSuite;
    };

    function findFocusedAncestor(suite) {
      while (suite) {
        if (suite.isFocused) {
          return suite.id;
        }

        suite = suite.parentSuite;
      }

      return null;
    }

    function unfocusAncestor() {
      var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);

      if (focusedAncestor) {
        for (var i = 0; i < focusedRunnables.length; i++) {
          if (focusedRunnables[i] === focusedAncestor) {
            focusedRunnables.splice(i, 1);
            break;
          }
        }
      }
    }

    var specFactory = function specFactory(description, fn, suite, _timeout) {
      totalSpecsDefined++;
      var spec = new j$.Spec({
        id: getNextSpecId(),
        beforeAndAfterFns: beforeAndAfterFns(suite),
        resultCallback: specResultCallback,
        getSpecName: function getSpecName(spec) {
          return _getSpecName(spec, suite);
        },
        getTestPath: function getTestPath() {
          return j$.testPath;
        },
        onStart: specStarted,
        description: description,
        queueRunnerFactory: queueRunnerFactory,
        userContext: function userContext() {
          return suite.clonedSharedUserContext();
        },
        queueableFn: {
          fn: fn,
          timeout: function timeout() {
            return _timeout || j$._DEFAULT_TIMEOUT_INTERVAL;
          }
        },
        throwOnExpectationFailure: throwOnExpectationFailure
      });

      if (!_this.specFilter(spec)) {
        spec.disable();
      }

      return spec;

      function specResultCallback(result) {
        clearResourcesForRunnable(spec.id);
        currentSpec = null;
        reporter.specDone(result);
      }

      function specStarted(spec) {
        currentSpec = spec;
        defaultResourcesForRunnable(spec.id, suite.id);
        reporter.specStarted(spec.result);
      }
    };

    this.it = function (description, fn, timeout) {
      if (typeof description !== 'string') {
        throw new Error("Invalid first argument, ".concat(description, ". It must be a string."));
      }

      if (fn === undefined) {
        throw new Error('Missing second argument. It must be a callback function. Perhaps you want to use `test.todo` for a test placeholder.');
      }

      if (typeof fn !== 'function') {
        throw new Error("Invalid second argument, ".concat(fn, ". It must be a callback function."));
      }

      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);

      if (currentDeclarationSuite.markedPending) {
        spec.pend();
      } // When a test is defined inside another, jasmine will not run it.
      // This check throws an error to warn the user about the edge-case.


      if (currentSpec !== null) {
        throw new Error("Tests cannot be nested. Test \"".concat(spec.description, "\" cannot run because it is nested within \"").concat(currentSpec.description, "\"."));
      }

      currentDeclarationSuite.addChild(spec);
      return spec;
    };

    this.xit = function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var spec = this.it.apply(this, args);
      spec.pend('Temporarily disabled with xit');
      return spec;
    };

    this.todo = function () {
      var description = arguments[0];

      if (arguments.length !== 1 || typeof description !== 'string') {
        throw new _jestUtil.ErrorWithStack('Todo must be called with only a description.', this.todo);
      }

      var spec = specFactory(description, function () {}, currentDeclarationSuite);
      spec.todo();
      currentDeclarationSuite.addChild(spec);
      return spec;
    };

    this.fit = function (description, fn, timeout) {
      var spec = specFactory(description, fn, currentDeclarationSuite, timeout);
      currentDeclarationSuite.addChild(spec);
      focusedRunnables.push(spec.id);
      unfocusAncestor();
      return spec;
    };

    this.beforeEach = function (beforeEachFunction, _timeout2) {
      currentDeclarationSuite.beforeEach({
        fn: beforeEachFunction,
        timeout: function timeout() {
          return _timeout2 || j$._DEFAULT_TIMEOUT_INTERVAL;
        }
      });
    };

    this.beforeAll = function (beforeAllFunction, _timeout3) {
      currentDeclarationSuite.beforeAll({
        fn: beforeAllFunction,
        timeout: function timeout() {
          return _timeout3 || j$._DEFAULT_TIMEOUT_INTERVAL;
        }
      });
    };

    this.afterEach = function (afterEachFunction, _timeout4) {
      currentDeclarationSuite.afterEach({
        fn: afterEachFunction,
        timeout: function timeout() {
          return _timeout4 || j$._DEFAULT_TIMEOUT_INTERVAL;
        }
      });
    };

    this.afterAll = function (afterAllFunction, _timeout5) {
      currentDeclarationSuite.afterAll({
        fn: afterAllFunction,
        timeout: function timeout() {
          return _timeout5 || j$._DEFAULT_TIMEOUT_INTERVAL;
        }
      });
    };

    this.pending = function (message) {
      var fullMessage = j$.Spec.pendingSpecExceptionMessage;

      if (message) {
        fullMessage += message;
      }

      throw fullMessage;
    };

    this.fail = function (error) {
      var checkIsError;
      var message;

      if (error instanceof _assert.AssertionError || error && error.name === _assert.AssertionError.name) {
        checkIsError = false; // @ts-expect-error TODO Possible error: j$.Spec does not have expand property

        message = (0, _assertionErrorMessage["default"])(error, {
          expand: j$.Spec.expand
        });
      } else {
        var check = (0, _isError["default"])(error);
        checkIsError = check.isError;
        message = check.message;
      }

      var errorAsErrorObject = checkIsError ? error : new Error(message);
      var runnable = currentRunnable();

      if (!runnable) {
        errorAsErrorObject.message = 'Caught error after test environment was torn down\n\n' + errorAsErrorObject.message;
        throw errorAsErrorObject;
      }

      runnable.addExpectationResult(false, {
        matcherName: '',
        passed: false,
        expected: '',
        actual: '',
        message: message,
        error: errorAsErrorObject
      });
    };
  }, _temp;
}