"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var _require = require("./encoding"),
    utf8Encode = _require.utf8Encode,
    utf8DecodeWithoutBOM = _require.utf8DecodeWithoutBOM;

var _require2 = require("./percent-encoding"),
    percentDecodeBytes = _require2.percentDecodeBytes,
    utf8PercentEncodeString = _require2.utf8PercentEncodeString,
    isURLEncodedPercentEncode = _require2.isURLEncodedPercentEncode; // https://url.spec.whatwg.org/#concept-urlencoded-parser


function parseUrlencoded(input) {
  var sequences = strictlySplitByteSequence(input, 38);
  var output = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = sequences[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var bytes = _step.value;

      if (bytes.length === 0) {
        continue;
      }

      var name = void 0;
      var value = void 0;
      var indexOfEqual = bytes.indexOf(61);

      if (indexOfEqual >= 0) {
        name = bytes.slice(0, indexOfEqual);
        value = bytes.slice(indexOfEqual + 1);
      } else {
        name = bytes;
        value = new Uint8Array(0);
      }

      name = replaceByteInByteSequence(name, 0x2B, 0x20);
      value = replaceByteInByteSequence(value, 0x2B, 0x20);
      var nameString = utf8DecodeWithoutBOM(percentDecodeBytes(name));
      var valueString = utf8DecodeWithoutBOM(percentDecodeBytes(value));
      output.push([nameString, valueString]);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return output;
} // https://url.spec.whatwg.org/#concept-urlencoded-string-parser


function parseUrlencodedString(input) {
  return parseUrlencoded(utf8Encode(input));
} // https://url.spec.whatwg.org/#concept-urlencoded-serializer


function serializeUrlencoded(tuples) {
  var encodingOverride = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
  var encoding = "utf-8";

  if (encodingOverride !== undefined) {
    // TODO "get the output encoding", i.e. handle encoding labels vs. names.
    encoding = encodingOverride;
  }

  var output = "";
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = tuples.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _step2$value = _slicedToArray(_step2.value, 2),
          i = _step2$value[0],
          tuple = _step2$value[1];

      // TODO: handle encoding override
      var name = utf8PercentEncodeString(tuple[0], isURLEncodedPercentEncode, true);
      var value = tuple[1];

      if (tuple.length > 2 && tuple[2] !== undefined) {
        if (tuple[2] === "hidden" && name === "_charset_") {
          value = encoding;
        } else if (tuple[2] === "file") {
          // value is a File object
          value = value.name;
        }
      }

      value = utf8PercentEncodeString(value, isURLEncodedPercentEncode, true);

      if (i !== 0) {
        output += "&";
      }

      output += "".concat(name, "=").concat(value);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return output;
}

function strictlySplitByteSequence(buf, cp) {
  var list = [];
  var last = 0;
  var i = buf.indexOf(cp);

  while (i >= 0) {
    list.push(buf.slice(last, i));
    last = i + 1;
    i = buf.indexOf(cp, last);
  }

  if (last !== buf.length) {
    list.push(buf.slice(last));
  }

  return list;
}

function replaceByteInByteSequence(buf, from, to) {
  var i = buf.indexOf(from);

  while (i >= 0) {
    buf[i] = to;
    i = buf.indexOf(from, i + 1);
  }

  return buf;
}

module.exports = {
  parseUrlencodedString: parseUrlencodedString,
  serializeUrlencoded: serializeUrlencoded
};