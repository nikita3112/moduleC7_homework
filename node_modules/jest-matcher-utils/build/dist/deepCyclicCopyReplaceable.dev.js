'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = deepCyclicCopyReplaceable;

var _prettyFormat = require('pretty-format');
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var builtInObject = [Array, Buffer, Date, Float32Array, Float64Array, Int16Array, Int32Array, Int8Array, Map, Set, RegExp, Uint16Array, Uint32Array, Uint8Array, Uint8ClampedArray];

var isBuiltInObject = function isBuiltInObject(object) {
  return builtInObject.includes(object.constructor);
};

var isMap = function isMap(value) {
  return value.constructor === Map;
};

function deepCyclicCopyReplaceable(value) {
  var cycles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new WeakMap();

  if (_typeof(value) !== 'object' || value === null) {
    return value;
  } else if (cycles.has(value)) {
    return cycles.get(value);
  } else if (Array.isArray(value)) {
    return deepCyclicCopyArray(value, cycles);
  } else if (isMap(value)) {
    return deepCyclicCopyMap(value, cycles);
  } else if (isBuiltInObject(value)) {
    return value;
  } else if (_prettyFormat.plugins.DOMElement.test(value)) {
    return value.cloneNode(true);
  } else {
    return deepCyclicCopyObject(value, cycles);
  }
}

function deepCyclicCopyObject(object, cycles) {
  var newObject = Object.create(Object.getPrototypeOf(object));
  var descriptors = Object.getOwnPropertyDescriptors(object);
  cycles.set(object, newObject);
  var newDescriptors = [].concat(_toConsumableArray(Object.keys(descriptors)), _toConsumableArray(Object.getOwnPropertySymbols(descriptors))).reduce( //@ts-expect-error because typescript do not support symbol key in object
  //https://github.com/microsoft/TypeScript/issues/1863
  function (newDescriptors, key) {
    var enumerable = descriptors[key].enumerable;
    newDescriptors[key] = {
      configurable: true,
      enumerable: enumerable,
      value: deepCyclicCopyReplaceable( // this accesses the value or getter, depending. We just care about the value anyways, and this allows us to not mess with accessors
      // it has the side effect of invoking the getter here though, rather than copying it over
      object[key], cycles),
      writable: true
    };
    return newDescriptors;
  }, {}); //@ts-expect-error because typescript do not support symbol key in object
  //https://github.com/microsoft/TypeScript/issues/1863

  return Object.defineProperties(newObject, newDescriptors);
}

function deepCyclicCopyArray(array, cycles) {
  var newArray = new (Object.getPrototypeOf(array).constructor)(array.length);
  var length = array.length;
  cycles.set(array, newArray);

  for (var i = 0; i < length; i++) {
    newArray[i] = deepCyclicCopyReplaceable(array[i], cycles);
  }

  return newArray;
}

function deepCyclicCopyMap(map, cycles) {
  var newMap = new Map();
  cycles.set(map, newMap);
  map.forEach(function (value, key) {
    newMap.set(key, deepCyclicCopyReplaceable(value, cycles));
  });
  return newMap;
}