'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

var _jestGetType = _interopRequireDefault(require('jest-get-type'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var supportTypes = ['map', 'array', 'object'];
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */

var Replaceable =
/*#__PURE__*/
function () {
  function Replaceable(object) {
    _classCallCheck(this, Replaceable);

    _defineProperty(this, 'object', void 0);

    _defineProperty(this, 'type', void 0);

    this.object = object;
    this.type = (0, _jestGetType["default"])(object);

    if (!supportTypes.includes(this.type)) {
      throw new Error("Type ".concat(this.type, " is not support in Replaceable!"));
    }
  }

  _createClass(Replaceable, [{
    key: "forEach",
    value: function forEach(cb) {
      var _this = this;

      if (this.type === 'object') {
        var descriptors = Object.getOwnPropertyDescriptors(this.object);
        [].concat(_toConsumableArray(Object.keys(descriptors)), _toConsumableArray(Object.getOwnPropertySymbols(descriptors))) //@ts-expect-error because typescript do not support symbol key in object
        //https://github.com/microsoft/TypeScript/issues/1863
        .filter(function (key) {
          return descriptors[key].enumerable;
        }).forEach(function (key) {
          cb(_this.object[key], key, _this.object);
        });
      } else {
        this.object.forEach(cb);
      }
    }
  }, {
    key: "get",
    value: function get(key) {
      if (this.type === 'map') {
        return this.object.get(key);
      }

      return this.object[key];
    }
  }, {
    key: "set",
    value: function set(key, value) {
      if (this.type === 'map') {
        this.object.set(key, value);
      } else {
        this.object[key] = value;
      }
    }
  }], [{
    key: "isReplaceable",
    value: function isReplaceable(obj1, obj2) {
      var obj1Type = (0, _jestGetType["default"])(obj1);
      var obj2Type = (0, _jestGetType["default"])(obj2);
      return obj1Type === obj2Type && supportTypes.includes(obj1Type);
    }
  }]);

  return Replaceable;
}();
/* eslint-enable */


exports["default"] = Replaceable;