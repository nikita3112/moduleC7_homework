'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.matcherHint = exports.matcherErrorMessage = exports.getLabelPrinter = exports.pluralize = exports.diff = exports.printDiffOrStringify = exports.ensureExpectedIsNonNegativeInteger = exports.ensureNumbers = exports.ensureExpectedIsNumber = exports.ensureActualIsNumber = exports.ensureNoExpected = exports.printWithType = exports.printExpected = exports.printReceived = exports.highlightTrailingWhitespace = exports.stringify = exports.SUGGEST_TO_CONTAIN_EQUAL = exports.DIM_COLOR = exports.BOLD_WEIGHT = exports.INVERTED_COLOR = exports.RECEIVED_COLOR = exports.EXPECTED_COLOR = void 0;

var _chalk = _interopRequireDefault(require('chalk'));

var _jestDiff = _interopRequireWildcard(require('jest-diff'));

var _jestGetType = _interopRequireDefault(require('jest-get-type'));

var _prettyFormat = _interopRequireDefault(require('pretty-format'));

var _Replaceable = _interopRequireDefault(require('./Replaceable'));

var _deepCyclicCopyReplaceable = _interopRequireDefault(require('./deepCyclicCopyReplaceable'));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== 'function') return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/* eslint-disable local/ban-types-eventually */


var _prettyFormat$default = _prettyFormat["default"].plugins,
    AsymmetricMatcher = _prettyFormat$default.AsymmetricMatcher,
    DOMCollection = _prettyFormat$default.DOMCollection,
    DOMElement = _prettyFormat$default.DOMElement,
    Immutable = _prettyFormat$default.Immutable,
    ReactElement = _prettyFormat$default.ReactElement,
    ReactTestComponent = _prettyFormat$default.ReactTestComponent;
var PLUGINS = [ReactTestComponent, ReactElement, DOMElement, DOMCollection, Immutable, AsymmetricMatcher];
var EXPECTED_COLOR = _chalk["default"].green;
exports.EXPECTED_COLOR = EXPECTED_COLOR;
var RECEIVED_COLOR = _chalk["default"].red;
exports.RECEIVED_COLOR = RECEIVED_COLOR;
var INVERTED_COLOR = _chalk["default"].inverse;
exports.INVERTED_COLOR = INVERTED_COLOR;
var BOLD_WEIGHT = _chalk["default"].bold;
exports.BOLD_WEIGHT = BOLD_WEIGHT;
var DIM_COLOR = _chalk["default"].dim;
exports.DIM_COLOR = DIM_COLOR;
var MULTILINE_REGEXP = /\n/;
var SPACE_SYMBOL = "\xB7"; // middle dot

var NUMBERS = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'eleven', 'twelve', 'thirteen'];

var SUGGEST_TO_CONTAIN_EQUAL = _chalk["default"].dim('Looks like you wanted to test for object/array equality with the stricter `toContain` matcher. You probably need to use `toContainEqual` instead.');

exports.SUGGEST_TO_CONTAIN_EQUAL = SUGGEST_TO_CONTAIN_EQUAL;

var stringify = function stringify(object) {
  var maxDepth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
  var MAX_LENGTH = 10000;
  var result;

  try {
    result = (0, _prettyFormat["default"])(object, {
      maxDepth: maxDepth,
      min: true,
      plugins: PLUGINS
    });
  } catch (_unused) {
    result = (0, _prettyFormat["default"])(object, {
      callToJSON: false,
      maxDepth: maxDepth,
      min: true,
      plugins: PLUGINS
    });
  }

  return result.length >= MAX_LENGTH && maxDepth > 1 ? stringify(object, Math.floor(maxDepth / 2)) : result;
};

exports.stringify = stringify;

var highlightTrailingWhitespace = function highlightTrailingWhitespace(text) {
  return text.replace(/\s+$/gm, _chalk["default"].inverse('$&'));
}; // Instead of inverse highlight which now implies a change,
// replace common spaces with middle dot at the end of any line.


exports.highlightTrailingWhitespace = highlightTrailingWhitespace;

var replaceTrailingSpaces = function replaceTrailingSpaces(text) {
  return text.replace(/\s+$/gm, function (spaces) {
    return SPACE_SYMBOL.repeat(spaces.length);
  });
};

var printReceived = function printReceived(object) {
  return RECEIVED_COLOR(replaceTrailingSpaces(stringify(object)));
};

exports.printReceived = printReceived;

var printExpected = function printExpected(value) {
  return EXPECTED_COLOR(replaceTrailingSpaces(stringify(value)));
};

exports.printExpected = printExpected;

var printWithType = function printWithType(name, value, print) {
  var type = (0, _jestGetType["default"])(value);
  var hasType = type !== 'null' && type !== 'undefined' ? "".concat(name, " has type:  ").concat(type, "\n") : '';
  var hasValue = "".concat(name, " has value: ").concat(print(value));
  return hasType + hasValue;
};

exports.printWithType = printWithType;

var ensureNoExpected = function ensureNoExpected(expected, matcherName, options) {
  if (typeof expected !== 'undefined') {
    // Prepend maybe not only for backward compatibility.
    var matcherString = (options ? '' : '[.not]') + matcherName;
    throw new Error(matcherErrorMessage(matcherHint(matcherString, undefined, '', options), // Because expected is omitted in hint above,
    // expected is black instead of green in message below.
    'this matcher must not have an expected argument', printWithType('Expected', expected, printExpected)));
  }
};
/**
 * Ensures that `actual` is of type `number | bigint`
 */


exports.ensureNoExpected = ensureNoExpected;

var ensureActualIsNumber = function ensureActualIsNumber(actual, matcherName, options) {
  if (typeof actual !== 'number' && typeof actual !== 'bigint') {
    // Prepend maybe not only for backward compatibility.
    var matcherString = (options ? '' : '[.not]') + matcherName;
    throw new Error(matcherErrorMessage(matcherHint(matcherString, undefined, undefined, options), "".concat(RECEIVED_COLOR('received'), " value must be a number or bigint"), printWithType('Received', actual, printReceived)));
  }
};
/**
 * Ensures that `expected` is of type `number | bigint`
 */


exports.ensureActualIsNumber = ensureActualIsNumber;

var ensureExpectedIsNumber = function ensureExpectedIsNumber(expected, matcherName, options) {
  if (typeof expected !== 'number' && typeof expected !== 'bigint') {
    // Prepend maybe not only for backward compatibility.
    var matcherString = (options ? '' : '[.not]') + matcherName;
    throw new Error(matcherErrorMessage(matcherHint(matcherString, undefined, undefined, options), "".concat(EXPECTED_COLOR('expected'), " value must be a number or bigint"), printWithType('Expected', expected, printExpected)));
  }
};
/**
 * Ensures that `actual` & `expected` are of type `number | bigint`
 */


exports.ensureExpectedIsNumber = ensureExpectedIsNumber;

var ensureNumbers = function ensureNumbers(actual, expected, matcherName, options) {
  ensureActualIsNumber(actual, matcherName, options);
  ensureExpectedIsNumber(expected, matcherName, options);
};

exports.ensureNumbers = ensureNumbers;

var ensureExpectedIsNonNegativeInteger = function ensureExpectedIsNonNegativeInteger(expected, matcherName, options) {
  if (typeof expected !== 'number' || !Number.isSafeInteger(expected) || expected < 0) {
    // Prepend maybe not only for backward compatibility.
    var matcherString = (options ? '' : '[.not]') + matcherName;
    throw new Error(matcherErrorMessage(matcherHint(matcherString, undefined, undefined, options), "".concat(EXPECTED_COLOR('expected'), " value must be a non-negative integer"), printWithType('Expected', expected, printExpected)));
  }
}; // Given array of diffs, return concatenated string:
// * include common substrings
// * exclude change substrings which have opposite op
// * include change substrings which have argument op
//   with inverse highlight only if there is a common substring


exports.ensureExpectedIsNonNegativeInteger = ensureExpectedIsNonNegativeInteger;

var getCommonAndChangedSubstrings = function getCommonAndChangedSubstrings(diffs, op, hasCommonDiff) {
  return diffs.reduce(function (reduced, diff) {
    return reduced + (diff[0] === _jestDiff.DIFF_EQUAL ? diff[1] : diff[0] !== op ? '' : hasCommonDiff ? INVERTED_COLOR(diff[1]) : diff[1]);
  }, '');
};

var isLineDiffable = function isLineDiffable(expected, received) {
  var expectedType = (0, _jestGetType["default"])(expected);
  var receivedType = (0, _jestGetType["default"])(received);

  if (expectedType !== receivedType) {
    return false;
  }

  if (_jestGetType["default"].isPrimitive(expected)) {
    // Print generic line diff for strings only:
    // * if neither string is empty
    // * if either string has more than one line
    return typeof expected === 'string' && typeof received === 'string' && expected.length !== 0 && received.length !== 0 && (MULTILINE_REGEXP.test(expected) || MULTILINE_REGEXP.test(received));
  }

  if (expectedType === 'date' || expectedType === 'function' || expectedType === 'regexp') {
    return false;
  }

  if (expected instanceof Error && received instanceof Error) {
    return false;
  }

  if (expectedType === 'object' && typeof expected.asymmetricMatch === 'function') {
    return false;
  }

  if (receivedType === 'object' && typeof received.asymmetricMatch === 'function') {
    return false;
  }

  return true;
};

var MAX_DIFF_STRING_LENGTH = 20000;

var printDiffOrStringify = function printDiffOrStringify(expected, received, expectedLabel, receivedLabel, expand) {
  if (typeof expected === 'string' && typeof received === 'string' && expected.length !== 0 && received.length !== 0 && expected.length <= MAX_DIFF_STRING_LENGTH && received.length <= MAX_DIFF_STRING_LENGTH && expected !== received) {
    if (expected.includes('\n') || received.includes('\n')) {
      return (0, _jestDiff.diffStringsUnified)(expected, received, {
        aAnnotation: expectedLabel,
        bAnnotation: receivedLabel,
        changeLineTrailingSpaceColor: _chalk["default"].bgYellow,
        commonLineTrailingSpaceColor: _chalk["default"].bgYellow,
        emptyFirstOrLastLinePlaceholder: '↵',
        // U+21B5
        expand: expand,
        includeChangeCounts: true
      });
    }

    var diffs = (0, _jestDiff.diffStringsRaw)(expected, received, true);
    var hasCommonDiff = diffs.some(function (diff) {
      return diff[0] === _jestDiff.DIFF_EQUAL;
    });

    var _printLabel = getLabelPrinter(expectedLabel, receivedLabel);

    var _expectedLine = _printLabel(expectedLabel) + printExpected(getCommonAndChangedSubstrings(diffs, _jestDiff.DIFF_DELETE, hasCommonDiff));

    var _receivedLine = _printLabel(receivedLabel) + printReceived(getCommonAndChangedSubstrings(diffs, _jestDiff.DIFF_INSERT, hasCommonDiff));

    return _expectedLine + '\n' + _receivedLine;
  }

  if (isLineDiffable(expected, received)) {
    var _replaceMatchedToAsym = replaceMatchedToAsymmetricMatcher((0, _deepCyclicCopyReplaceable["default"])(expected), (0, _deepCyclicCopyReplaceable["default"])(received), [], []),
        replacedExpected = _replaceMatchedToAsym.replacedExpected,
        replacedReceived = _replaceMatchedToAsym.replacedReceived;

    var difference = (0, _jestDiff["default"])(replacedExpected, replacedReceived, {
      aAnnotation: expectedLabel,
      bAnnotation: receivedLabel,
      expand: expand,
      includeChangeCounts: true
    });

    if (typeof difference === 'string' && difference.includes('- ' + expectedLabel) && difference.includes('+ ' + receivedLabel)) {
      return difference;
    }
  }

  var printLabel = getLabelPrinter(expectedLabel, receivedLabel);
  var expectedLine = printLabel(expectedLabel) + printExpected(expected);
  var receivedLine = printLabel(receivedLabel) + (stringify(expected) === stringify(received) ? 'serializes to the same string' : printReceived(received));
  return expectedLine + '\n' + receivedLine;
}; // Sometimes, e.g. when comparing two numbers, the output from jest-diff
// does not contain more information than the `Expected:` / `Received:` already gives.
// In those cases, we do not print a diff to make the output shorter and not redundant.


exports.printDiffOrStringify = printDiffOrStringify;

var shouldPrintDiff = function shouldPrintDiff(actual, expected) {
  if (typeof actual === 'number' && typeof expected === 'number') {
    return false;
  }

  if (typeof actual === 'bigint' && typeof expected === 'bigint') {
    return false;
  }

  if (typeof actual === 'boolean' && typeof expected === 'boolean') {
    return false;
  }

  return true;
};

function replaceMatchedToAsymmetricMatcher(replacedExpected, replacedReceived, expectedCycles, receivedCycles) {
  if (!_Replaceable["default"].isReplaceable(replacedExpected, replacedReceived)) {
    return {
      replacedExpected: replacedExpected,
      replacedReceived: replacedReceived
    };
  }

  if (expectedCycles.includes(replacedExpected) || receivedCycles.includes(replacedReceived)) {
    return {
      replacedExpected: replacedExpected,
      replacedReceived: replacedReceived
    };
  }

  expectedCycles.push(replacedExpected);
  receivedCycles.push(replacedReceived);
  var expectedReplaceable = new _Replaceable["default"](replacedExpected);
  var receivedReplaceable = new _Replaceable["default"](replacedReceived);
  expectedReplaceable.forEach(function (expectedValue, key) {
    var receivedValue = receivedReplaceable.get(key);

    if (isAsymmetricMatcher(expectedValue)) {
      if (expectedValue.asymmetricMatch(receivedValue)) {
        receivedReplaceable.set(key, expectedValue);
      }
    } else if (isAsymmetricMatcher(receivedValue)) {
      if (receivedValue.asymmetricMatch(expectedValue)) {
        expectedReplaceable.set(key, receivedValue);
      }
    } else if (_Replaceable["default"].isReplaceable(expectedValue, receivedValue)) {
      var replaced = replaceMatchedToAsymmetricMatcher(expectedValue, receivedValue, expectedCycles, receivedCycles);
      expectedReplaceable.set(key, replaced.replacedExpected);
      receivedReplaceable.set(key, replaced.replacedReceived);
    }
  });
  return {
    replacedExpected: expectedReplaceable.object,
    replacedReceived: receivedReplaceable.object
  };
}

function isAsymmetricMatcher(data) {
  var type = (0, _jestGetType["default"])(data);
  return type === 'object' && typeof data.asymmetricMatch === 'function';
}

var diff = function diff(a, b, options) {
  return shouldPrintDiff(a, b) ? (0, _jestDiff["default"])(a, b, options) : null;
};

exports.diff = diff;

var pluralize = function pluralize(word, count) {
  return (NUMBERS[count] || count) + ' ' + word + (count === 1 ? '' : 's');
}; // To display lines of labeled values as two columns with monospace alignment:
// given the strings which will describe the values,
// return function which given each string, returns the label:
// string, colon, space, and enough padding spaces to align the value.


exports.pluralize = pluralize;

var getLabelPrinter = function getLabelPrinter() {
  for (var _len = arguments.length, strings = new Array(_len), _key = 0; _key < _len; _key++) {
    strings[_key] = arguments[_key];
  }

  var maxLength = strings.reduce(function (max, string) {
    return string.length > max ? string.length : max;
  }, 0);
  return function (string) {
    return "".concat(string, ": ").concat(' '.repeat(maxLength - string.length));
  };
};

exports.getLabelPrinter = getLabelPrinter;

var matcherErrorMessage = function matcherErrorMessage(hint, generic, specific) {
  return "".concat(hint, "\n\n").concat(_chalk["default"].bold('Matcher error'), ": ").concat(generic).concat(typeof specific === 'string' ? '\n\n' + specific : '');
}; // Display assertion for the report when a test fails.
// New format: rejects/resolves, not, and matcher name have black color
// Old format: matcher name has dim color


exports.matcherErrorMessage = matcherErrorMessage;

var matcherHint = function matcherHint(matcherName) {
  var received = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'received';
  var expected = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'expected';
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var _options$comment = options.comment,
      comment = _options$comment === void 0 ? '' : _options$comment,
      _options$expectedColo = options.expectedColor,
      expectedColor = _options$expectedColo === void 0 ? EXPECTED_COLOR : _options$expectedColo,
      _options$isDirectExpe = options.isDirectExpectCall,
      isDirectExpectCall = _options$isDirectExpe === void 0 ? false : _options$isDirectExpe,
      _options$isNot = options.isNot,
      isNot = _options$isNot === void 0 ? false : _options$isNot,
      _options$promise = options.promise,
      promise = _options$promise === void 0 ? '' : _options$promise,
      _options$receivedColo = options.receivedColor,
      receivedColor = _options$receivedColo === void 0 ? RECEIVED_COLOR : _options$receivedColo,
      _options$secondArgume = options.secondArgument,
      secondArgument = _options$secondArgume === void 0 ? '' : _options$secondArgume,
      _options$secondArgume2 = options.secondArgumentColor,
      secondArgumentColor = _options$secondArgume2 === void 0 ? EXPECTED_COLOR : _options$secondArgume2;
  var hint = '';
  var dimString = 'expect'; // concatenate adjacent dim substrings

  if (!isDirectExpectCall && received !== '') {
    hint += DIM_COLOR(dimString + '(') + receivedColor(received);
    dimString = ')';
  }

  if (promise !== '') {
    hint += DIM_COLOR(dimString + '.') + promise;
    dimString = '';
  }

  if (isNot) {
    hint += DIM_COLOR(dimString + '.') + 'not';
    dimString = '';
  }

  if (matcherName.includes('.')) {
    // Old format: for backward compatibility,
    // especially without promise or isNot options
    dimString += matcherName;
  } else {
    // New format: omit period from matcherName arg
    hint += DIM_COLOR(dimString + '.') + matcherName;
    dimString = '';
  }

  if (expected === '') {
    dimString += '()';
  } else {
    hint += DIM_COLOR(dimString + '(') + expectedColor(expected);

    if (secondArgument) {
      hint += DIM_COLOR(', ') + secondArgumentColor(secondArgument);
    }

    dimString = ')';
  }

  if (comment !== '') {
    dimString += ' // ' + comment;
  }

  if (dimString !== '') {
    hint += DIM_COLOR(dimString);
  }

  return hint;
};

exports.matcherHint = matcherHint;