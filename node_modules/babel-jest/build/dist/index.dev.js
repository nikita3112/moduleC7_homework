'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _crypto() {
  var data = require('crypto');

  _crypto = function _crypto() {
    return data;
  };

  return data;
}

function path() {
  var data = _interopRequireWildcard(require('path'));

  path = function path() {
    return data;
  };

  return data;
}

function _core() {
  var data = require('@babel/core');

  _core = function _core() {
    return data;
  };

  return data;
}

function _chalk() {
  var data = _interopRequireDefault(require('chalk'));

  _chalk = function _chalk() {
    return data;
  };

  return data;
}

function fs() {
  var data = _interopRequireWildcard(require('graceful-fs'));

  fs = function fs() {
    return data;
  };

  return data;
}

function _slash() {
  var data = _interopRequireDefault(require('slash'));

  _slash = function _slash() {
    return data;
  };

  return data;
}

var _loadBabelConfig = require('./loadBabelConfig');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== 'function') return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var THIS_FILE = fs().readFileSync(__filename);

var jestPresetPath = require.resolve('babel-preset-jest');

var babelIstanbulPlugin = require.resolve('babel-plugin-istanbul'); // Narrow down the types


var createTransformer = function createTransformer(userOptions) {
  var _inputOptions$plugins, _inputOptions$presets;

  var inputOptions = userOptions !== null && userOptions !== void 0 ? userOptions : {};

  var options = _objectSpread({}, inputOptions, {
    caller: _objectSpread({
      name: 'babel-jest',
      supportsDynamicImport: false,
      supportsExportNamespaceFrom: false,
      supportsStaticESM: false,
      supportsTopLevelAwait: false
    }, inputOptions.caller),
    compact: false,
    plugins: (_inputOptions$plugins = inputOptions.plugins) !== null && _inputOptions$plugins !== void 0 ? _inputOptions$plugins : [],
    presets: ((_inputOptions$presets = inputOptions.presets) !== null && _inputOptions$presets !== void 0 ? _inputOptions$presets : []).concat(jestPresetPath),
    sourceMaps: 'both'
  });

  function loadBabelConfig(cwd, filename, transformOptions) {
    var _transformOptions$sup, _transformOptions$sup2, _transformOptions$sup3, _transformOptions$sup4; // `cwd` first to allow incoming options to override it


    var babelConfig = (0, _loadBabelConfig.loadPartialConfig)(_objectSpread({
      cwd: cwd
    }, options, {
      caller: _objectSpread({}, options.caller, {
        supportsDynamicImport: (_transformOptions$sup = transformOptions === null || transformOptions === void 0 ? void 0 : transformOptions.supportsDynamicImport) !== null && _transformOptions$sup !== void 0 ? _transformOptions$sup : options.caller.supportsDynamicImport,
        supportsExportNamespaceFrom: (_transformOptions$sup2 = transformOptions === null || transformOptions === void 0 ? void 0 : transformOptions.supportsExportNamespaceFrom) !== null && _transformOptions$sup2 !== void 0 ? _transformOptions$sup2 : options.caller.supportsExportNamespaceFrom,
        supportsStaticESM: (_transformOptions$sup3 = transformOptions === null || transformOptions === void 0 ? void 0 : transformOptions.supportsStaticESM) !== null && _transformOptions$sup3 !== void 0 ? _transformOptions$sup3 : options.caller.supportsStaticESM,
        supportsTopLevelAwait: (_transformOptions$sup4 = transformOptions === null || transformOptions === void 0 ? void 0 : transformOptions.supportsTopLevelAwait) !== null && _transformOptions$sup4 !== void 0 ? _transformOptions$sup4 : options.caller.supportsTopLevelAwait
      }),
      filename: filename
    }));

    if (!babelConfig) {
      throw new Error("babel-jest: Babel ignores ".concat(_chalk()["default"].bold((0, _slash()["default"])(path().relative(cwd, filename))), " - make sure to include the file in Jest's ").concat(_chalk()["default"].bold('transformIgnorePatterns'), " as well."));
    }

    return babelConfig;
  }

  return {
    canInstrument: true,
    getCacheKey: function getCacheKey(fileData, filename, configString, cacheKeyOptions) {
      var config = cacheKeyOptions.config,
          instrument = cacheKeyOptions.instrument,
          rootDir = cacheKeyOptions.rootDir;
      var babelOptions = loadBabelConfig(config.cwd, filename, cacheKeyOptions);
      var configPath = [babelOptions.config || '', babelOptions.babelrc || ''];
      return (0, _crypto().createHash)('md5').update(THIS_FILE).update('\0', 'utf8').update(JSON.stringify(babelOptions.options)).update('\0', 'utf8').update(fileData).update('\0', 'utf8').update(path().relative(rootDir, filename)).update('\0', 'utf8').update(configString).update('\0', 'utf8').update(configPath.join('')).update('\0', 'utf8').update(instrument ? 'instrument' : '').update('\0', 'utf8').update(process.env.NODE_ENV || '').update('\0', 'utf8').update(process.env.BABEL_ENV || '').digest('hex');
    },
    process: function process(src, filename, config, transformOptions) {
      var babelOptions = _objectSpread({}, loadBabelConfig(config.cwd, filename, transformOptions).options);

      if (transformOptions === null || transformOptions === void 0 ? void 0 : transformOptions.instrument) {
        babelOptions.auxiliaryCommentBefore = ' istanbul ignore next '; // Copied from jest-runtime transform.js

        babelOptions.plugins = (babelOptions.plugins || []).concat([[babelIstanbulPlugin, {
          // files outside `cwd` will not be instrumented
          cwd: config.rootDir,
          exclude: []
        }]]);
      }

      var transformResult = (0, _core().transformSync)(src, babelOptions);

      if (transformResult) {
        var code = transformResult.code,
            map = transformResult.map;

        if (typeof code === 'string') {
          return {
            code: code,
            map: map
          };
        }
      }

      return src;
    }
  };
};

var transformer = _objectSpread({}, createTransformer(), {
  // Assigned here so only the exported transformer has `createTransformer`,
  // instead of all created transformers by the function
  createTransformer: createTransformer
});

module.exports = transformer;