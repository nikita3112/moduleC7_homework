'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var path = require('path');

var _require = require('util'),
    promisify = _require.promisify;

var _glob = promisify(require('glob'));

var minimatch = require('minimatch');

var _require2 = require('@istanbuljs/schema'),
    defaults = _require2.defaults;

var isOutsideDir = require('./is-outside-dir');

var TestExclude =
/*#__PURE__*/
function () {
  function TestExclude() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, TestExclude);

    Object.assign(this, {
      relativePath: true
    }, defaults.testExclude);

    for (var _i = 0, _Object$entries = Object.entries(opts); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          name = _Object$entries$_i[0],
          value = _Object$entries$_i[1];

      if (value !== undefined) {
        this[name] = value;
      }
    }

    if (typeof this.include === 'string') {
      this.include = [this.include];
    }

    if (typeof this.exclude === 'string') {
      this.exclude = [this.exclude];
    }

    if (typeof this.extension === 'string') {
      this.extension = [this.extension];
    } else if (this.extension.length === 0) {
      this.extension = false;
    }

    if (this.include && this.include.length > 0) {
      this.include = prepGlobPatterns([].concat(this.include));
    } else {
      this.include = false;
    }

    if (this.excludeNodeModules && !this.exclude.includes('**/node_modules/**')) {
      this.exclude = this.exclude.concat('**/node_modules/**');
    }

    this.exclude = prepGlobPatterns([].concat(this.exclude));
    this.handleNegation();
  }
  /* handle the special case of negative globs
   * (!**foo/bar); we create a new this.excludeNegated set
   * of rules, which is applied after excludes and we
   * move excluded include rules into this.excludes.
   */


  _createClass(TestExclude, [{
    key: "handleNegation",
    value: function handleNegation() {
      var noNeg = function noNeg(e) {
        return e.charAt(0) !== '!';
      };

      var onlyNeg = function onlyNeg(e) {
        return e.charAt(0) === '!';
      };

      var stripNeg = function stripNeg(e) {
        return e.slice(1);
      };

      if (Array.isArray(this.include)) {
        var _this$exclude;

        var includeNegated = this.include.filter(onlyNeg).map(stripNeg);

        (_this$exclude = this.exclude).push.apply(_this$exclude, _toConsumableArray(prepGlobPatterns(includeNegated)));

        this.include = this.include.filter(noNeg);
      }

      this.excludeNegated = this.exclude.filter(onlyNeg).map(stripNeg);
      this.exclude = this.exclude.filter(noNeg);
      this.excludeNegated = prepGlobPatterns(this.excludeNegated);
    }
  }, {
    key: "shouldInstrument",
    value: function shouldInstrument(filename, relFile) {
      if (this.extension && !this.extension.some(function (ext) {
        return filename.endsWith(ext);
      })) {
        return false;
      }

      var pathToCheck = filename;

      if (this.relativePath) {
        relFile = relFile || path.relative(this.cwd, filename); // Don't instrument files that are outside of the current working directory.

        if (isOutsideDir(this.cwd, filename)) {
          return false;
        }

        pathToCheck = relFile.replace(/^\.[\\/]/, ''); // remove leading './' or '.\'.
      }

      var dot = {
        dot: true
      };

      var matches = function matches(pattern) {
        return minimatch(pathToCheck, pattern, dot);
      };

      return (!this.include || this.include.some(matches)) && (!this.exclude.some(matches) || this.excludeNegated.some(matches));
    }
  }, {
    key: "globSync",
    value: function globSync() {
      var _this = this;

      var cwd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.cwd;
      var globPatterns = getExtensionPattern(this.extension || []);
      var globOptions = {
        cwd: cwd,
        nodir: true,
        dot: true
      };
      /* If we don't have any excludeNegated then we can optimize glob by telling
       * it to not iterate into unwanted directory trees (like node_modules). */

      if (this.excludeNegated.length === 0) {
        globOptions.ignore = this.exclude;
      }

      return _glob.sync(globPatterns, globOptions).filter(function (file) {
        return _this.shouldInstrument(path.resolve(cwd, file));
      });
    }
  }, {
    key: "glob",
    value: function glob() {
      var _this2 = this;

      var cwd,
          globPatterns,
          globOptions,
          list,
          _args = arguments;
      return regeneratorRuntime.async(function glob$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              cwd = _args.length > 0 && _args[0] !== undefined ? _args[0] : this.cwd;
              globPatterns = getExtensionPattern(this.extension || []);
              globOptions = {
                cwd: cwd,
                nodir: true,
                dot: true
              };
              /* If we don't have any excludeNegated then we can optimize glob by telling
               * it to not iterate into unwanted directory trees (like node_modules). */

              if (this.excludeNegated.length === 0) {
                globOptions.ignore = this.exclude;
              }

              _context.next = 6;
              return regeneratorRuntime.awrap(_glob(globPatterns, globOptions));

            case 6:
              list = _context.sent;
              return _context.abrupt("return", list.filter(function (file) {
                return _this2.shouldInstrument(path.resolve(cwd, file));
              }));

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
  }]);

  return TestExclude;
}();

function prepGlobPatterns(patterns) {
  return patterns.reduce(function (result, pattern) {
    // Allow gitignore style of directory exclusion
    if (!/\/\*\*$/.test(pattern)) {
      result = result.concat(pattern.replace(/\/$/, '') + '/**');
    } // Any rules of the form **/foo.js, should also match foo.js.


    if (/^\*\*\//.test(pattern)) {
      result = result.concat(pattern.replace(/^\*\*\//, ''));
    }

    return result.concat(pattern);
  }, []);
}

function getExtensionPattern(extension) {
  switch (extension.length) {
    case 0:
      return '**';

    case 1:
      return "**/*".concat(extension[0]);

    default:
      return "**/*{".concat(extension.join(), "}");
  }
}

module.exports = TestExclude;