"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var assert = require('assert');

var convertSourceMap = require('convert-source-map');

var _require = require('path'),
    dirname = _require.dirname,
    isAbsolute = _require.isAbsolute,
    join = _require.join,
    resolve = _require.resolve;

var CovBranch = require('./branch');

var CovFunction = require('./function');

var CovSource = require('./source');

var compatError = Error("requires Node.js ".concat(require('../package.json').engines.node));

var readFile = function readFile() {
  throw compatError;
};

try {
  readFile = require('fs').promises.readFile;
} catch (_err) {// most likely we're on an older version of Node.js.
}

var _require2 = require('source-map'),
    SourceMapConsumer = _require2.SourceMapConsumer;

var isOlderNode10 = /^v10\.(([0-9]\.)|(1[0-5]\.))/.test(process.version);
var isNode8 = /^v8\./.test(process.version); // Injected when Node.js is loading script into isolate pre Node 10.16.x.
// see: https://github.com/nodejs/node/pull/21573.

var cjsWrapperLength = isOlderNode10 ? require('module').wrapper[0].length : 0;

module.exports =
/*#__PURE__*/
function () {
  function V8ToIstanbul(scriptPath, wrapperLength, sources, excludePath) {
    _classCallCheck(this, V8ToIstanbul);

    assert(typeof scriptPath === 'string', 'scriptPath must be a string');
    assert(!isNode8, 'This module does not support node 8 or lower, please upgrade to node 10');
    this.path = parsePath(scriptPath);
    this.wrapperLength = wrapperLength === undefined ? cjsWrapperLength : wrapperLength;

    this.excludePath = excludePath || function () {
      return false;
    };

    this.sources = sources || {};
    this.generatedLines = [];
    this.branches = {};
    this.functions = {};
    this.covSources = [];
    this.rawSourceMap = undefined;
    this.sourceMap = undefined;
    this.sourceTranspiled = undefined; // Indicate that this report was generated with placeholder data from
    // running --all:

    this.all = false;
  }

  _createClass(V8ToIstanbul, [{
    key: "load",
    value: function load() {
      var _this = this;

      var rawSource, candidatePath, originalRawSource;
      return regeneratorRuntime.async(function load$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.t0 = this.sources.source;

              if (_context.t0) {
                _context.next = 5;
                break;
              }

              _context.next = 4;
              return regeneratorRuntime.awrap(readFile(this.path, 'utf8'));

            case 4:
              _context.t0 = _context.sent;

            case 5:
              rawSource = _context.t0;
              this.rawSourceMap = this.sources.sourceMap || // if we find a source-map (either inline, or a .map file) we load
              // both the transpiled and original source, both of which are used during
              // the backflips we perform to remap absolute to relative positions.
              convertSourceMap.fromSource(rawSource) || convertSourceMap.fromMapFileSource(rawSource, dirname(this.path));

              if (!this.rawSourceMap) {
                _context.next = 40;
                break;
              }

              if (!(this.rawSourceMap.sourcemap.sources.length > 1)) {
                _context.next = 16;
                break;
              }

              _context.next = 11;
              return regeneratorRuntime.awrap(new SourceMapConsumer(this.rawSourceMap.sourcemap));

            case 11:
              this.sourceMap = _context.sent;
              this.covSources = this.sourceMap.sourcesContent.map(function (rawSource, i) {
                return {
                  source: new CovSource(rawSource, _this.wrapperLength),
                  path: _this.sourceMap.sources[i]
                };
              });
              this.sourceTranspiled = new CovSource(rawSource, this.wrapperLength);
              _context.next = 38;
              break;

            case 16:
              candidatePath = this.rawSourceMap.sourcemap.sources.length >= 1 ? this.rawSourceMap.sourcemap.sources[0] : this.rawSourceMap.sourcemap.file;
              this.path = this._resolveSource(this.rawSourceMap, candidatePath);
              _context.next = 20;
              return regeneratorRuntime.awrap(new SourceMapConsumer(this.rawSourceMap.sourcemap));

            case 20:
              this.sourceMap = _context.sent;

              if (!(this.sources.sourceMap && this.sources.sourceMap.sourcemap && this.sources.sourceMap.sourcemap.sourcesContent && this.sources.sourceMap.sourcemap.sourcesContent.length === 1)) {
                _context.next = 25;
                break;
              }

              // If the sourcesContent field has been provided, return it rather than attempting
              // to load the original source from disk.
              // TODO: investigate whether there's ever a case where we hit this logic with 1:many sources.
              originalRawSource = this.sources.sourceMap.sourcemap.sourcesContent[0];
              _context.next = 36;
              break;

            case 25:
              if (!this.sources.originalSource) {
                _context.next = 29;
                break;
              }

              // Original source may be populated on the sources object.
              originalRawSource = this.sources.originalSource;
              _context.next = 36;
              break;

            case 29:
              if (!(this.sourceMap.sourcesContent && this.sourceMap.sourcesContent[0])) {
                _context.next = 33;
                break;
              }

              // perhaps we loaded sourcesContent was populated by an inline source map, or .map file?
              // TODO: investigate whether there's ever a case where we hit this logic with 1:many sources.
              originalRawSource = this.sourceMap.sourcesContent[0];
              _context.next = 36;
              break;

            case 33:
              _context.next = 35;
              return regeneratorRuntime.awrap(readFile(this.path, 'utf8'));

            case 35:
              originalRawSource = _context.sent;

            case 36:
              this.covSources = [{
                source: new CovSource(originalRawSource, this.wrapperLength),
                path: this.path
              }];
              this.sourceTranspiled = new CovSource(rawSource, this.wrapperLength);

            case 38:
              _context.next = 41;
              break;

            case 40:
              this.covSources = [{
                source: new CovSource(rawSource, this.wrapperLength),
                path: this.path
              }];

            case 41:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "_resolveSource",
    value: function _resolveSource(rawSourceMap, sourcePath) {
      sourcePath = sourcePath.replace(/(^file:\/\/)|(^webpack:\/\/)/, '');
      var sourceRoot = rawSourceMap.sourcemap.sourceRoot ? rawSourceMap.sourcemap.sourceRoot.replace('file://', '') : '';
      var candidatePath = join(sourceRoot, sourcePath);

      if (isAbsolute(candidatePath)) {
        return candidatePath;
      } else {
        return resolve(dirname(this.path), candidatePath);
      }
    }
  }, {
    key: "applyCoverage",
    value: function applyCoverage(blocks) {
      var _this2 = this;

      blocks.forEach(function (block) {
        block.ranges.forEach(function (range, i) {
          var _this2$_maybeRemapSta = _this2._maybeRemapStartColEndCol(range),
              startCol = _this2$_maybeRemapSta.startCol,
              endCol = _this2$_maybeRemapSta.endCol,
              path = _this2$_maybeRemapSta.path,
              covSource = _this2$_maybeRemapSta.covSource;

          if (_this2.excludePath(path)) {
            return;
          }

          var lines = covSource.lines.filter(function (line) {
            // Upstream tooling can provide a block with the functionName
            // (empty-report), this will result in a report that has all
            // lines zeroed out.
            if (block.functionName === '(empty-report)') {
              line.count = 0;
              _this2.all = true;
              return true;
            }

            return startCol < line.endCol && endCol >= line.startCol;
          });
          var startLineInstance = lines[0];
          var endLineInstance = lines[lines.length - 1];

          if (block.isBlockCoverage && lines.length) {
            _this2.branches[path] = _this2.branches[path] || []; // record branches.

            _this2.branches[path].push(new CovBranch(startLineInstance.line, startCol - startLineInstance.startCol, endLineInstance.line, endCol - endLineInstance.startCol, range.count)); // if block-level granularity is enabled, we we still create a single
            // CovFunction tracking object for each set of ranges.


            if (block.functionName && i === 0) {
              _this2.functions[path] = _this2.functions[path] || [];

              _this2.functions[path].push(new CovFunction(block.functionName, startLineInstance.line, startCol - startLineInstance.startCol, endLineInstance.line, endCol - endLineInstance.startCol, range.count));
            }
          } else if (block.functionName && lines.length) {
            _this2.functions[path] = _this2.functions[path] || []; // record functions.

            _this2.functions[path].push(new CovFunction(block.functionName, startLineInstance.line, startCol - startLineInstance.startCol, endLineInstance.line, endCol - endLineInstance.startCol, range.count));
          } // record the lines (we record these as statements, such that we're
          // compatible with Istanbul 2.0).


          lines.forEach(function (line) {
            // make sure branch spans entire line; don't record 'goodbye'
            // branch in `const foo = true ? 'hello' : 'goodbye'` as a
            // 0 for line coverage.
            //
            // All lines start out with coverage of 1, and are later set to 0
            // if they are not invoked; line.ignore prevents a line from being
            // set to 0, and is set if the special comment /* c8 ignore next */
            // is used.
            if (startCol <= line.startCol && endCol >= line.endCol && !line.ignore) {
              line.count = range.count;
            }
          });
        });
      });
    }
  }, {
    key: "_maybeRemapStartColEndCol",
    value: function _maybeRemapStartColEndCol(range) {
      var covSource = this.covSources[0].source;
      var startCol = Math.max(0, range.startOffset - covSource.wrapperLength);
      var endCol = Math.min(covSource.eof, range.endOffset - covSource.wrapperLength);
      var path = this.path;

      if (this.sourceMap) {
        startCol = Math.max(0, range.startOffset - this.sourceTranspiled.wrapperLength);
        endCol = Math.min(this.sourceTranspiled.eof, range.endOffset - this.sourceTranspiled.wrapperLength);

        var _this$sourceTranspile = this.sourceTranspiled.offsetToOriginalRelative(this.sourceMap, startCol, endCol),
            startLine = _this$sourceTranspile.startLine,
            relStartCol = _this$sourceTranspile.relStartCol,
            endLine = _this$sourceTranspile.endLine,
            relEndCol = _this$sourceTranspile.relEndCol,
            source = _this$sourceTranspile.source;

        var matchingSource = this.covSources.find(function (covSource) {
          return covSource.path === source;
        });
        covSource = matchingSource ? matchingSource.source : this.covSources[0].source;
        path = matchingSource ? matchingSource.path : this.covSources[0].path; // next we convert these relative positions back to absolute positions
        // in the original source (which is the format expected in the next step).

        startCol = covSource.relativeToOffset(startLine, relStartCol);
        endCol = covSource.relativeToOffset(endLine, relEndCol);
      }

      return {
        path: path,
        covSource: covSource,
        startCol: startCol,
        endCol: endCol
      };
    }
  }, {
    key: "getInnerIstanbul",
    value: function getInnerIstanbul(source, path) {
      // We apply the "Resolving Sources" logic (as defined in
      // sourcemaps.info/spec.html) as a final step for 1:many source maps.
      // for 1:1 source maps, the resolve logic is applied while loading.
      //
      // TODO: could we move the resolving logic for 1:1 source maps to the final
      // step as well? currently this breaks some tests in c8.
      var resolvedPath = path;

      if (this.rawSourceMap && this.rawSourceMap.sourcemap.sources.length > 1) {
        resolvedPath = this._resolveSource(this.rawSourceMap, path);
      }

      if (this.excludePath(resolvedPath)) {
        return;
      }

      return _defineProperty({}, resolvedPath, _objectSpread({
        path: resolvedPath,
        all: this.all
      }, this._statementsToIstanbul(source, path), {}, this._branchesToIstanbul(source, path), {}, this._functionsToIstanbul(source, path)));
    }
  }, {
    key: "toIstanbul",
    value: function toIstanbul() {
      var _this3 = this;

      return this.covSources.reduce(function (istanbulOuter, _ref2) {
        var source = _ref2.source,
            path = _ref2.path;
        return Object.assign(istanbulOuter, _this3.getInnerIstanbul(source, path));
      }, {});
    }
  }, {
    key: "_statementsToIstanbul",
    value: function _statementsToIstanbul(source, path) {
      var statements = {
        statementMap: {},
        s: {}
      };
      source.lines.forEach(function (line, index) {
        statements.statementMap["".concat(index)] = line.toIstanbul();
        statements.s["".concat(index)] = line.count;
      });
      return statements;
    }
  }, {
    key: "_branchesToIstanbul",
    value: function _branchesToIstanbul(source, path) {
      var branches = {
        branchMap: {},
        b: {}
      };
      this.branches[path] = this.branches[path] || [];
      this.branches[path].forEach(function (branch, index) {
        var ignore = source.lines[branch.startLine - 1].ignore;
        branches.branchMap["".concat(index)] = branch.toIstanbul();
        branches.b["".concat(index)] = [ignore ? 1 : branch.count];
      });
      return branches;
    }
  }, {
    key: "_functionsToIstanbul",
    value: function _functionsToIstanbul(source, path) {
      var functions = {
        fnMap: {},
        f: {}
      };
      this.functions[path] = this.functions[path] || [];
      this.functions[path].forEach(function (fn, index) {
        var ignore = source.lines[fn.startLine - 1].ignore;
        functions.fnMap["".concat(index)] = fn.toIstanbul();
        functions.f["".concat(index)] = ignore ? 1 : fn.count;
      });
      return functions;
    }
  }]);

  return V8ToIstanbul;
}();

function parsePath(scriptPath) {
  return scriptPath.replace('file://', '');
}