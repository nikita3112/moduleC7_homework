'use strict';
/*
 Copyright 2012-2015, Yahoo Inc.
 Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var fs = require('fs');

var path = require('path');

var _require = require('istanbul-lib-report'),
    ReportBase = _require.ReportBase;

var HtmlReport = require('../html');

var standardLinkMapper = {
  getPath: function getPath(node) {
    if (typeof node === 'string') {
      return node;
    }

    var filePath = node.getQualifiedName();

    if (node.isSummary()) {
      if (filePath !== '') {
        filePath += '/index.html';
      } else {
        filePath = 'index.html';
      }
    } else {
      filePath += '.html';
    }

    return filePath;
  },
  relativePath: function relativePath(source, target) {
    var targetPath = this.getPath(target);
    var sourcePath = path.dirname(this.getPath(source));
    return path.relative(sourcePath, targetPath);
  },
  assetPath: function assetPath(node, name) {
    return this.relativePath(this.getPath(node), name);
  }
};

var HtmlSpaReport =
/*#__PURE__*/
function (_ReportBase) {
  _inherits(HtmlSpaReport, _ReportBase);

  function HtmlSpaReport() {
    var _this;

    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, HtmlSpaReport);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(HtmlSpaReport).call(this, {
      // force the summarizer to nested for html-spa
      summarizer: 'nested'
    }));
    _this.verbose = opts.verbose || false;
    _this.linkMapper = opts.linkMapper || standardLinkMapper;
    _this.subdir = opts.subdir || '';
    _this.date = Date();
    _this.skipEmpty = opts.skipEmpty;
    _this.htmlReport = new HtmlReport(opts);

    _this.htmlReport.getBreadcrumbHtml = function () {
      return '<a href="javascript:history.back()">Back</a>';
    };

    _this.metricsToShow = opts.metricsToShow || ['lines', 'branches', 'functions'];
    return _this;
  }

  _createClass(HtmlSpaReport, [{
    key: "getWriter",
    value: function getWriter(context) {
      if (!this.subdir) {
        return context.writer;
      }

      return context.writer.writerForDir(this.subdir);
    }
  }, {
    key: "onStart",
    value: function onStart(root, context) {
      var _this2 = this;

      this.htmlReport.onStart(root, context);
      var writer = this.getWriter(context);
      var srcDir = path.resolve(__dirname, './assets');
      fs.readdirSync(srcDir).forEach(function (f) {
        var resolvedSource = path.resolve(srcDir, f);
        var resolvedDestination = '.';
        var stat = fs.statSync(resolvedSource);
        var dest;

        if (stat.isFile()) {
          dest = resolvedDestination + '/' + f;

          if (_this2.verbose) {
            console.log('Write asset: ' + dest);
          }

          writer.copyFile(resolvedSource, dest);
        }
      });
    }
  }, {
    key: "onDetail",
    value: function onDetail(node, context) {
      this.htmlReport.onDetail(node, context);
    }
  }, {
    key: "getMetric",
    value: function getMetric(metric, type, context) {
      var isEmpty = metric.total === 0;
      return {
        total: metric.total,
        covered: metric.covered,
        skipped: metric.skipped,
        pct: isEmpty ? 0 : metric.pct,
        classForPercent: isEmpty ? 'empty' : context.classForPercent(type, metric.pct)
      };
    }
  }, {
    key: "toDataStructure",
    value: function toDataStructure(node, context) {
      var _this3 = this;

      var coverageSummary = node.getCoverageSummary();
      var metrics = {
        statements: this.getMetric(coverageSummary.statements, 'statements', context),
        branches: this.getMetric(coverageSummary.branches, 'branches', context),
        functions: this.getMetric(coverageSummary.functions, 'functions', context),
        lines: this.getMetric(coverageSummary.lines, 'lines', context)
      };
      return {
        file: node.getRelativeName(),
        isEmpty: coverageSummary.isEmpty(),
        metrics: metrics,
        children: node.isSummary() && node.getChildren().map(function (child) {
          return _this3.toDataStructure(child, context);
        })
      };
    }
  }, {
    key: "onEnd",
    value: function onEnd(rootNode, context) {
      var data = this.toDataStructure(rootNode, context);
      var cw = this.getWriter(context).writeFile(this.linkMapper.getPath(rootNode));
      cw.write("<!doctype html>\n            <html lang=\"en\">\n                <head>\n                    <link rel=\"stylesheet\" href=\"spa.css\" />\n                    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n                </head>\n                <body>\n                    <div id=\"app\" class=\"app\"></div>\n                    <script>\n                        window.data = ".concat(JSON.stringify(data), ";\n                        window.generatedDatetime = ").concat(JSON.stringify(String(Date())), ";\n                        window.metricsToShow = ").concat(JSON.stringify(this.metricsToShow), ";\n                    </script>\n                    <script src=\"bundle.js\"></script>\n                </body>\n            </html>"));
      cw.close();
    }
  }]);

  return HtmlSpaReport;
}(ReportBase);

module.exports = HtmlSpaReport;