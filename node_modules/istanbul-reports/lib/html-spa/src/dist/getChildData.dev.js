"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function addPath(node, parentPath) {
  if (!parentPath) {
    return node;
  }

  return _objectSpread({}, node, {
    file: parentPath + '/' + node.file
  });
}

function flatten(nodes, parentPath) {
  var children = [];

  for (var i = 0; i < nodes.length; i++) {
    var child = nodes[i];

    if (child.children) {
      children = [].concat(_toConsumableArray(children), _toConsumableArray(flatten(child.children, (parentPath ? parentPath + '/' : '') + child.file)));
    } else {
      children.push(addPath(child, parentPath));
    }
  }

  return children;
}

function filterByFile(nodes, fileFilter, parentPath) {
  var children = [];

  for (var i = 0; i < nodes.length; i++) {
    var child = nodes[i];
    var childFullPath = (parentPath ? parentPath + '/' : '') + child.file;
    var isChildUnderFilter = fileFilter === childFullPath || fileFilter.indexOf(childFullPath + '/') === 0;
    var isChildAboveFilter = childFullPath.indexOf(fileFilter + '/') === 0;

    if (isChildUnderFilter) {
      // flatten and continue looking underneath
      children = [].concat(_toConsumableArray(children), _toConsumableArray(filterByFile(child.children, fileFilter, childFullPath)));
    } else if (isChildAboveFilter) {
      // remove the parent path and add everything underneath
      var charsToRemoveFromFile = fileFilter.length - (parentPath ? parentPath.length : 0);
      var childFilename = child.file.slice(charsToRemoveFromFile);

      if (childFilename[0] === '/') {
        childFilename = childFilename.slice(1);
      }

      children.push(_objectSpread({}, child, {
        file: childFilename
      }));
    }
  }

  return children;
}

function sort(childData, activeSort) {
  var top = activeSort.order === 'asc' ? 1 : -1;
  var bottom = activeSort.order === 'asc' ? -1 : 1;
  childData.sort(function (a, b) {
    var valueA;
    var valueB;

    if (activeSort.sortKey === 'file') {
      valueA = a.file;
      valueB = b.file;
    } else {
      var _activeSort$sortKey$s = activeSort.sortKey.split('.'),
          _activeSort$sortKey$s2 = _slicedToArray(_activeSort$sortKey$s, 2),
          metricType = _activeSort$sortKey$s2[0],
          valueType = _activeSort$sortKey$s2[1];

      valueA = a.metrics[metricType][valueType];
      valueB = b.metrics[metricType][valueType];
    }

    if (valueA === valueB) {
      return 0;
    }

    return valueA < valueB ? top : bottom;
  });

  for (var i = 0; i < childData.length; i++) {
    var child = childData[i];

    if (child.children) {
      childData[i] = _objectSpread({}, child, {
        children: sort(child.children, activeSort)
      });
    }
  }

  return childData;
}

function filter(nodes, metricsMap, activeFilters) {
  var children = [];

  for (var i = 0; i < nodes.length; i++) {
    var child = nodes[i];

    if (child.children) {
      var newSubChildren = filter(child.children, metricsMap, activeFilters);

      if (newSubChildren.length) {
        child = _objectSpread({}, child, {
          children: newSubChildren
        });
        children.push(child);
      }
    } else {
      if (metricsMap.statements && activeFilters[child.metrics.statements.classForPercent] || metricsMap.branches && activeFilters[child.metrics.branches.classForPercent] || metricsMap.functions && activeFilters[child.metrics.functions.classForPercent] || metricsMap.lines && activeFilters[child.metrics.lines.classForPercent]) {
        children.push(child);
      }
    }
  }

  return children;
}

module.exports = function getChildData(sourceData, metricsToShow, activeSort, isFlat, activeFilters, fileFilter) {
  var childData = sourceData.children;

  if (isFlat) {
    childData = flatten(childData.slice(0));
  }

  if (fileFilter) {
    childData = filterByFile(childData, fileFilter);
  }

  if (activeFilters.low) {
    activeFilters = _objectSpread({}, activeFilters, {
      empty: true
    });
  }

  childData = filter(childData, metricsToShow, activeFilters);

  if (activeSort) {
    childData = sort(childData, activeSort);
  }

  return childData;
};