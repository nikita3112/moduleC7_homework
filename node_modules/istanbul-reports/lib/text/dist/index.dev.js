/*
 Copyright 2012-2015, Yahoo Inc.
 Copyrights licensed under the New BSD License. See the accompanying LICENSE
 file for terms.
 */
'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var _require = require('istanbul-lib-report'),
    ReportBase = _require.ReportBase;

var NAME_COL = 4;
var PCT_COLS = 7;
var MISSING_COL = 17;
var TAB_SIZE = 1;
var DELIM = ' | ';

function padding(num, ch) {
  var str = '';
  var i;
  ch = ch || ' ';

  for (i = 0; i < num; i += 1) {
    str += ch;
  }

  return str;
}

function fill(str, width, right, tabs) {
  tabs = tabs || 0;
  str = String(str);
  var leadingSpaces = tabs * TAB_SIZE;
  var remaining = width - leadingSpaces;
  var leader = padding(leadingSpaces);
  var fmtStr = '';

  if (remaining > 0) {
    var strlen = str.length;
    var fillStr;

    if (remaining >= strlen) {
      fillStr = padding(remaining - strlen);
    } else {
      fillStr = '...';
      var length = remaining - fillStr.length;
      str = str.substring(strlen - length);
      right = true;
    }

    fmtStr = right ? fillStr + str : str + fillStr;
  }

  return leader + fmtStr;
}

function formatName(name, maxCols, level) {
  return fill(name, maxCols, false, level);
}

function formatPct(pct, width) {
  return fill(pct, width || PCT_COLS, true, 0);
}

function nodeMissing(node) {
  var _ref5;

  if (node.isSummary()) {
    return '';
  }

  var metrics = node.getCoverageSummary();
  var isEmpty = metrics.isEmpty();
  var lines = isEmpty ? 0 : metrics.lines.pct;
  var coveredLines;
  var fileCoverage = node.getFileCoverage();

  if (lines === 100) {
    var branches = fileCoverage.getBranchCoverageByLine();
    coveredLines = Object.entries(branches).map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          coverage = _ref2[1].coverage;

      return [key, coverage === 100];
    });
  } else {
    coveredLines = Object.entries(fileCoverage.getLineCoverage());
  }

  var newRange = true;
  var ranges = coveredLines.reduce(function (acum, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        line = _ref4[0],
        hit = _ref4[1];

    if (hit) newRange = true;else {
      line = parseInt(line);

      if (newRange) {
        acum.push([line]);
        newRange = false;
      } else acum[acum.length - 1][1] = line;
    }
    return acum;
  }, []).map(function (range) {
    var length = range.length;
    if (length === 1) return range[0];
    return "".concat(range[0], "-").concat(range[1]);
  });
  return (_ref5 = []).concat.apply(_ref5, _toConsumableArray(ranges)).join(',');
}

function nodeName(node) {
  return node.getRelativeName() || 'All files';
}

function depthFor(node) {
  var ret = 0;
  node = node.getParent();

  while (node) {
    ret += 1;
    node = node.getParent();
  }

  return ret;
}

function nullDepthFor() {
  return 0;
}

function findWidth(node, context, nodeExtractor) {
  var depthFor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : nullDepthFor;
  var last = 0;

  function compareWidth(node) {
    last = Math.max(last, TAB_SIZE * depthFor(node) + nodeExtractor(node).length);
  }

  var visitor = {
    onSummary: compareWidth,
    onDetail: compareWidth
  };
  node.visit(context.getVisitor(visitor));
  return last;
}

function makeLine(nameWidth, missingWidth) {
  var name = padding(nameWidth, '-');
  var pct = padding(PCT_COLS, '-');
  var elements = [];
  elements.push(name);
  elements.push(pct);
  elements.push(padding(PCT_COLS + 1, '-'));
  elements.push(pct);
  elements.push(pct);
  elements.push(padding(missingWidth, '-'));
  return elements.join(DELIM.replace(/ /g, '-')) + '-';
}

function tableHeader(maxNameCols, missingWidth) {
  var elements = [];
  elements.push(formatName('File', maxNameCols, 0));
  elements.push(formatPct('% Stmts'));
  elements.push(formatPct('% Branch', PCT_COLS + 1));
  elements.push(formatPct('% Funcs'));
  elements.push(formatPct('% Lines'));
  elements.push(formatName('Uncovered Line #s', missingWidth));
  return elements.join(DELIM) + ' ';
}

function isFull(metrics) {
  return metrics.statements.pct === 100 && metrics.branches.pct === 100 && metrics.functions.pct === 100 && metrics.lines.pct === 100;
}

function tableRow(node, context, colorizer, maxNameCols, level, skipEmpty, skipFull, missingWidth) {
  var name = nodeName(node);
  var metrics = node.getCoverageSummary();
  var isEmpty = metrics.isEmpty();

  if (skipEmpty && isEmpty) {
    return '';
  }

  if (skipFull && isFull(metrics)) {
    return '';
  }

  var mm = {
    statements: isEmpty ? 0 : metrics.statements.pct,
    branches: isEmpty ? 0 : metrics.branches.pct,
    functions: isEmpty ? 0 : metrics.functions.pct,
    lines: isEmpty ? 0 : metrics.lines.pct
  };
  var colorize = isEmpty ? function (str) {
    return str;
  } : function (str, key) {
    return colorizer(str, context.classForPercent(key, mm[key]));
  };
  var elements = [];
  elements.push(colorize(formatName(name, maxNameCols, level), 'statements'));
  elements.push(colorize(formatPct(mm.statements), 'statements'));
  elements.push(colorize(formatPct(mm.branches, PCT_COLS + 1), 'branches'));
  elements.push(colorize(formatPct(mm.functions), 'functions'));
  elements.push(colorize(formatPct(mm.lines), 'lines'));
  elements.push(colorizer(formatName(nodeMissing(node), missingWidth), mm.lines === 100 ? 'medium' : 'low'));
  return elements.join(DELIM) + ' ';
}

var TextReport =
/*#__PURE__*/
function (_ReportBase) {
  _inherits(TextReport, _ReportBase);

  function TextReport(opts) {
    var _this;

    _classCallCheck(this, TextReport);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(TextReport).call(this));
    opts = opts || {};
    var _opts = opts,
        maxCols = _opts.maxCols;
    _this.file = opts.file || null;
    _this.maxCols = maxCols != null ? maxCols : process.stdout.columns || 80;
    _this.cw = null;
    _this.skipEmpty = opts.skipEmpty;
    _this.skipFull = opts.skipFull;
    return _this;
  }

  _createClass(TextReport, [{
    key: "onStart",
    value: function onStart(root, context) {
      this.cw = context.writer.writeFile(this.file);
      this.nameWidth = Math.max(NAME_COL, findWidth(root, context, nodeName, depthFor));
      this.missingWidth = Math.max(MISSING_COL, findWidth(root, context, nodeMissing));

      if (this.maxCols > 0) {
        var pct_cols = DELIM.length + 4 * (PCT_COLS + DELIM.length) + 2;
        var maxRemaining = this.maxCols - (pct_cols + MISSING_COL);

        if (this.nameWidth > maxRemaining) {
          this.nameWidth = maxRemaining;
          this.missingWidth = MISSING_COL;
        } else if (this.nameWidth < maxRemaining) {
          var _maxRemaining = this.maxCols - (this.nameWidth + pct_cols);

          if (this.missingWidth > _maxRemaining) {
            this.missingWidth = _maxRemaining;
          }
        }
      }

      var line = makeLine(this.nameWidth, this.missingWidth);
      this.cw.println(line);
      this.cw.println(tableHeader(this.nameWidth, this.missingWidth));
      this.cw.println(line);
    }
  }, {
    key: "onSummary",
    value: function onSummary(node, context) {
      var nodeDepth = depthFor(node);
      var row = tableRow(node, context, this.cw.colorize.bind(this.cw), this.nameWidth, nodeDepth, this.skipEmpty, this.skipFull, this.missingWidth);

      if (row) {
        this.cw.println(row);
      }
    }
  }, {
    key: "onDetail",
    value: function onDetail(node, context) {
      return this.onSummary(node, context);
    }
  }, {
    key: "onEnd",
    value: function onEnd() {
      this.cw.println(makeLine(this.nameWidth, this.missingWidth));
      this.cw.close();
    }
  }]);

  return TextReport;
}(ReportBase);

module.exports = TextReport;