'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var os = require('os');

var onExit = require('signal-exit');

var DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5; // Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior

var spawnedKill = function spawnedKill(kill) {
  var signal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'SIGTERM';
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var killResult = kill(signal);
  setKillTimeout(kill, signal, options, killResult);
  return killResult;
};

var setKillTimeout = function setKillTimeout(kill, signal, options, killResult) {
  if (!shouldForceKill(signal, options, killResult)) {
    return;
  }

  var timeout = getForceKillAfterTimeout(options);
  var t = setTimeout(function () {
    kill('SIGKILL');
  }, timeout); // Guarded because there's no `.unref()` when `execa` is used in the renderer
  // process in Electron. This cannot be tested since we don't run tests in
  // Electron.
  // istanbul ignore else

  if (t.unref) {
    t.unref();
  }
};

var shouldForceKill = function shouldForceKill(signal, _ref, killResult) {
  var forceKillAfterTimeout = _ref.forceKillAfterTimeout;
  return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
};

var isSigterm = function isSigterm(signal) {
  return signal === os.constants.signals.SIGTERM || typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM';
};

var getForceKillAfterTimeout = function getForceKillAfterTimeout(_ref2) {
  var _ref2$forceKillAfterT = _ref2.forceKillAfterTimeout,
      forceKillAfterTimeout = _ref2$forceKillAfterT === void 0 ? true : _ref2$forceKillAfterT;

  if (forceKillAfterTimeout === true) {
    return DEFAULT_FORCE_KILL_TIMEOUT;
  }

  if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
    throw new TypeError("Expected the `forceKillAfterTimeout` option to be a non-negative integer, got `".concat(forceKillAfterTimeout, "` (").concat(_typeof(forceKillAfterTimeout), ")"));
  }

  return forceKillAfterTimeout;
}; // `childProcess.cancel()`


var spawnedCancel = function spawnedCancel(spawned, context) {
  var killResult = spawned.kill();

  if (killResult) {
    context.isCanceled = true;
  }
};

var timeoutKill = function timeoutKill(spawned, signal, reject) {
  spawned.kill(signal);
  reject(Object.assign(new Error('Timed out'), {
    timedOut: true,
    signal: signal
  }));
}; // `timeout` option handling


var setupTimeout = function setupTimeout(spawned, _ref3, spawnedPromise) {
  var timeout = _ref3.timeout,
      _ref3$killSignal = _ref3.killSignal,
      killSignal = _ref3$killSignal === void 0 ? 'SIGTERM' : _ref3$killSignal;

  if (timeout === 0 || timeout === undefined) {
    return spawnedPromise;
  }

  if (!Number.isFinite(timeout) || timeout < 0) {
    throw new TypeError("Expected the `timeout` option to be a non-negative integer, got `".concat(timeout, "` (").concat(_typeof(timeout), ")"));
  }

  var timeoutId;
  var timeoutPromise = new Promise(function (resolve, reject) {
    timeoutId = setTimeout(function () {
      timeoutKill(spawned, killSignal, reject);
    }, timeout);
  });
  var safeSpawnedPromise = spawnedPromise["finally"](function () {
    clearTimeout(timeoutId);
  });
  return Promise.race([timeoutPromise, safeSpawnedPromise]);
}; // `cleanup` option handling


var setExitHandler = function setExitHandler(spawned, _ref4, timedPromise) {
  var cleanup, detached, removeExitHandler;
  return regeneratorRuntime.async(function setExitHandler$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          cleanup = _ref4.cleanup, detached = _ref4.detached;

          if (!(!cleanup || detached)) {
            _context.next = 3;
            break;
          }

          return _context.abrupt("return", timedPromise);

        case 3:
          removeExitHandler = onExit(function () {
            spawned.kill();
          });
          return _context.abrupt("return", timedPromise["finally"](function () {
            removeExitHandler();
          }));

        case 5:
        case "end":
          return _context.stop();
      }
    }
  });
};

module.exports = {
  spawnedKill: spawnedKill,
  spawnedCancel: spawnedCancel,
  setupTimeout: setupTimeout,
  setExitHandler: setExitHandler
};