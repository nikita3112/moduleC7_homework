'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function path() {
  var data = _interopRequireWildcard(require('path'));

  path = function path() {
    return data;
  };

  return data;
}

function _fbWatchman() {
  var data = _interopRequireDefault(require('fb-watchman'));

  _fbWatchman = function _fbWatchman() {
    return data;
  };

  return data;
}

function _constants() {
  var data = _interopRequireDefault(require('../constants'));

  _constants = function _constants() {
    return data;
  };

  return data;
}

function fastPath() {
  var data = _interopRequireWildcard(require('../lib/fast_path'));

  fastPath = function fastPath() {
    return data;
  };

  return data;
}

function _normalizePathSep() {
  var data = _interopRequireDefault(require('../lib/normalizePathSep'));

  _normalizePathSep = function _normalizePathSep() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== 'function') return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var watchmanURL = 'https://facebook.github.io/watchman/docs/troubleshooting';

function WatchmanError(error) {
  error.message = "Watchman error: ".concat(error.message.trim(), ". Make sure watchman ") + "is running for this project. See ".concat(watchmanURL, ".");
  return error;
}

module.exports = function watchmanCrawl(options) {
  var fields, data, extensions, ignore, rootDir, roots, defaultWatchExpression, clocks, client, clientError, cmd, _ref, capabilities, getWatchmanRoots, queryWatchmanForDirs, files, removedFiles, changedFiles, watchmanFiles, isFresh, watchmanRoots, watchmanFileResults, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, _step4$value, watchRoot, response, fsRoot, relativeFsRoot, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, fileData, filePath, relativeFilePath, existingFileData, mtime, size, sha1hex, nextData;

  return regeneratorRuntime.async(function watchmanCrawl$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          queryWatchmanForDirs = function _ref5(rootProjectDirMappings) {
            var files, isFresh;
            return regeneratorRuntime.async(function queryWatchmanForDirs$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    files = new Map();
                    isFresh = false;
                    _context4.next = 4;
                    return regeneratorRuntime.awrap(Promise.all(Array.from(rootProjectDirMappings).map(function _callee2(_ref2) {
                      var _ref3, root, directoryFilters, expression, glob, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, directory, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, extension, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _extension, relativeRoot, query, response;

                      return regeneratorRuntime.async(function _callee2$(_context3) {
                        while (1) {
                          switch (_context3.prev = _context3.next) {
                            case 0:
                              _ref3 = _slicedToArray(_ref2, 2), root = _ref3[0], directoryFilters = _ref3[1];
                              expression = Array.from(defaultWatchExpression);
                              glob = [];

                              if (!(directoryFilters.length > 0)) {
                                _context3.next = 50;
                                break;
                              }

                              expression.push(['anyof'].concat(_toConsumableArray(directoryFilters.map(function (dir) {
                                return ['dirname', dir];
                              }))));
                              _iteratorNormalCompletion = true;
                              _didIteratorError = false;
                              _iteratorError = undefined;
                              _context3.prev = 8;
                              _iterator = directoryFilters[Symbol.iterator]();

                            case 10:
                              if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                                _context3.next = 34;
                                break;
                              }

                              directory = _step.value;
                              _iteratorNormalCompletion2 = true;
                              _didIteratorError2 = false;
                              _iteratorError2 = undefined;
                              _context3.prev = 15;

                              for (_iterator2 = extensions[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                                extension = _step2.value;
                                glob.push("".concat(directory, "/**/*.").concat(extension));
                              }

                              _context3.next = 23;
                              break;

                            case 19:
                              _context3.prev = 19;
                              _context3.t0 = _context3["catch"](15);
                              _didIteratorError2 = true;
                              _iteratorError2 = _context3.t0;

                            case 23:
                              _context3.prev = 23;
                              _context3.prev = 24;

                              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                                _iterator2["return"]();
                              }

                            case 26:
                              _context3.prev = 26;

                              if (!_didIteratorError2) {
                                _context3.next = 29;
                                break;
                              }

                              throw _iteratorError2;

                            case 29:
                              return _context3.finish(26);

                            case 30:
                              return _context3.finish(23);

                            case 31:
                              _iteratorNormalCompletion = true;
                              _context3.next = 10;
                              break;

                            case 34:
                              _context3.next = 40;
                              break;

                            case 36:
                              _context3.prev = 36;
                              _context3.t1 = _context3["catch"](8);
                              _didIteratorError = true;
                              _iteratorError = _context3.t1;

                            case 40:
                              _context3.prev = 40;
                              _context3.prev = 41;

                              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                                _iterator["return"]();
                              }

                            case 43:
                              _context3.prev = 43;

                              if (!_didIteratorError) {
                                _context3.next = 46;
                                break;
                              }

                              throw _iteratorError;

                            case 46:
                              return _context3.finish(43);

                            case 47:
                              return _context3.finish(40);

                            case 48:
                              _context3.next = 69;
                              break;

                            case 50:
                              _iteratorNormalCompletion3 = true;
                              _didIteratorError3 = false;
                              _iteratorError3 = undefined;
                              _context3.prev = 53;

                              for (_iterator3 = extensions[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                                _extension = _step3.value;
                                glob.push("**/*.".concat(_extension));
                              }

                              _context3.next = 61;
                              break;

                            case 57:
                              _context3.prev = 57;
                              _context3.t2 = _context3["catch"](53);
                              _didIteratorError3 = true;
                              _iteratorError3 = _context3.t2;

                            case 61:
                              _context3.prev = 61;
                              _context3.prev = 62;

                              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                                _iterator3["return"]();
                              }

                            case 64:
                              _context3.prev = 64;

                              if (!_didIteratorError3) {
                                _context3.next = 67;
                                break;
                              }

                              throw _iteratorError3;

                            case 67:
                              return _context3.finish(64);

                            case 68:
                              return _context3.finish(61);

                            case 69:
                              relativeRoot = fastPath().relative(rootDir, root);
                              query = clocks.has(relativeRoot) // Use the `since` generator if we have a clock available
                              ? {
                                expression: expression,
                                fields: fields,
                                since: clocks.get(relativeRoot)
                              } // Otherwise use the `glob` filter
                              : {
                                expression: expression,
                                fields: fields,
                                glob: glob,
                                glob_includedotfiles: true
                              };
                              _context3.next = 73;
                              return regeneratorRuntime.awrap(cmd('query', root, query));

                            case 73:
                              response = _context3.sent;

                              if ('warning' in response) {
                                console.warn('watchman warning: ', response.warning);
                              }

                              isFresh = isFresh || response.is_fresh_instance;
                              files.set(root, response);

                            case 77:
                            case "end":
                              return _context3.stop();
                          }
                        }
                      }, null, null, [[8, 36, 40, 48], [15, 19, 23, 31], [24,, 26, 30], [41,, 43, 47], [53, 57, 61, 69], [62,, 64, 68]]);
                    })));

                  case 4:
                    return _context4.abrupt("return", {
                      files: files,
                      isFresh: isFresh
                    });

                  case 5:
                  case "end":
                    return _context4.stop();
                }
              }
            });
          };

          getWatchmanRoots = function _ref4(roots) {
            var watchmanRoots;
            return regeneratorRuntime.async(function getWatchmanRoots$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    watchmanRoots = new Map();
                    _context2.next = 3;
                    return regeneratorRuntime.awrap(Promise.all(roots.map(function _callee(root) {
                      var response, existing, canBeFiltered;
                      return regeneratorRuntime.async(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              _context.next = 2;
                              return regeneratorRuntime.awrap(cmd('watch-project', root));

                            case 2:
                              response = _context.sent;
                              existing = watchmanRoots.get(response.watch); // A root can only be filtered if it was never seen with a
                              // relative_path before.

                              canBeFiltered = !existing || existing.length > 0;

                              if (canBeFiltered) {
                                if (response.relative_path) {
                                  watchmanRoots.set(response.watch, (existing || []).concat(response.relative_path));
                                } else {
                                  // Make the filter directories an empty array to signal that this
                                  // root was already seen and needs to be watched for all files or
                                  // directories.
                                  watchmanRoots.set(response.watch, []);
                                }
                              }

                            case 6:
                            case "end":
                              return _context.stop();
                          }
                        }
                      });
                    })));

                  case 3:
                    return _context2.abrupt("return", watchmanRoots);

                  case 4:
                  case "end":
                    return _context2.stop();
                }
              }
            });
          };

          fields = ['name', 'exists', 'mtime_ms', 'size'];
          data = options.data, extensions = options.extensions, ignore = options.ignore, rootDir = options.rootDir, roots = options.roots;
          defaultWatchExpression = ['allof', ['type', 'f'], ['anyof'].concat(_toConsumableArray(extensions.map(function (extension) {
            return ['suffix', extension];
          })))];
          clocks = data.clocks;
          client = new (_fbWatchman()["default"].Client)();
          client.on('error', function (error) {
            return clientError = WatchmanError(error);
          }); // TODO: type better than `any`

          cmd = function cmd() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            return new Promise(function (resolve, reject) {
              return client.command(args, function (error, result) {
                return error ? reject(WatchmanError(error)) : resolve(result);
              });
            });
          };

          if (!options.computeSha1) {
            _context5.next = 15;
            break;
          }

          _context5.next = 12;
          return regeneratorRuntime.awrap(cmd('list-capabilities'));

        case 12:
          _ref = _context5.sent;
          capabilities = _ref.capabilities;

          if (capabilities.indexOf('field-content.sha1hex') !== -1) {
            fields.push('content.sha1hex');
          }

        case 15:
          files = data.files;
          removedFiles = new Map();
          changedFiles = new Map();
          isFresh = false;
          _context5.prev = 19;
          _context5.next = 22;
          return regeneratorRuntime.awrap(getWatchmanRoots(roots));

        case 22:
          watchmanRoots = _context5.sent;
          _context5.next = 25;
          return regeneratorRuntime.awrap(queryWatchmanForDirs(watchmanRoots));

        case 25:
          watchmanFileResults = _context5.sent;

          // Reset the file map if watchman was restarted and sends us a list of
          // files.
          if (watchmanFileResults.isFresh) {
            files = new Map();
            removedFiles = new Map(data.files);
            isFresh = true;
          }

          watchmanFiles = watchmanFileResults.files;

        case 28:
          _context5.prev = 28;
          client.end();
          return _context5.finish(28);

        case 31:
          if (!clientError) {
            _context5.next = 33;
            break;
          }

          throw clientError;

        case 33:
          // TODO: remove non-null
          _iteratorNormalCompletion4 = true;
          _didIteratorError4 = false;
          _iteratorError4 = undefined;
          _context5.prev = 36;
          _iterator4 = watchmanFiles[Symbol.iterator]();

        case 38:
          if (_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done) {
            _context5.next = 65;
            break;
          }

          _step4$value = _slicedToArray(_step4.value, 2), watchRoot = _step4$value[0], response = _step4$value[1];
          fsRoot = (0, _normalizePathSep()["default"])(watchRoot);
          relativeFsRoot = fastPath().relative(rootDir, fsRoot);
          clocks.set(relativeFsRoot, response.clock);
          _iteratorNormalCompletion5 = true;
          _didIteratorError5 = false;
          _iteratorError5 = undefined;
          _context5.prev = 46;

          for (_iterator5 = response.files[Symbol.iterator](); !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            fileData = _step5.value;
            filePath = fsRoot + path().sep + (0, _normalizePathSep()["default"])(fileData.name);
            relativeFilePath = fastPath().relative(rootDir, filePath);
            existingFileData = data.files.get(relativeFilePath); // If watchman is fresh, the removed files map starts with all files
            // and we remove them as we verify they still exist.

            if (isFresh && existingFileData && fileData.exists) {
              removedFiles["delete"](relativeFilePath);
            }

            if (!fileData.exists) {
              // No need to act on files that do not exist and were not tracked.
              if (existingFileData) {
                files["delete"](relativeFilePath); // If watchman is not fresh, we will know what specific files were
                // deleted since we last ran and can track only those files.

                if (!isFresh) {
                  removedFiles.set(relativeFilePath, existingFileData);
                }
              }
            } else if (!ignore(filePath)) {
              mtime = typeof fileData.mtime_ms === 'number' ? fileData.mtime_ms : fileData.mtime_ms.toNumber();
              size = fileData.size;
              sha1hex = fileData['content.sha1hex'];

              if (typeof sha1hex !== 'string' || sha1hex.length !== 40) {
                sha1hex = null;
              }

              nextData = void 0;

              if (existingFileData && existingFileData[_constants()["default"].MTIME] === mtime) {
                nextData = existingFileData;
              } else if (existingFileData && sha1hex && existingFileData[_constants()["default"].SHA1] === sha1hex) {
                nextData = [existingFileData[0], mtime, existingFileData[2], existingFileData[3], existingFileData[4], existingFileData[5]];
              } else {
                // See ../constants.ts
                nextData = ['', mtime, size, 0, '', sha1hex];
              }

              files.set(relativeFilePath, nextData);
              changedFiles.set(relativeFilePath, nextData);
            }
          }

          _context5.next = 54;
          break;

        case 50:
          _context5.prev = 50;
          _context5.t0 = _context5["catch"](46);
          _didIteratorError5 = true;
          _iteratorError5 = _context5.t0;

        case 54:
          _context5.prev = 54;
          _context5.prev = 55;

          if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
            _iterator5["return"]();
          }

        case 57:
          _context5.prev = 57;

          if (!_didIteratorError5) {
            _context5.next = 60;
            break;
          }

          throw _iteratorError5;

        case 60:
          return _context5.finish(57);

        case 61:
          return _context5.finish(54);

        case 62:
          _iteratorNormalCompletion4 = true;
          _context5.next = 38;
          break;

        case 65:
          _context5.next = 71;
          break;

        case 67:
          _context5.prev = 67;
          _context5.t1 = _context5["catch"](36);
          _didIteratorError4 = true;
          _iteratorError4 = _context5.t1;

        case 71:
          _context5.prev = 71;
          _context5.prev = 72;

          if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
            _iterator4["return"]();
          }

        case 74:
          _context5.prev = 74;

          if (!_didIteratorError4) {
            _context5.next = 77;
            break;
          }

          throw _iteratorError4;

        case 77:
          return _context5.finish(74);

        case 78:
          return _context5.finish(71);

        case 79:
          data.files = files;
          return _context5.abrupt("return", {
            changedFiles: isFresh ? undefined : changedFiles,
            hasteMap: data,
            removedFiles: removedFiles
          });

        case 81:
        case "end":
          return _context5.stop();
      }
    }
  }, null, null, [[19,, 28, 31], [36, 67, 71, 79], [46, 50, 54, 62], [55,, 57, 61], [72,, 74, 78]]);
};