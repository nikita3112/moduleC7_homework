'use strict';

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _child_process() {
  var data = require('child_process');

  _child_process = function _child_process() {
    return data;
  };

  return data;
}

function _crypto() {
  var data = require('crypto');

  _crypto = function _crypto() {
    return data;
  };

  return data;
}

function _events() {
  var data = require('events');

  _events = function _events() {
    return data;
  };

  return data;
}

function _os() {
  var data = require('os');

  _os = function _os() {
    return data;
  };

  return data;
}

function path() {
  var data = _interopRequireWildcard(require('path'));

  path = function path() {
    return data;
  };

  return data;
}

function _sane() {
  var data = require('sane');

  _sane = function _sane() {
    return data;
  };

  return data;
}

function _jestRegexUtil() {
  var data = require('jest-regex-util');

  _jestRegexUtil = function _jestRegexUtil() {
    return data;
  };

  return data;
}

function _jestSerializer() {
  var data = _interopRequireDefault(require('jest-serializer'));

  _jestSerializer = function _jestSerializer() {
    return data;
  };

  return data;
}

function _jestWorker() {
  var data = _interopRequireDefault(require('jest-worker'));

  _jestWorker = function _jestWorker() {
    return data;
  };

  return data;
}

var _HasteFS = _interopRequireDefault(require('./HasteFS'));

var _ModuleMap = _interopRequireDefault(require('./ModuleMap'));

var _constants = _interopRequireDefault(require('./constants'));

var _node = _interopRequireDefault(require('./crawlers/node'));

var _watchman = _interopRequireDefault(require('./crawlers/watchman'));

var _getMockName = _interopRequireDefault(require('./getMockName'));

var _FSEventsWatcher = _interopRequireDefault(require('./lib/FSEventsWatcher'));

var _WatchmanWatcher = _interopRequireDefault(require('./lib/WatchmanWatcher'));

var fastPath = _interopRequireWildcard(require('./lib/fast_path'));

var _getPlatformExtension = _interopRequireDefault(require('./lib/getPlatformExtension'));

var _normalizePathSep = _interopRequireDefault(require('./lib/normalizePathSep'));

var _worker = require('./worker');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== 'function') return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
} // TypeScript doesn't like us importing from outside `rootDir`, but it doesn't
// understand `require`.


var _require = require('../package.json'),
    VERSION = _require.version;

var CHANGE_INTERVAL = 30;
var MAX_WAIT_TIME = 240000;
var NODE_MODULES = path().sep + 'node_modules' + path().sep;
var PACKAGE_JSON = path().sep + 'package.json';
var VCS_DIRECTORIES = ['.git', '.hg'].map(function (vcs) {
  return (0, _jestRegexUtil().escapePathForRegex)(path().sep + vcs + path().sep);
}).join('|');

var canUseWatchman = function () {
  try {
    (0, _child_process().execSync)('watchman --version', {
      stdio: ['ignore']
    });
    return true;
  } catch (_unused) {}

  return false;
}();

function invariant(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
/**
 * HasteMap is a JavaScript implementation of Facebook's haste module system.
 *
 * This implementation is inspired by https://github.com/facebook/node-haste
 * and was built with for high-performance in large code repositories with
 * hundreds of thousands of files. This implementation is scalable and provides
 * predictable performance.
 *
 * Because the haste map creation and synchronization is critical to startup
 * performance and most tasks are blocked by I/O this class makes heavy use of
 * synchronous operations. It uses worker processes for parallelizing file
 * access and metadata extraction.
 *
 * The data structures created by `jest-haste-map` can be used directly from the
 * cache without further processing. The metadata objects in the `files` and
 * `map` objects contain cross-references: a metadata object from one can look
 * up the corresponding metadata object in the other map. Note that in most
 * projects, the number of files will be greater than the number of haste
 * modules one module can refer to many files based on platform extensions.
 *
 * type HasteMap = {
 *   clocks: WatchmanClocks,
 *   files: {[filepath: string]: FileMetaData},
 *   map: {[id: string]: ModuleMapItem},
 *   mocks: {[id: string]: string},
 * }
 *
 * // Watchman clocks are used for query synchronization and file system deltas.
 * type WatchmanClocks = {[filepath: string]: string};
 *
 * type FileMetaData = {
 *   id: ?string, // used to look up module metadata objects in `map`.
 *   mtime: number, // check for outdated files.
 *   size: number, // size of the file in bytes.
 *   visited: boolean, // whether the file has been parsed or not.
 *   dependencies: Array<string>, // all relative dependencies of this file.
 *   sha1: ?string, // SHA-1 of the file, if requested via options.
 * };
 *
 * // Modules can be targeted to a specific platform based on the file name.
 * // Example: platform.ios.js and Platform.android.js will both map to the same
 * // `Platform` module. The platform should be specified during resolution.
 * type ModuleMapItem = {[platform: string]: ModuleMetaData};
 *
 * //
 * type ModuleMetaData = {
 *   path: string, // the path to look up the file object in `files`.
 *   type: string, // the module type (either `package` or `module`).
 * };
 *
 * Note that the data structures described above are conceptual only. The actual
 * implementation uses arrays and constant keys for metadata storage. Instead of
 * `{id: 'flatMap', mtime: 3421, size: 42, visited: true, dependencies: []}` the real
 * representation is similar to `['flatMap', 3421, 42, 1, []]` to save storage space
 * and reduce parse and write time of a big JSON blob.
 *
 * The HasteMap is created as follows:
 *  1. read data from the cache or create an empty structure.
 *
 *  2. crawl the file system.
 *     * empty cache: crawl the entire file system.
 *     * cache available:
 *       * if watchman is available: get file system delta changes.
 *       * if watchman is unavailable: crawl the entire file system.
 *     * build metadata objects for every file. This builds the `files` part of
 *       the `HasteMap`.
 *
 *  3. parse and extract metadata from changed files.
 *     * this is done in parallel over worker processes to improve performance.
 *     * the worst case is to parse all files.
 *     * the best case is no file system access and retrieving all data from
 *       the cache.
 *     * the average case is a small number of changed files.
 *
 *  4. serialize the new `HasteMap` in a cache file.
 *     Worker processes can directly access the cache through `HasteMap.read()`.
 *
 */


var HasteMap =
/*#__PURE__*/
function (_events$EventEmitter) {
  _inherits(HasteMap, _events$EventEmitter);

  function HasteMap(options) {
    var _this;

    _classCallCheck(this, HasteMap);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(HasteMap).call(this));

    _defineProperty(_assertThisInitialized(_this), '_buildPromise', void 0);

    _defineProperty(_assertThisInitialized(_this), '_cachePath', void 0);

    _defineProperty(_assertThisInitialized(_this), '_changeInterval', void 0);

    _defineProperty(_assertThisInitialized(_this), '_console', void 0);

    _defineProperty(_assertThisInitialized(_this), '_options', void 0);

    _defineProperty(_assertThisInitialized(_this), '_watchers', void 0);

    _defineProperty(_assertThisInitialized(_this), '_worker', void 0);

    _this._options = {
      cacheDirectory: options.cacheDirectory || (0, _os().tmpdir)(),
      computeDependencies: options.computeDependencies === undefined ? true : options.computeDependencies,
      computeSha1: options.computeSha1 || false,
      dependencyExtractor: options.dependencyExtractor || null,
      extensions: options.extensions,
      forceNodeFilesystemAPI: !!options.forceNodeFilesystemAPI,
      hasteImplModulePath: options.hasteImplModulePath,
      maxWorkers: options.maxWorkers,
      mocksPattern: options.mocksPattern ? new RegExp(options.mocksPattern) : null,
      name: options.name,
      platforms: options.platforms,
      resetCache: options.resetCache,
      retainAllFiles: options.retainAllFiles,
      rootDir: options.rootDir,
      roots: Array.from(new Set(options.roots)),
      skipPackageJson: !!options.skipPackageJson,
      throwOnModuleCollision: !!options.throwOnModuleCollision,
      useWatchman: options.useWatchman == null ? true : options.useWatchman,
      watch: !!options.watch
    };
    _this._console = options.console || global.console;

    if (options.ignorePattern) {
      if (options.ignorePattern instanceof RegExp) {
        _this._options.ignorePattern = new RegExp(options.ignorePattern.source.concat('|' + VCS_DIRECTORIES), options.ignorePattern.flags);
      } else {
        var ignorePattern = options.ignorePattern;
        var vcsIgnoreRegExp = new RegExp(VCS_DIRECTORIES);

        _this._options.ignorePattern = function (filePath) {
          return vcsIgnoreRegExp.test(filePath) || ignorePattern(filePath);
        };

        _this._console.warn('jest-haste-map: the `ignorePattern` options as a function is being ' + 'deprecated. Provide a RegExp instead. See https://github.com/facebook/jest/pull/4063.');
      }
    } else {
      _this._options.ignorePattern = new RegExp(VCS_DIRECTORIES);
    }

    var rootDirHash = (0, _crypto().createHash)('md5').update(options.rootDir).digest('hex');
    var hasteImplHash = '';
    var dependencyExtractorHash = '';

    if (options.hasteImplModulePath) {
      var hasteImpl = require(options.hasteImplModulePath);

      if (hasteImpl.getCacheKey) {
        hasteImplHash = String(hasteImpl.getCacheKey());
      }
    }

    if (options.dependencyExtractor) {
      var dependencyExtractor = require(options.dependencyExtractor);

      if (dependencyExtractor.getCacheKey) {
        dependencyExtractorHash = String(dependencyExtractor.getCacheKey());
      }
    }

    _this._cachePath = HasteMap.getCacheFilePath(_this._options.cacheDirectory, "haste-map-".concat(_this._options.name, "-").concat(rootDirHash), VERSION, _this._options.name, _this._options.roots.map(function (root) {
      return fastPath.relative(options.rootDir, root);
    }).join(':'), _this._options.extensions.join(':'), _this._options.platforms.join(':'), _this._options.computeSha1.toString(), options.mocksPattern || '', (options.ignorePattern || '').toString(), hasteImplHash, dependencyExtractorHash);
    _this._buildPromise = null;
    _this._watchers = [];
    _this._worker = null;
    return _this;
  }

  _createClass(HasteMap, [{
    key: "getCacheFilePath",
    value: function getCacheFilePath() {
      return this._cachePath;
    }
  }, {
    key: "build",
    value: function build() {
      var _this2 = this;

      if (!this._buildPromise) {
        this._buildPromise = function _callee() {
          var data, hasteMap, rootDir, hasteFS, moduleMap, __hasteMapForTest;

          return regeneratorRuntime.async(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return regeneratorRuntime.awrap(_this2._buildFileMap());

                case 2:
                  data = _context.sent;

                  if (!(data.changedFiles === undefined || data.changedFiles.size > 0 || data.removedFiles.size > 0)) {
                    _context.next = 10;
                    break;
                  }

                  _context.next = 6;
                  return regeneratorRuntime.awrap(_this2._buildHasteMap(data));

                case 6:
                  hasteMap = _context.sent;

                  _this2._persist(hasteMap);

                  _context.next = 11;
                  break;

                case 10:
                  hasteMap = data.hasteMap;

                case 11:
                  rootDir = _this2._options.rootDir;
                  hasteFS = new _HasteFS["default"]({
                    files: hasteMap.files,
                    rootDir: rootDir
                  });
                  moduleMap = new _ModuleMap["default"]({
                    duplicates: hasteMap.duplicates,
                    map: hasteMap.map,
                    mocks: hasteMap.mocks,
                    rootDir: rootDir
                  });
                  __hasteMapForTest = process.env.NODE_ENV === 'test' && hasteMap || null;
                  _context.next = 17;
                  return regeneratorRuntime.awrap(_this2._watch(hasteMap));

                case 17:
                  return _context.abrupt("return", {
                    __hasteMapForTest: __hasteMapForTest,
                    hasteFS: hasteFS,
                    moduleMap: moduleMap
                  });

                case 18:
                case "end":
                  return _context.stop();
              }
            }
          });
        }();
      }

      return this._buildPromise;
    }
    /**
     * 1. read data from the cache or create an empty structure.
     */

  }, {
    key: "read",
    value: function read() {
      var hasteMap;

      try {
        hasteMap = _jestSerializer()["default"].readFileSync(this._cachePath);
      } catch (_unused2) {
        hasteMap = this._createEmptyMap();
      }

      return hasteMap;
    }
  }, {
    key: "readModuleMap",
    value: function readModuleMap() {
      var data = this.read();
      return new _ModuleMap["default"]({
        duplicates: data.duplicates,
        map: data.map,
        mocks: data.mocks,
        rootDir: this._options.rootDir
      });
    }
    /**
     * 2. crawl the file system.
     */

  }, {
    key: "_buildFileMap",
    value: function _buildFileMap() {
      var hasteMap, read;
      return regeneratorRuntime.async(function _buildFileMap$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              read = this._options.resetCache ? this._createEmptyMap : this.read;
              _context2.next = 4;
              return regeneratorRuntime.awrap(read.call(this));

            case 4:
              hasteMap = _context2.sent;
              _context2.next = 10;
              break;

            case 7:
              _context2.prev = 7;
              _context2.t0 = _context2["catch"](0);
              hasteMap = this._createEmptyMap();

            case 10:
              return _context2.abrupt("return", this._crawl(hasteMap));

            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this, [[0, 7]]);
    }
    /**
     * 3. parse and extract metadata from changed files.
     */

  }, {
    key: "_processFile",
    value: function _processFile(hasteMap, map, mocks, filePath, workerOptions) {
      var _this3 = this;

      var rootDir = this._options.rootDir;

      var setModule = function setModule(id, module) {
        var moduleMap = map.get(id);

        if (!moduleMap) {
          moduleMap = Object.create(null);
          map.set(id, moduleMap);
        }

        var platform = (0, _getPlatformExtension["default"])(module[_constants["default"].PATH], _this3._options.platforms) || _constants["default"].GENERIC_PLATFORM;

        var existingModule = moduleMap[platform];

        if (existingModule && existingModule[_constants["default"].PATH] !== module[_constants["default"].PATH]) {
          var method = _this3._options.throwOnModuleCollision ? 'error' : 'warn';

          _this3._console[method](['jest-haste-map: Haste module naming collision: ' + id, '  The following files share their name; please adjust your hasteImpl:', '    * <rootDir>' + path().sep + existingModule[_constants["default"].PATH], '    * <rootDir>' + path().sep + module[_constants["default"].PATH], ''].join('\n'));

          if (_this3._options.throwOnModuleCollision) {
            throw new DuplicateError(existingModule[_constants["default"].PATH], module[_constants["default"].PATH]);
          } // We do NOT want consumers to use a module that is ambiguous.


          delete moduleMap[platform];

          if (Object.keys(moduleMap).length === 1) {
            map["delete"](id);
          }

          var _dupsByPlatform = hasteMap.duplicates.get(id);

          if (_dupsByPlatform == null) {
            _dupsByPlatform = new Map();
            hasteMap.duplicates.set(id, _dupsByPlatform);
          }

          var dups = new Map([[module[_constants["default"].PATH], module[_constants["default"].TYPE]], [existingModule[_constants["default"].PATH], existingModule[_constants["default"].TYPE]]]);

          _dupsByPlatform.set(platform, dups);

          return;
        }

        var dupsByPlatform = hasteMap.duplicates.get(id);

        if (dupsByPlatform != null) {
          var _dups = dupsByPlatform.get(platform);

          if (_dups != null) {
            _dups.set(module[_constants["default"].PATH], module[_constants["default"].TYPE]);
          }

          return;
        }

        moduleMap[platform] = module;
      };

      var relativeFilePath = fastPath.relative(rootDir, filePath);
      var fileMetadata = hasteMap.files.get(relativeFilePath);

      if (!fileMetadata) {
        throw new Error('jest-haste-map: File to process was not found in the haste map.');
      }

      var moduleMetadata = hasteMap.map.get(fileMetadata[_constants["default"].ID]);
      var computeSha1 = this._options.computeSha1 && !fileMetadata[_constants["default"].SHA1]; // Callback called when the response from the worker is successful.

      var workerReply = function workerReply(metadata) {
        // `1` for truthy values instead of `true` to save cache space.
        fileMetadata[_constants["default"].VISITED] = 1;
        var metadataId = metadata.id;
        var metadataModule = metadata.module;

        if (metadataId && metadataModule) {
          fileMetadata[_constants["default"].ID] = metadataId;
          setModule(metadataId, metadataModule);
        }

        fileMetadata[_constants["default"].DEPENDENCIES] = metadata.dependencies ? metadata.dependencies.join(_constants["default"].DEPENDENCY_DELIM) : '';

        if (computeSha1) {
          fileMetadata[_constants["default"].SHA1] = metadata.sha1;
        }
      }; // Callback called when the response from the worker is an error.


      var workerError = function workerError(error) {
        if (_typeof(error) !== 'object' || !error.message || !error.stack) {
          error = new Error(error);
          error.stack = ''; // Remove stack for stack-less errors.
        }

        if (!['ENOENT', 'EACCES'].includes(error.code)) {
          throw error;
        } // If a file cannot be read we remove it from the file list and
        // ignore the failure silently.


        hasteMap.files["delete"](relativeFilePath);
      }; // If we retain all files in the virtual HasteFS representation, we avoid
      // reading them if they aren't important (node_modules).


      if (this._options.retainAllFiles && filePath.includes(NODE_MODULES)) {
        if (computeSha1) {
          return this._getWorker(workerOptions).getSha1({
            computeDependencies: this._options.computeDependencies,
            computeSha1: computeSha1,
            dependencyExtractor: this._options.dependencyExtractor,
            filePath: filePath,
            hasteImplModulePath: this._options.hasteImplModulePath,
            rootDir: rootDir
          }).then(workerReply, workerError);
        }

        return null;
      }

      if (this._options.mocksPattern && this._options.mocksPattern.test(filePath)) {
        var mockPath = (0, _getMockName["default"])(filePath);
        var existingMockPath = mocks.get(mockPath);

        if (existingMockPath) {
          var secondMockPath = fastPath.relative(rootDir, filePath);

          if (existingMockPath !== secondMockPath) {
            var method = this._options.throwOnModuleCollision ? 'error' : 'warn';

            this._console[method](['jest-haste-map: duplicate manual mock found: ' + mockPath, '  The following files share their name; please delete one of them:', '    * <rootDir>' + path().sep + existingMockPath, '    * <rootDir>' + path().sep + secondMockPath, ''].join('\n'));

            if (this._options.throwOnModuleCollision) {
              throw new DuplicateError(existingMockPath, secondMockPath);
            }
          }
        }

        mocks.set(mockPath, relativeFilePath);
      }

      if (fileMetadata[_constants["default"].VISITED]) {
        if (!fileMetadata[_constants["default"].ID]) {
          return null;
        }

        if (moduleMetadata != null) {
          var platform = (0, _getPlatformExtension["default"])(filePath, this._options.platforms) || _constants["default"].GENERIC_PLATFORM;

          var _module = moduleMetadata[platform];

          if (_module == null) {
            return null;
          }

          var moduleId = fileMetadata[_constants["default"].ID];
          var modulesByPlatform = map.get(moduleId);

          if (!modulesByPlatform) {
            modulesByPlatform = Object.create(null);
            map.set(moduleId, modulesByPlatform);
          }

          modulesByPlatform[platform] = _module;
          return null;
        }
      }

      return this._getWorker(workerOptions).worker({
        computeDependencies: this._options.computeDependencies,
        computeSha1: computeSha1,
        dependencyExtractor: this._options.dependencyExtractor,
        filePath: filePath,
        hasteImplModulePath: this._options.hasteImplModulePath,
        rootDir: rootDir
      }).then(workerReply, workerError);
    }
  }, {
    key: "_buildHasteMap",
    value: function _buildHasteMap(data) {
      var _this4 = this;

      var removedFiles = data.removedFiles,
          changedFiles = data.changedFiles,
          hasteMap = data.hasteMap; // If any files were removed or we did not track what files changed, process
      // every file looking for changes. Otherwise, process only changed files.

      var map;
      var mocks;
      var filesToProcess;

      if (changedFiles === undefined || removedFiles.size) {
        map = new Map();
        mocks = new Map();
        filesToProcess = hasteMap.files;
      } else {
        map = hasteMap.map;
        mocks = hasteMap.mocks;
        filesToProcess = changedFiles;
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = removedFiles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _slicedToArray(_step.value, 2),
              relativeFilePath = _step$value[0],
              fileMetadata = _step$value[1];

          this._recoverDuplicates(hasteMap, relativeFilePath, fileMetadata[_constants["default"].ID]);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      var promises = [];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = filesToProcess.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _relativeFilePath = _step2.value;

          if (this._options.skipPackageJson && _relativeFilePath.endsWith(PACKAGE_JSON)) {
            continue;
          } // SHA-1, if requested, should already be present thanks to the crawler.


          var filePath = fastPath.resolve(this._options.rootDir, _relativeFilePath);

          var promise = this._processFile(hasteMap, map, mocks, filePath);

          if (promise) {
            promises.push(promise);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return Promise.all(promises).then(function () {
        _this4._cleanup();

        hasteMap.map = map;
        hasteMap.mocks = mocks;
        return hasteMap;
      }, function (error) {
        _this4._cleanup();

        throw error;
      });
    }
  }, {
    key: "_cleanup",
    value: function _cleanup() {
      var worker = this._worker; // @ts-expect-error

      if (worker && typeof worker.end === 'function') {
        // @ts-expect-error
        worker.end();
      }

      this._worker = null;
    }
    /**
     * 4. serialize the new `HasteMap` in a cache file.
     */

  }, {
    key: "_persist",
    value: function _persist(hasteMap) {
      _jestSerializer()["default"].writeFileSync(this._cachePath, hasteMap);
    }
    /**
     * Creates workers or parses files and extracts metadata in-process.
     */

  }, {
    key: "_getWorker",
    value: function _getWorker(options) {
      if (!this._worker) {
        if (options && options.forceInBand || this._options.maxWorkers <= 1) {
          this._worker = {
            getSha1: _worker.getSha1,
            worker: _worker.worker
          };
        } else {
          // @ts-expect-error: assignment of a worker with custom properties.
          this._worker = new (_jestWorker()["default"])(require.resolve('./worker'), {
            exposedMethods: ['getSha1', 'worker'],
            maxRetries: 3,
            numWorkers: this._options.maxWorkers
          });
        }
      }

      return this._worker;
    }
  }, {
    key: "_crawl",
    value: function _crawl(hasteMap) {
      var _this5 = this;

      var options = this._options;

      var ignore = this._ignore.bind(this);

      var crawl = canUseWatchman && this._options.useWatchman ? _watchman["default"] : _node["default"];
      var crawlerOptions = {
        computeSha1: options.computeSha1,
        data: hasteMap,
        extensions: options.extensions,
        forceNodeFilesystemAPI: options.forceNodeFilesystemAPI,
        ignore: ignore,
        rootDir: options.rootDir,
        roots: options.roots
      };

      var retry = function retry(error) {
        if (crawl === _watchman["default"]) {
          _this5._console.warn("jest-haste-map: Watchman crawl failed. Retrying once with node " + "crawler.\n" + "  Usually this happens when watchman isn't running. Create an " + "empty `.watchmanconfig` file in your project's root folder or " + "initialize a git or hg repository in your project.\n" + "  " + error);

          return (0, _node["default"])(crawlerOptions)["catch"](function (e) {
            throw new Error("Crawler retry failed:\n" + "  Original error: ".concat(error.message, "\n") + "  Retry error: ".concat(e.message, "\n"));
          });
        }

        throw error;
      };

      try {
        return crawl(crawlerOptions)["catch"](retry);
      } catch (error) {
        return retry(error);
      }
    }
    /**
     * Watch mode
     */

  }, {
    key: "_watch",
    value: function _watch(hasteMap) {
      var _this6 = this;

      if (!this._options.watch) {
        return Promise.resolve();
      } // In watch mode, we'll only warn about module collisions and we'll retain
      // all files, even changes to node_modules.


      this._options.throwOnModuleCollision = false;
      this._options.retainAllFiles = true; // WatchmanWatcher > FSEventsWatcher > sane.NodeWatcher

      var Watcher = canUseWatchman && this._options.useWatchman ? _WatchmanWatcher["default"] : _FSEventsWatcher["default"].isSupported() ? _FSEventsWatcher["default"] : _sane().NodeWatcher;
      var extensions = this._options.extensions;
      var ignorePattern = this._options.ignorePattern;
      var rootDir = this._options.rootDir;
      var changeQueue = Promise.resolve();
      var eventsQueue = []; // We only need to copy the entire haste map once on every "frame".

      var mustCopy = true;

      var createWatcher = function createWatcher(root) {
        // @ts-expect-error: TODO how? "Cannot use 'new' with an expression whose type lacks a call or construct signature."
        var watcher = new Watcher(root, {
          dot: true,
          glob: extensions.map(function (extension) {
            return '**/*.' + extension;
          }),
          ignored: ignorePattern
        });
        return new Promise(function (resolve, reject) {
          var rejectTimeout = setTimeout(function () {
            return reject(new Error('Failed to start watch mode.'));
          }, MAX_WAIT_TIME);
          watcher.once('ready', function () {
            clearTimeout(rejectTimeout);
            watcher.on('all', onChange);
            resolve(watcher);
          });
        });
      };

      var emitChange = function emitChange() {
        if (eventsQueue.length) {
          mustCopy = true;
          var changeEvent = {
            eventsQueue: eventsQueue,
            hasteFS: new _HasteFS["default"]({
              files: hasteMap.files,
              rootDir: rootDir
            }),
            moduleMap: new _ModuleMap["default"]({
              duplicates: hasteMap.duplicates,
              map: hasteMap.map,
              mocks: hasteMap.mocks,
              rootDir: rootDir
            })
          };

          _this6.emit('change', changeEvent);

          eventsQueue = [];
        }
      };

      var onChange = function onChange(type, filePath, root, stat) {
        filePath = path().join(root, (0, _normalizePathSep["default"])(filePath));

        if (stat && stat.isDirectory() || _this6._ignore(filePath) || !extensions.some(function (extension) {
          return filePath.endsWith(extension);
        })) {
          return;
        }

        var relativeFilePath = fastPath.relative(rootDir, filePath);
        var fileMetadata = hasteMap.files.get(relativeFilePath); // The file has been accessed, not modified

        if (type === 'change' && fileMetadata && stat && fileMetadata[_constants["default"].MTIME] === stat.mtime.getTime()) {
          return;
        }

        changeQueue = changeQueue.then(function () {
          // If we get duplicate events for the same file, ignore them.
          if (eventsQueue.find(function (event) {
            return event.type === type && event.filePath === filePath && (!event.stat && !stat || !!event.stat && !!stat && event.stat.mtime.getTime() === stat.mtime.getTime());
          })) {
            return null;
          }

          if (mustCopy) {
            mustCopy = false;
            hasteMap = {
              clocks: new Map(hasteMap.clocks),
              duplicates: new Map(hasteMap.duplicates),
              files: new Map(hasteMap.files),
              map: new Map(hasteMap.map),
              mocks: new Map(hasteMap.mocks)
            };
          }

          var add = function add() {
            eventsQueue.push({
              filePath: filePath,
              stat: stat,
              type: type
            });
            return null;
          };

          var fileMetadata = hasteMap.files.get(relativeFilePath); // If it's not an addition, delete the file and all its metadata

          if (fileMetadata != null) {
            var moduleName = fileMetadata[_constants["default"].ID];

            var platform = (0, _getPlatformExtension["default"])(filePath, _this6._options.platforms) || _constants["default"].GENERIC_PLATFORM;

            hasteMap.files["delete"](relativeFilePath);
            var moduleMap = hasteMap.map.get(moduleName);

            if (moduleMap != null) {
              // We are forced to copy the object because jest-haste-map exposes
              // the map as an immutable entity.
              moduleMap = copy(moduleMap);
              delete moduleMap[platform];

              if (Object.keys(moduleMap).length === 0) {
                hasteMap.map["delete"](moduleName);
              } else {
                hasteMap.map.set(moduleName, moduleMap);
              }
            }

            if (_this6._options.mocksPattern && _this6._options.mocksPattern.test(filePath)) {
              var mockName = (0, _getMockName["default"])(filePath);
              hasteMap.mocks["delete"](mockName);
            }

            _this6._recoverDuplicates(hasteMap, relativeFilePath, moduleName);
          } // If the file was added or changed,
          // parse it and update the haste map.


          if (type === 'add' || type === 'change') {
            invariant(stat, 'since the file exists or changed, it should have stats');
            var _fileMetadata = ['', stat.mtime.getTime(), stat.size, 0, '', null];
            hasteMap.files.set(relativeFilePath, _fileMetadata);

            var promise = _this6._processFile(hasteMap, hasteMap.map, hasteMap.mocks, filePath, {
              forceInBand: true
            }); // Cleanup


            _this6._cleanup();

            if (promise) {
              return promise.then(add);
            } else {
              // If a file in node_modules has changed,
              // emit an event regardless.
              add();
            }
          } else {
            add();
          }

          return null;
        })["catch"](function (error) {
          _this6._console.error("jest-haste-map: watch error:\n  ".concat(error.stack, "\n"));
        });
      };

      this._changeInterval = setInterval(emitChange, CHANGE_INTERVAL);
      return Promise.all(this._options.roots.map(createWatcher)).then(function (watchers) {
        _this6._watchers = watchers;
      });
    }
    /**
     * This function should be called when the file under `filePath` is removed
     * or changed. When that happens, we want to figure out if that file was
     * part of a group of files that had the same ID. If it was, we want to
     * remove it from the group. Furthermore, if there is only one file
     * remaining in the group, then we want to restore that single file as the
     * correct resolution for its ID, and cleanup the duplicates index.
     */

  }, {
    key: "_recoverDuplicates",
    value: function _recoverDuplicates(hasteMap, relativeFilePath, moduleName) {
      var dupsByPlatform = hasteMap.duplicates.get(moduleName);

      if (dupsByPlatform == null) {
        return;
      }

      var platform = (0, _getPlatformExtension["default"])(relativeFilePath, this._options.platforms) || _constants["default"].GENERIC_PLATFORM;

      var dups = dupsByPlatform.get(platform);

      if (dups == null) {
        return;
      }

      dupsByPlatform = copyMap(dupsByPlatform);
      hasteMap.duplicates.set(moduleName, dupsByPlatform);
      dups = copyMap(dups);
      dupsByPlatform.set(platform, dups);
      dups["delete"](relativeFilePath);

      if (dups.size !== 1) {
        return;
      }

      var uniqueModule = dups.entries().next().value;

      if (!uniqueModule) {
        return;
      }

      var dedupMap = hasteMap.map.get(moduleName);

      if (dedupMap == null) {
        dedupMap = Object.create(null);
        hasteMap.map.set(moduleName, dedupMap);
      }

      dedupMap[platform] = uniqueModule;
      dupsByPlatform["delete"](platform);

      if (dupsByPlatform.size === 0) {
        hasteMap.duplicates["delete"](moduleName);
      }
    }
  }, {
    key: "end",
    value: function end() {
      var _this7 = this;

      // @ts-expect-error: TODO TS cannot decide if `setInterval` and `clearInterval` comes from NodeJS or the DOM
      clearInterval(this._changeInterval);

      if (!this._watchers.length) {
        return Promise.resolve();
      }

      return Promise.all(this._watchers.map(function (watcher) {
        return new Promise(function (resolve) {
          return watcher.close(resolve);
        });
      })).then(function () {
        _this7._watchers = [];
      });
    }
    /**
     * Helpers
     */

  }, {
    key: "_ignore",
    value: function _ignore(filePath) {
      var ignorePattern = this._options.ignorePattern;
      var ignoreMatched = ignorePattern instanceof RegExp ? ignorePattern.test(filePath) : ignorePattern && ignorePattern(filePath);
      return ignoreMatched || !this._options.retainAllFiles && filePath.includes(NODE_MODULES);
    }
  }, {
    key: "_createEmptyMap",
    value: function _createEmptyMap() {
      return {
        clocks: new Map(),
        duplicates: new Map(),
        files: new Map(),
        map: new Map(),
        mocks: new Map()
      };
    }
  }], [{
    key: "getCacheFilePath",
    value: function getCacheFilePath(tmpdir, name) {
      for (var _len = arguments.length, extra = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        extra[_key - 2] = arguments[_key];
      }

      var hash = (0, _crypto().createHash)('md5').update(extra.join(''));
      return path().join(tmpdir, name.replace(/\W/g, '-') + '-' + hash.digest('hex'));
    }
  }]);

  return HasteMap;
}(_events().EventEmitter);

_defineProperty(HasteMap, 'H', void 0);

_defineProperty(HasteMap, 'DuplicateError', void 0);

_defineProperty(HasteMap, 'ModuleMap', void 0);

var DuplicateError =
/*#__PURE__*/
function (_Error) {
  _inherits(DuplicateError, _Error);

  function DuplicateError(mockPath1, mockPath2) {
    var _this8;

    _classCallCheck(this, DuplicateError);

    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(DuplicateError).call(this, 'Duplicated files or mocks. Please check the console for more info'));

    _defineProperty(_assertThisInitialized(_this8), 'mockPath1', void 0);

    _defineProperty(_assertThisInitialized(_this8), 'mockPath2', void 0);

    _this8.mockPath1 = mockPath1;
    _this8.mockPath2 = mockPath2;
    return _this8;
  }

  return DuplicateError;
}(_wrapNativeSuper(Error));

function copy(object) {
  return Object.assign(Object.create(null), object);
}

function copyMap(input) {
  return new Map(input);
}

HasteMap.H = _constants["default"];
HasteMap.DuplicateError = DuplicateError;
HasteMap.ModuleMap = _ModuleMap["default"];
module.exports = HasteMap;