'use strict';

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

var _constants = _interopRequireDefault(require('./constants'));

var fastPath = _interopRequireWildcard(require('./lib/fast_path'));

function _getRequireWildcardCache() {
  if (typeof WeakMap !== 'function') return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var EMPTY_OBJ = {};
var EMPTY_MAP = new Map();

var ModuleMap =
/*#__PURE__*/
function () {
  _createClass(ModuleMap, null, [{
    key: "mapToArrayRecursive",
    value: function mapToArrayRecursive(map) {
      var _this = this;

      var arr = Array.from(map);

      if (arr[0] && arr[0][1] instanceof Map) {
        arr = arr.map(function (el) {
          return [el[0], _this.mapToArrayRecursive(el[1])];
        });
      }

      return arr;
    }
  }, {
    key: "mapFromArrayRecursive",
    value: function mapFromArrayRecursive(arr) {
      var _this2 = this;

      if (arr[0] && Array.isArray(arr[1])) {
        arr = arr.map(function (el) {
          return [el[0], _this2.mapFromArrayRecursive(el[1])];
        });
      }

      return new Map(arr);
    }
  }]);

  function ModuleMap(raw) {
    _classCallCheck(this, ModuleMap);

    _defineProperty(this, '_raw', void 0);

    _defineProperty(this, 'json', void 0);

    this._raw = raw;
  }

  _createClass(ModuleMap, [{
    key: "getModule",
    value: function getModule(name, platform, supportsNativePlatform, type) {
      if (type == null) {
        type = _constants["default"].MODULE;
      }

      var module = this._getModuleMetadata(name, platform, !!supportsNativePlatform);

      if (module && module[_constants["default"].TYPE] === type) {
        var modulePath = module[_constants["default"].PATH];
        return modulePath && fastPath.resolve(this._raw.rootDir, modulePath);
      }

      return null;
    }
  }, {
    key: "getPackage",
    value: function getPackage(name, platform, _supportsNativePlatform) {
      return this.getModule(name, platform, null, _constants["default"].PACKAGE);
    }
  }, {
    key: "getMockModule",
    value: function getMockModule(name) {
      var mockPath = this._raw.mocks.get(name) || this._raw.mocks.get(name + '/index');

      return mockPath && fastPath.resolve(this._raw.rootDir, mockPath);
    }
  }, {
    key: "getRawModuleMap",
    value: function getRawModuleMap() {
      return {
        duplicates: this._raw.duplicates,
        map: this._raw.map,
        mocks: this._raw.mocks,
        rootDir: this._raw.rootDir
      };
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      if (!this.json) {
        this.json = {
          duplicates: ModuleMap.mapToArrayRecursive(this._raw.duplicates),
          map: Array.from(this._raw.map),
          mocks: Array.from(this._raw.mocks),
          rootDir: this._raw.rootDir
        };
      }

      return this.json;
    }
  }, {
    key: "_getModuleMetadata",

    /**
     * When looking up a module's data, we walk through each eligible platform for
     * the query. For each platform, we want to check if there are known
     * duplicates for that name+platform pair. The duplication logic normally
     * removes elements from the `map` object, but we want to check upfront to be
     * extra sure. If metadata exists both in the `duplicates` object and the
     * `map`, this would be a bug.
     */
    value: function _getModuleMetadata(name, platform, supportsNativePlatform) {
      var map = this._raw.map.get(name) || EMPTY_OBJ;
      var dupMap = this._raw.duplicates.get(name) || EMPTY_MAP;

      if (platform != null) {
        this._assertNoDuplicates(name, platform, supportsNativePlatform, dupMap.get(platform));

        if (map[platform] != null) {
          return map[platform];
        }
      }

      if (supportsNativePlatform) {
        this._assertNoDuplicates(name, _constants["default"].NATIVE_PLATFORM, supportsNativePlatform, dupMap.get(_constants["default"].NATIVE_PLATFORM));

        if (map[_constants["default"].NATIVE_PLATFORM]) {
          return map[_constants["default"].NATIVE_PLATFORM];
        }
      }

      this._assertNoDuplicates(name, _constants["default"].GENERIC_PLATFORM, supportsNativePlatform, dupMap.get(_constants["default"].GENERIC_PLATFORM));

      if (map[_constants["default"].GENERIC_PLATFORM]) {
        return map[_constants["default"].GENERIC_PLATFORM];
      }

      return null;
    }
  }, {
    key: "_assertNoDuplicates",
    value: function _assertNoDuplicates(name, platform, supportsNativePlatform, relativePathSet) {
      if (relativePathSet == null) {
        return;
      } // Force flow refinement


      var previousSet = relativePathSet;
      var duplicates = new Map();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = previousSet[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _step$value = _slicedToArray(_step.value, 2),
              relativePath = _step$value[0],
              type = _step$value[1];

          var duplicatePath = fastPath.resolve(this._raw.rootDir, relativePath);
          duplicates.set(duplicatePath, type);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      throw new DuplicateHasteCandidatesError(name, platform, supportsNativePlatform, duplicates);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(serializableModuleMap) {
      return new ModuleMap({
        duplicates: ModuleMap.mapFromArrayRecursive(serializableModuleMap.duplicates),
        map: new Map(serializableModuleMap.map),
        mocks: new Map(serializableModuleMap.mocks),
        rootDir: serializableModuleMap.rootDir
      });
    }
  }, {
    key: "create",
    value: function create(rootDir) {
      return new ModuleMap({
        duplicates: new Map(),
        map: new Map(),
        mocks: new Map(),
        rootDir: rootDir
      });
    }
  }]);

  return ModuleMap;
}();

exports["default"] = ModuleMap;

_defineProperty(ModuleMap, 'DuplicateHasteCandidatesError', void 0);

var DuplicateHasteCandidatesError =
/*#__PURE__*/
function (_Error) {
  _inherits(DuplicateHasteCandidatesError, _Error);

  function DuplicateHasteCandidatesError(name, platform, supportsNativePlatform, duplicatesSet) {
    var _this3;

    _classCallCheck(this, DuplicateHasteCandidatesError);

    var platformMessage = getPlatformMessage(platform);
    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(DuplicateHasteCandidatesError).call(this, "The name `".concat(name, "` was looked up in the Haste module map. It ") + "cannot be resolved, because there exists several different " + "files, or packages, that provide a module for " + "that particular name and platform. ".concat(platformMessage, " You must ") + "delete or exclude files until there remains only one of these:\n\n" + Array.from(duplicatesSet).map(function (_ref) {
      var _ref2 = _slicedToArray(_ref, 2),
          dupFilePath = _ref2[0],
          dupFileType = _ref2[1];

      return "  * `".concat(dupFilePath, "` (").concat(getTypeMessage(dupFileType), ")\n");
    }).sort().join('')));

    _defineProperty(_assertThisInitialized(_this3), 'hasteName', void 0);

    _defineProperty(_assertThisInitialized(_this3), 'platform', void 0);

    _defineProperty(_assertThisInitialized(_this3), 'supportsNativePlatform', void 0);

    _defineProperty(_assertThisInitialized(_this3), 'duplicatesSet', void 0);

    _this3.hasteName = name;
    _this3.platform = platform;
    _this3.supportsNativePlatform = supportsNativePlatform;
    _this3.duplicatesSet = duplicatesSet;
    return _this3;
  }

  return DuplicateHasteCandidatesError;
}(_wrapNativeSuper(Error));

function getPlatformMessage(platform) {
  if (platform === _constants["default"].GENERIC_PLATFORM) {
    return 'The platform is generic (no extension).';
  }

  return "The platform extension is `".concat(platform, "`.");
}

function getTypeMessage(type) {
  switch (type) {
    case _constants["default"].MODULE:
      return 'module';

    case _constants["default"].PACKAGE:
      return 'package';
  }

  return 'unknown';
}

ModuleMap.DuplicateHasteCandidatesError = DuplicateHasteCandidatesError;