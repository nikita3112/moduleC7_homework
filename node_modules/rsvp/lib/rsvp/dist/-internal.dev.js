"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.noop = noop;
exports.handleMaybeThenable = handleMaybeThenable;
exports.resolve = resolve;
exports.publishRejection = publishRejection;
exports.fulfill = fulfill;
exports.reject = reject;
exports.subscribe = subscribe;
exports.publish = publish;
exports.invokeCallback = invokeCallback;
exports.initializePromise = initializePromise;
exports.REJECTED = exports.FULFILLED = exports.PENDING = void 0;

var _then = _interopRequireDefault(require("./then"));

var _resolve = _interopRequireDefault(require("./promise/resolve"));

var _instrument = _interopRequireDefault(require("./instrument"));

var _config = require("./config");

var _promise = _interopRequireDefault(require("./promise"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function withOwnPromise() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function objectOrFunction(x) {
  var type = _typeof(x);

  return x !== null && (type === 'object' || type === 'function');
}

function noop() {}

var PENDING = void 0;
exports.PENDING = PENDING;
var FULFILLED = 1;
exports.FULFILLED = FULFILLED;
var REJECTED = 2;
exports.REJECTED = REJECTED;

function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
  try {
    then.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then) {
  _config.config.async(function (promise) {
    var sealed = false;
    var error = tryThen(then, thenable, function (value) {
      if (sealed) {
        return;
      }

      sealed = true;

      if (thenable === value) {
        fulfill(promise, value);
      } else {
        resolve(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }

      sealed = true;
      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    thenable._onError = null;
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      if (thenable === value) {
        fulfill(promise, value);
      } else {
        resolve(promise, value);
      }
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then) {
  var isOwnThenable = maybeThenable.constructor === promise.constructor && then === _then["default"] && promise.constructor.resolve === _resolve["default"];

  if (isOwnThenable) {
    handleOwnThenable(promise, maybeThenable);
  } else if (typeof then === 'function') {
    handleForeignThenable(promise, maybeThenable, then);
  } else {
    fulfill(promise, maybeThenable);
  }
}

function resolve(promise, value) {
  if (promise === value) {
    fulfill(promise, value);
  } else if (objectOrFunction(value)) {
    var then;

    try {
      then = value.then;
    } catch (error) {
      reject(promise, error);
      return;
    }

    handleMaybeThenable(promise, value, then);
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onError) {
    promise._onError(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length === 0) {
    if (_config.config.instrument) {
      (0, _instrument["default"])('fulfilled', promise);
    }
  } else {
    _config.config.async(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._state = REJECTED;
  promise._result = reason;

  _config.config.async(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var subscribers = parent._subscribers;
  var length = subscribers.length;
  parent._onError = null;
  subscribers[length] = child;
  subscribers[length + FULFILLED] = onFulfillment;
  subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    _config.config.async(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (_config.config.instrument) {
    (0, _instrument["default"])(settled === FULFILLED ? 'fulfilled' : 'rejected', promise);
  }

  if (subscribers.length === 0) {
    return;
  }

  var child,
      callback,
      result = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, result);
    } else {
      callback(result);
    }
  }

  promise._subscribers.length = 0;
}

function invokeCallback(state, promise, callback, result) {
  var hasCallback = typeof callback === 'function';
  var value,
      succeeded = true,
      error;

  if (hasCallback) {
    try {
      value = callback(result);
    } catch (e) {
      succeeded = false;
      error = e;
    }
  } else {
    value = result;
  }

  if (promise._state !== PENDING) {// noop
  } else if (value === promise) {
    reject(promise, withOwnPromise());
  } else if (succeeded === false) {
    reject(promise, error);
  } else if (hasCallback) {
    resolve(promise, value);
  } else if (state === FULFILLED) {
    fulfill(promise, value);
  } else if (state === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  var resolved = false;

  try {
    resolver(function (value) {
      if (resolved) {
        return;
      }

      resolved = true;
      resolve(promise, value);
    }, function (reason) {
      if (resolved) {
        return;
      }

      resolved = true;
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}