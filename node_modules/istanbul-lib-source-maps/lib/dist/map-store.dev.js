/*
 Copyright 2015, Yahoo Inc.
 Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var path = require('path');

var fs = require('fs');

var debug = require('debug')('istanbuljs');

var _require = require('source-map'),
    SourceMapConsumer = _require.SourceMapConsumer;

var pathutils = require('./pathutils');

var _require2 = require('./transformer'),
    SourceMapTransformer = _require2.SourceMapTransformer;
/**
 * Tracks source maps for registered files
 */


var MapStore =
/*#__PURE__*/
function () {
  /**
   * @param {Object} opts [opts=undefined] options.
   * @param {Boolean} opts.verbose [opts.verbose=false] verbose mode
   * @param {String} opts.baseDir [opts.baseDir=null] alternate base directory
   *  to resolve sourcemap files
   * @param {Class} opts.SourceStore [opts.SourceStore=Map] class to use for
   * SourceStore.  Must support `get`, `set` and `clear` methods.
   * @param {Array} opts.sourceStoreOpts [opts.sourceStoreOpts=[]] arguments
   * to use in the SourceStore constructor.
   * @constructor
   */
  function MapStore(opts) {
    _classCallCheck(this, MapStore);

    opts = _objectSpread({
      baseDir: null,
      verbose: false,
      SourceStore: Map,
      sourceStoreOpts: []
    }, opts);
    this.baseDir = opts.baseDir;
    this.verbose = opts.verbose;
    this.sourceStore = _construct(opts.SourceStore, _toConsumableArray(opts.sourceStoreOpts));
    this.data = Object.create(null);
    this.sourceFinder = this.sourceFinder.bind(this);
  }
  /**
   * Registers a source map URL with this store. It makes some input sanity checks
   * and silently fails on malformed input.
   * @param transformedFilePath - the file path for which the source map is valid.
   *  This must *exactly* match the path stashed for the coverage object to be
   *  useful.
   * @param sourceMapUrl - the source map URL, **not** a comment
   */


  _createClass(MapStore, [{
    key: "registerURL",
    value: function registerURL(transformedFilePath, sourceMapUrl) {
      var d = 'data:';

      if (sourceMapUrl.length > d.length && sourceMapUrl.substring(0, d.length) === d) {
        var b64 = 'base64,';
        var pos = sourceMapUrl.indexOf(b64);

        if (pos > 0) {
          this.data[transformedFilePath] = {
            type: 'encoded',
            data: sourceMapUrl.substring(pos + b64.length)
          };
        } else {
          debug("Unable to interpret source map URL: ".concat(sourceMapUrl));
        }

        return;
      }

      var dir = path.dirname(path.resolve(transformedFilePath));
      var file = path.resolve(dir, sourceMapUrl);
      this.data[transformedFilePath] = {
        type: 'file',
        data: file
      };
    }
    /**
     * Registers a source map object with this store. Makes some basic sanity checks
     * and silently fails on malformed input.
     * @param transformedFilePath - the file path for which the source map is valid
     * @param sourceMap - the source map object
     */

  }, {
    key: "registerMap",
    value: function registerMap(transformedFilePath, sourceMap) {
      if (sourceMap && sourceMap.version) {
        this.data[transformedFilePath] = {
          type: 'object',
          data: sourceMap
        };
      } else {
        debug('Invalid source map object: ' + JSON.stringify(sourceMap, null, 2));
      }
    }
    /**
     * Retrieve a source map object from this store.
     * @param filePath - the file path for which the source map is valid
     * @returns {Object} a parsed source map object
     */

  }, {
    key: "getSourceMapSync",
    value: function getSourceMapSync(filePath) {
      try {
        if (!this.data[filePath]) {
          return;
        }

        var d = this.data[filePath];

        if (d.type === 'file') {
          return JSON.parse(fs.readFileSync(d.data, 'utf8'));
        }

        if (d.type === 'encoded') {
          return JSON.parse(Buffer.from(d.data, 'base64').toString());
        }
        /* The caller might delete properties */


        return _objectSpread({}, d.data);
      } catch (error) {
        debug('Error returning source map for ' + filePath);
        debug(error.stack);
        return;
      }
    }
    /**
     * Add inputSourceMap property to coverage data
     * @param coverageData - the __coverage__ object
     * @returns {Object} a parsed source map object
     */

  }, {
    key: "addInputSourceMapsSync",
    value: function addInputSourceMapsSync(coverageData) {
      var _this = this;

      Object.entries(coverageData).forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            filePath = _ref2[0],
            data = _ref2[1];

        if (data.inputSourceMap) {
          return;
        }

        var sourceMap = _this.getSourceMapSync(filePath);

        if (sourceMap) {
          data.inputSourceMap = sourceMap;
          /* This huge property is not needed. */

          delete data.inputSourceMap.sourcesContent;
        }
      });
    }
  }, {
    key: "sourceFinder",
    value: function sourceFinder(filePath) {
      var content = this.sourceStore.get(filePath);

      if (content !== undefined) {
        return content;
      }

      if (path.isAbsolute(filePath)) {
        return fs.readFileSync(filePath, 'utf8');
      }

      return fs.readFileSync(pathutils.asAbsolute(filePath, this.baseDir), 'utf8');
    }
    /**
     * Transforms the coverage map provided into one that refers to original
     * sources when valid mappings have been registered with this store.
     * @param {CoverageMap} coverageMap - the coverage map to transform
     * @returns {Promise<CoverageMap>} the transformed coverage map
     */

  }, {
    key: "transformCoverage",
    value: function transformCoverage(coverageMap) {
      var _this2 = this;

      var hasInputSourceMaps, transformer;
      return regeneratorRuntime.async(function transformCoverage$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              hasInputSourceMaps = coverageMap.files().some(function (file) {
                return coverageMap.fileCoverageFor(file).data.inputSourceMap;
              });

              if (!(!hasInputSourceMaps && Object.keys(this.data).length === 0)) {
                _context2.next = 3;
                break;
              }

              return _context2.abrupt("return", coverageMap);

            case 3:
              transformer = new SourceMapTransformer(function _callee(filePath, coverage) {
                var obj, smc;
                return regeneratorRuntime.async(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.prev = 0;
                        obj = coverage.data.inputSourceMap || _this2.getSourceMapSync(filePath);

                        if (obj) {
                          _context.next = 4;
                          break;
                        }

                        return _context.abrupt("return", null);

                      case 4:
                        smc = new SourceMapConsumer(obj);
                        smc.sources.forEach(function (s) {
                          var content = smc.sourceContentFor(s);

                          if (content) {
                            var sourceFilePath = pathutils.relativeTo(s, filePath);

                            _this2.sourceStore.set(sourceFilePath, content);
                          }
                        });
                        return _context.abrupt("return", smc);

                      case 9:
                        _context.prev = 9;
                        _context.t0 = _context["catch"](0);
                        debug('Error returning source map for ' + filePath);
                        debug(_context.t0.stack);
                        return _context.abrupt("return", null);

                      case 14:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, null, null, [[0, 9]]);
              });
              _context2.next = 6;
              return regeneratorRuntime.awrap(transformer.transform(coverageMap));

            case 6:
              return _context2.abrupt("return", _context2.sent);

            case 7:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this);
    }
    /**
     * Disposes temporary resources allocated by this map store
     */

  }, {
    key: "dispose",
    value: function dispose() {
      this.sourceStore.clear();
    }
  }]);

  return MapStore;
}();

module.exports = {
  MapStore: MapStore
};