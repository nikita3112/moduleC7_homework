'use strict';
/*
 Copyright 2012-2015, Yahoo Inc.
 Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var INDENT = '  ';

function attrString(attrs) {
  return Object.entries(attrs || {}).map(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        k = _ref2[0],
        v = _ref2[1];

    return " ".concat(k, "=\"").concat(v, "\"");
  }).join('');
}
/**
 * a utility class to produce well-formed, indented XML
 * @param {ContentWriter} contentWriter the content writer that this utility wraps
 * @constructor
 */


var XMLWriter =
/*#__PURE__*/
function () {
  function XMLWriter(contentWriter) {
    _classCallCheck(this, XMLWriter);

    this.cw = contentWriter;
    this.stack = [];
  }

  _createClass(XMLWriter, [{
    key: "indent",
    value: function indent(str) {
      return this.stack.map(function () {
        return INDENT;
      }).join('') + str;
    }
    /**
     * writes the opening XML tag with the supplied attributes
     * @param {String} name tag name
     * @param {Object} [attrs=null] attrs attributes for the tag
     */

  }, {
    key: "openTag",
    value: function openTag(name, attrs) {
      var str = this.indent("<".concat(name + attrString(attrs), ">"));
      this.cw.println(str);
      this.stack.push(name);
    }
    /**
     * closes an open XML tag.
     * @param {String} name - tag name to close. This must match the writer's
     *  notion of the tag that is currently open.
     */

  }, {
    key: "closeTag",
    value: function closeTag(name) {
      if (this.stack.length === 0) {
        throw new Error("Attempt to close tag ".concat(name, " when not opened"));
      }

      var stashed = this.stack.pop();
      var str = "</".concat(name, ">");

      if (stashed !== name) {
        throw new Error("Attempt to close tag ".concat(name, " when ").concat(stashed, " was the one open"));
      }

      this.cw.println(this.indent(str));
    }
    /**
     * writes a tag and its value opening and closing it at the same time
     * @param {String} name tag name
     * @param {Object} [attrs=null] attrs tag attributes
     * @param {String} [content=null] content optional tag content
     */

  }, {
    key: "inlineTag",
    value: function inlineTag(name, attrs, content) {
      var str = '<' + name + attrString(attrs);

      if (content) {
        str += ">".concat(content, "</").concat(name, ">");
      } else {
        str += '/>';
      }

      str = this.indent(str);
      this.cw.println(str);
    }
    /**
     * closes all open tags and ends the document
     */

  }, {
    key: "closeAll",
    value: function closeAll() {
      var _this = this;

      this.stack.slice().reverse().forEach(function (name) {
        _this.closeTag(name);
      });
    }
  }]);

  return XMLWriter;
}();

module.exports = XMLWriter;