'use strict';
/*
 Copyright 2012-2015, Yahoo Inc.
 Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var path = require('path');

var fs = require('fs');

var mkdirp = require('make-dir');

var supportsColor = require('supports-color');
/**
 * Base class for writing content
 * @class ContentWriter
 * @constructor
 */


var ContentWriter =
/*#__PURE__*/
function () {
  function ContentWriter() {
    _classCallCheck(this, ContentWriter);
  }

  _createClass(ContentWriter, [{
    key: "colorize",

    /**
     * returns the colorized version of a string. Typically,
     * content writers that write to files will return the
     * same string and ones writing to a tty will wrap it in
     * appropriate escape sequences.
     * @param {String} str the string to colorize
     * @param {String} clazz one of `high`, `medium` or `low`
     * @returns {String} the colorized form of the string
     */
    value: function colorize(str
    /*, clazz*/
    ) {
      return str;
    }
    /**
     * writes a string appended with a newline to the destination
     * @param {String} str the string to write
     */

  }, {
    key: "println",
    value: function println(str) {
      this.write("".concat(str, "\n"));
    }
    /**
     * closes this content writer. Should be called after all writes are complete.
     */

  }, {
    key: "close",
    value: function close() {}
  }]);

  return ContentWriter;
}();
/**
 * a content writer that writes to a file
 * @param {Number} fd - the file descriptor
 * @extends ContentWriter
 * @constructor
 */


var FileContentWriter =
/*#__PURE__*/
function (_ContentWriter) {
  _inherits(FileContentWriter, _ContentWriter);

  function FileContentWriter(fd) {
    var _this;

    _classCallCheck(this, FileContentWriter);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(FileContentWriter).call(this));
    _this.fd = fd;
    return _this;
  }

  _createClass(FileContentWriter, [{
    key: "write",
    value: function write(str) {
      fs.writeSync(this.fd, str);
    }
  }, {
    key: "close",
    value: function close() {
      fs.closeSync(this.fd);
    }
  }]);

  return FileContentWriter;
}(ContentWriter); // allow stdout to be captured for tests.


var capture = false;
var output = '';
/**
 * a content writer that writes to the console
 * @extends ContentWriter
 * @constructor
 */

var ConsoleWriter =
/*#__PURE__*/
function (_ContentWriter2) {
  _inherits(ConsoleWriter, _ContentWriter2);

  function ConsoleWriter() {
    _classCallCheck(this, ConsoleWriter);

    return _possibleConstructorReturn(this, _getPrototypeOf(ConsoleWriter).apply(this, arguments));
  }

  _createClass(ConsoleWriter, [{
    key: "write",
    value: function write(str) {
      if (capture) {
        output += str;
      } else {
        process.stdout.write(str);
      }
    }
  }, {
    key: "colorize",
    value: function colorize(str, clazz) {
      var colors = {
        low: '31;1',
        medium: '33;1',
        high: '32;1'
      };
      /* istanbul ignore next: different modes for CI and local */

      if (supportsColor.stdout && colors[clazz]) {
        return "\x1B[".concat(colors[clazz], "m").concat(str, "\x1B[0m");
      }

      return str;
    }
  }]);

  return ConsoleWriter;
}(ContentWriter);
/**
 * utility for writing files under a specific directory
 * @class FileWriter
 * @param {String} baseDir the base directory under which files should be written
 * @constructor
 */


var FileWriter =
/*#__PURE__*/
function () {
  function FileWriter(baseDir) {
    _classCallCheck(this, FileWriter);

    if (!baseDir) {
      throw new Error('baseDir must be specified');
    }

    this.baseDir = baseDir;
  }
  /**
   * static helpers for capturing stdout report output;
   * super useful for tests!
   */


  _createClass(FileWriter, [{
    key: "writerForDir",

    /**
     * returns a FileWriter that is rooted at the supplied subdirectory
     * @param {String} subdir the subdirectory under which to root the
     *  returned FileWriter
     * @returns {FileWriter}
     */
    value: function writerForDir(subdir) {
      if (path.isAbsolute(subdir)) {
        throw new Error("Cannot create subdir writer for absolute path: ".concat(subdir));
      }

      return new FileWriter("".concat(this.baseDir, "/").concat(subdir));
    }
    /**
     * copies a file from a source directory to a destination name
     * @param {String} source path to source file
     * @param {String} dest relative path to destination file
     * @param {String} [header=undefined] optional text to prepend to destination
     *  (e.g., an "this file is autogenerated" comment, copyright notice, etc.)
     */

  }, {
    key: "copyFile",
    value: function copyFile(source, dest, header) {
      if (path.isAbsolute(dest)) {
        throw new Error("Cannot write to absolute path: ".concat(dest));
      }

      dest = path.resolve(this.baseDir, dest);
      mkdirp.sync(path.dirname(dest));
      var contents;

      if (header) {
        contents = header + fs.readFileSync(source, 'utf8');
      } else {
        contents = fs.readFileSync(source);
      }

      fs.writeFileSync(dest, contents);
    }
    /**
     * returns a content writer for writing content to the supplied file.
     * @param {String|null} file the relative path to the file or the special
     *  values `"-"` or `null` for writing to the console
     * @returns {ContentWriter}
     */

  }, {
    key: "writeFile",
    value: function writeFile(file) {
      if (file === null || file === '-') {
        return new ConsoleWriter();
      }

      if (path.isAbsolute(file)) {
        throw new Error("Cannot write to absolute path: ".concat(file));
      }

      file = path.resolve(this.baseDir, file);
      mkdirp.sync(path.dirname(file));
      return new FileContentWriter(fs.openSync(file, 'w'));
    }
  }], [{
    key: "startCapture",
    value: function startCapture() {
      capture = true;
    }
  }, {
    key: "stopCapture",
    value: function stopCapture() {
      capture = false;
    }
  }, {
    key: "getOutput",
    value: function getOutput() {
      return output;
    }
  }, {
    key: "resetOutput",
    value: function resetOutput() {
      output = '';
    }
  }]);

  return FileWriter;
}();

module.exports = FileWriter;