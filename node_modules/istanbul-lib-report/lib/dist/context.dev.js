'use strict';
/*
 Copyright 2012-2015, Yahoo Inc.
 Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var fs = require('fs');

var FileWriter = require('./file-writer');

var XMLWriter = require('./xml-writer');

var tree = require('./tree');

var watermarks = require('./watermarks');

var SummarizerFactory = require('./summarizer-factory');

function defaultSourceLookup(path) {
  try {
    return fs.readFileSync(path, 'utf8');
  } catch (ex) {
    throw new Error("Unable to lookup source: ".concat(path, " (").concat(ex.message, ")"));
  }
}

function normalizeWatermarks() {
  var specified = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  Object.entries(watermarks.getDefault()).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        k = _ref2[0],
        value = _ref2[1];

    var specValue = specified[k];

    if (!Array.isArray(specValue) || specValue.length !== 2) {
      specified[k] = value;
    }
  });
  return specified;
}
/**
 * A reporting context that is passed to report implementations
 * @param {Object} [opts=null] opts options
 * @param {String} [opts.dir='coverage'] opts.dir the reporting directory
 * @param {Object} [opts.watermarks=null] opts.watermarks watermarks for
 *  statements, lines, branches and functions
 * @param {Function} [opts.sourceFinder=fsLookup] opts.sourceFinder a
 *  function that returns source code given a file path. Defaults to
 *  filesystem lookups based on path.
 * @constructor
 */


var Context =
/*#__PURE__*/
function () {
  function Context(opts) {
    _classCallCheck(this, Context);

    this.dir = opts.dir || 'coverage';
    this.watermarks = normalizeWatermarks(opts.watermarks);
    this.sourceFinder = opts.sourceFinder || defaultSourceLookup;
    this._summarizerFactory = new SummarizerFactory(opts.coverageMap, opts.defaultSummarizer);
    this.data = {};
  }
  /**
   * returns a FileWriter implementation for reporting use. Also available
   * as the `writer` property on the context.
   * @returns {Writer}
   */


  _createClass(Context, [{
    key: "getWriter",
    value: function getWriter() {
      return this.writer;
    }
    /**
     * returns the source code for the specified file path or throws if
     * the source could not be found.
     * @param {String} filePath the file path as found in a file coverage object
     * @returns {String} the source code
     */

  }, {
    key: "getSource",
    value: function getSource(filePath) {
      return this.sourceFinder(filePath);
    }
    /**
     * returns the coverage class given a coverage
     * types and a percentage value.
     * @param {String} type - the coverage type, one of `statements`, `functions`,
     *  `branches`, or `lines`
     * @param {Number} value - the percentage value
     * @returns {String} one of `high`, `medium` or `low`
     */

  }, {
    key: "classForPercent",
    value: function classForPercent(type, value) {
      var watermarks = this.watermarks[type];

      if (!watermarks) {
        return 'unknown';
      }

      if (value < watermarks[0]) {
        return 'low';
      }

      if (value >= watermarks[1]) {
        return 'high';
      }

      return 'medium';
    }
    /**
     * returns an XML writer for the supplied content writer
     * @param {ContentWriter} contentWriter the content writer to which the returned XML writer
     *  writes data
     * @returns {XMLWriter}
     */

  }, {
    key: "getXMLWriter",
    value: function getXMLWriter(contentWriter) {
      return new XMLWriter(contentWriter);
    }
    /**
     * returns a full visitor given a partial one.
     * @param {Object} partialVisitor a partial visitor only having the functions of
     *  interest to the caller. These functions are called with a scope that is the
     *  supplied object.
     * @returns {Visitor}
     */

  }, {
    key: "getVisitor",
    value: function getVisitor(partialVisitor) {
      return new tree.Visitor(partialVisitor);
    }
  }, {
    key: "getTree",
    value: function getTree() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'defaultSummarizer';
      return this._summarizerFactory[name];
    }
  }]);

  return Context;
}();

Object.defineProperty(Context.prototype, 'writer', {
  enumerable: true,
  get: function get() {
    if (!this.data.writer) {
      this.data.writer = new FileWriter(this.dir);
    }

    return this.data.writer;
  }
});
module.exports = Context;