/*
 Copyright 2012-2015, Yahoo Inc.
 Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var path = require('path');

var parsePath = path.parse;
var SEP = path.sep;
var origParser = parsePath;
var origSep = SEP;

function makeRelativeNormalizedPath(str, sep) {
  var parsed = parsePath(str);
  var root = parsed.root;
  var dir;
  var file = parsed.base;
  var quoted;
  var pos; // handle a weird windows case separately

  if (sep === '\\') {
    pos = root.indexOf(':\\');

    if (pos >= 0) {
      root = root.substring(0, pos + 2);
    }
  }

  dir = parsed.dir.substring(root.length);

  if (str === '') {
    return [];
  }

  if (sep !== '/') {
    quoted = new RegExp(sep.replace(/\W/g, '\\$&'), 'g');
    dir = dir.replace(quoted, '/');
    file = file.replace(quoted, '/'); // excessively paranoid?
  }

  if (dir !== '') {
    dir = "".concat(dir, "/").concat(file);
  } else {
    dir = file;
  }

  if (dir.substring(0, 1) === '/') {
    dir = dir.substring(1);
  }

  dir = dir.split(/\/+/);
  return dir;
}

var Path =
/*#__PURE__*/
function () {
  function Path(strOrArray) {
    _classCallCheck(this, Path);

    if (Array.isArray(strOrArray)) {
      this.v = strOrArray;
    } else if (typeof strOrArray === 'string') {
      this.v = makeRelativeNormalizedPath(strOrArray, SEP);
    } else {
      throw new Error("Invalid Path argument must be string or array:".concat(strOrArray));
    }
  }

  _createClass(Path, [{
    key: "toString",
    value: function toString() {
      return this.v.join('/');
    }
  }, {
    key: "hasParent",
    value: function hasParent() {
      return this.v.length > 0;
    }
  }, {
    key: "parent",
    value: function parent() {
      if (!this.hasParent()) {
        throw new Error('Unable to get parent for 0 elem path');
      }

      var p = this.v.slice();
      p.pop();
      return new Path(p);
    }
  }, {
    key: "elements",
    value: function elements() {
      return this.v.slice();
    }
  }, {
    key: "name",
    value: function name() {
      return this.v.slice(-1)[0];
    }
  }, {
    key: "contains",
    value: function contains(other) {
      var i;

      if (other.length > this.length) {
        return false;
      }

      for (i = 0; i < other.length; i += 1) {
        if (this.v[i] !== other.v[i]) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "ancestorOf",
    value: function ancestorOf(other) {
      return other.contains(this) && other.length !== this.length;
    }
  }, {
    key: "descendantOf",
    value: function descendantOf(other) {
      return this.contains(other) && other.length !== this.length;
    }
  }, {
    key: "commonPrefixPath",
    value: function commonPrefixPath(other) {
      var len = this.length > other.length ? other.length : this.length;
      var i;
      var ret = [];

      for (i = 0; i < len; i += 1) {
        if (this.v[i] === other.v[i]) {
          ret.push(this.v[i]);
        } else {
          break;
        }
      }

      return new Path(ret);
    }
  }], [{
    key: "compare",
    value: function compare(a, b) {
      var al = a.length;
      var bl = b.length;

      if (al < bl) {
        return -1;
      }

      if (al > bl) {
        return 1;
      }

      var astr = a.toString();
      var bstr = b.toString();
      return astr < bstr ? -1 : astr > bstr ? 1 : 0;
    }
  }]);

  return Path;
}();

['push', 'pop', 'shift', 'unshift', 'splice'].forEach(function (fn) {
  Object.defineProperty(Path.prototype, fn, {
    value: function value() {
      var _this$v;

      return (_this$v = this.v)[fn].apply(_this$v, arguments);
    }
  });
});
Object.defineProperty(Path.prototype, 'length', {
  enumerable: true,
  get: function get() {
    return this.v.length;
  }
});
module.exports = Path;
Path.tester = {
  setParserAndSep: function setParserAndSep(p, sep) {
    parsePath = p;
    SEP = sep;
  },
  reset: function reset() {
    parsePath = origParser;
    SEP = origSep;
  }
};