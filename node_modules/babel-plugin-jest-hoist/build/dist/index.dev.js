'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _templateObject() {
  var data = _taggedTemplateLiteral(["\nfunction GETTER_NAME() {\n  const { JEST_GLOBALS_MODULE_JEST_EXPORT_NAME } = require(\"JEST_GLOBALS_MODULE_NAME\");\n  GETTER_NAME = () => JEST_GLOBALS_MODULE_JEST_EXPORT_NAME;\n  return JEST_GLOBALS_MODULE_JEST_EXPORT_NAME;\n}\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

function _template() {
  var data = require('@babel/template');

  _template = function _template() {
    return data;
  };

  return data;
}

function _types() {
  var data = require('@babel/types');

  _types = function _types() {
    return data;
  };

  return data;
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */


var JEST_GLOBAL_NAME = 'jest';
var JEST_GLOBALS_MODULE_NAME = '@jest/globals';
var JEST_GLOBALS_MODULE_JEST_EXPORT_NAME = 'jest';
var hoistedVariables = new WeakSet(); // We allow `jest`, `expect`, `require`, all default Node.js globals and all
// ES2015 built-ins to be used inside of a `jest.mock` factory.
// We also allow variables prefixed with `mock` as an escape-hatch.

var ALLOWED_IDENTIFIERS = new Set(['Array', 'ArrayBuffer', 'Boolean', 'BigInt', 'DataView', 'Date', 'Error', 'EvalError', 'Float32Array', 'Float64Array', 'Function', 'Generator', 'GeneratorFunction', 'Infinity', 'Int16Array', 'Int32Array', 'Int8Array', 'InternalError', 'Intl', 'JSON', 'Map', 'Math', 'NaN', 'Number', 'Object', 'Promise', 'Proxy', 'RangeError', 'ReferenceError', 'Reflect', 'RegExp', 'Set', 'String', 'Symbol', 'SyntaxError', 'TypeError', 'URIError', 'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray', 'WeakMap', 'WeakSet', 'arguments', 'console', 'expect', 'isNaN', 'jest', 'parseFloat', 'parseInt', 'require', 'undefined'].concat(_toConsumableArray(Object.getOwnPropertyNames(global))).sort());
var IDVisitor = {
  ReferencedIdentifier: function ReferencedIdentifier(path, _ref) {
    var ids = _ref.ids;
    ids.add(path);
  },
  blacklist: ['TypeAnnotation', 'TSTypeAnnotation', 'TSTypeReference']
};
var FUNCTIONS = Object.create(null);

FUNCTIONS.mock = function (args) {
  if (args.length === 1) {
    return args[0].isStringLiteral() || args[0].isLiteral();
  } else if (args.length === 2 || args.length === 3) {
    var moduleFactory = args[1];

    if (!moduleFactory.isFunction()) {
      throw moduleFactory.buildCodeFrameError('The second argument of `jest.mock` must be an inline function.\n', TypeError);
    }

    var ids = new Set();
    var parentScope = moduleFactory.parentPath.scope; // @ts-expect-error: ReferencedIdentifier and blacklist are not known on visitors

    moduleFactory.traverse(IDVisitor, {
      ids: ids
    });
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = ids[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var id = _step.value;
        var name = id.node.name;
        var found = false;
        var scope = id.scope;

        while (scope !== parentScope) {
          if (scope.bindings[name]) {
            found = true;
            break;
          }

          scope = scope.parent;
        }

        if (!found) {
          var isAllowedIdentifier = scope.hasGlobal(name) && ALLOWED_IDENTIFIERS.has(name) || /^mock/i.test(name) || // Allow istanbul's coverage variable to pass.
          /^(?:__)?cov/.test(name);

          if (!isAllowedIdentifier) {
            var binding = scope.bindings[name];

            if (binding === null || binding === void 0 ? void 0 : binding.path.isVariableDeclarator()) {
              var node = binding.path.node;
              var initNode = node.init;

              if (initNode && binding.constant && scope.isPure(initNode, true)) {
                hoistedVariables.add(node);
                isAllowedIdentifier = true;
              }
            }
          }

          if (!isAllowedIdentifier) {
            throw id.buildCodeFrameError('The module factory of `jest.mock()` is not allowed to ' + 'reference any out-of-scope variables.\n' + 'Invalid variable access: ' + name + '\n' + 'Allowed objects: ' + Array.from(ALLOWED_IDENTIFIERS).join(', ') + '.\n' + 'Note: This is a precaution to guard against uninitialized mock ' + 'variables. If it is ensured that the mock is required lazily, ' + 'variable names prefixed with `mock` (case insensitive) are permitted.\n', ReferenceError);
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return true;
  }

  return false;
};

FUNCTIONS.unmock = function (args) {
  return args.length === 1 && args[0].isStringLiteral();
};

FUNCTIONS.deepUnmock = function (args) {
  return args.length === 1 && args[0].isStringLiteral();
};

FUNCTIONS.disableAutomock = FUNCTIONS.enableAutomock = function (args) {
  return args.length === 0;
};

var createJestObjectGetter = (0, _template().statement)(_templateObject());

var isJestObject = function isJestObject(expression) {
  // global
  if (expression.isIdentifier() && expression.node.name === JEST_GLOBAL_NAME && !expression.scope.hasBinding(JEST_GLOBAL_NAME)) {
    return true;
  } // import { jest } from '@jest/globals'


  if (expression.referencesImport(JEST_GLOBALS_MODULE_NAME, JEST_GLOBALS_MODULE_JEST_EXPORT_NAME)) {
    return true;
  } // import * as JestGlobals from '@jest/globals'


  if (expression.isMemberExpression() && !expression.node.computed && expression.get('object').referencesImport(JEST_GLOBALS_MODULE_NAME, '*') && expression.node.property.type === 'Identifier' && expression.node.property.name === JEST_GLOBALS_MODULE_JEST_EXPORT_NAME) {
    return true;
  }

  return false;
};

var extractJestObjExprIfHoistable = function extractJestObjExprIfHoistable(expr) {
  var _FUNCTIONS$propertyNa;

  if (!expr.isCallExpression()) {
    return null;
  }

  var callee = expr.get('callee');
  var args = expr.get('arguments');

  if (!callee.isMemberExpression() || callee.node.computed) {
    return null;
  }

  var object = callee.get('object');
  var property = callee.get('property');
  var propertyName = property.node.name;
  var jestObjExpr = isJestObject(object) ? object // The Jest object could be returned from another call since the functions are all chainable.
  : extractJestObjExprIfHoistable(object);

  if (!jestObjExpr) {
    return null;
  } // Important: Call the function check last
  // It might throw an error to display to the user,
  // which should only happen if we're already sure it's a call on the Jest object.


  var functionLooksHoistable = (_FUNCTIONS$propertyNa = FUNCTIONS[propertyName]) === null || _FUNCTIONS$propertyNa === void 0 ? void 0 : _FUNCTIONS$propertyNa.call(FUNCTIONS, args);
  return functionLooksHoistable ? jestObjExpr : null;
};
/* eslint-disable sort-keys */


var _default = function _default() {
  return {
    pre: function pre(_ref2) {
      var _this = this;

      var program = _ref2.path;

      this.declareJestObjGetterIdentifier = function () {
        if (_this.jestObjGetterIdentifier) {
          return _this.jestObjGetterIdentifier;
        }

        _this.jestObjGetterIdentifier = program.scope.generateUidIdentifier('getJestObj');
        program.unshiftContainer('body', [createJestObjectGetter({
          GETTER_NAME: _this.jestObjGetterIdentifier.name,
          JEST_GLOBALS_MODULE_JEST_EXPORT_NAME: JEST_GLOBALS_MODULE_JEST_EXPORT_NAME,
          JEST_GLOBALS_MODULE_NAME: JEST_GLOBALS_MODULE_NAME
        })]);
        return _this.jestObjGetterIdentifier;
      };
    },
    visitor: {
      ExpressionStatement: function ExpressionStatement(exprStmt) {
        var jestObjExpr = extractJestObjExprIfHoistable(exprStmt.get('expression'));

        if (jestObjExpr) {
          jestObjExpr.replaceWith((0, _types().callExpression)(this.declareJestObjGetterIdentifier(), []));
        }
      }
    },
    // in `post` to make sure we come after an import transform and can unshift above the `require`s
    post: function post(_ref3) {
      var program = _ref3.path;
      var self = this;
      visitBlock(program);
      program.traverse({
        BlockStatement: visitBlock
      });

      function visitBlock(block) {
        // use a temporary empty statement instead of the real first statement, which may itself be hoisted
        var _block$unshiftContain = block.unshiftContainer('body', [(0, _types().emptyStatement)(), (0, _types().emptyStatement)()]),
            _block$unshiftContain2 = _slicedToArray(_block$unshiftContain, 2),
            varsHoistPoint = _block$unshiftContain2[0],
            callsHoistPoint = _block$unshiftContain2[1];

        block.traverse({
          CallExpression: visitCallExpr,
          VariableDeclarator: visitVariableDeclarator,
          // do not traverse into nested blocks, or we'll hoist calls in there out to this block
          // @ts-expect-error blacklist is not known
          blacklist: ['BlockStatement']
        });
        callsHoistPoint.remove();
        varsHoistPoint.remove();

        function visitCallExpr(callExpr) {
          var _self$jestObjGetterId;

          var callee = callExpr.node.callee;

          if ((0, _types().isIdentifier)(callee) && callee.name === ((_self$jestObjGetterId = self.jestObjGetterIdentifier) === null || _self$jestObjGetterId === void 0 ? void 0 : _self$jestObjGetterId.name)) {
            var mockStmt = callExpr.getStatementParent();

            if (mockStmt) {
              var mockStmtParent = mockStmt.parentPath;

              if (mockStmtParent.isBlock()) {
                var mockStmtNode = mockStmt.node;
                mockStmt.remove();
                callsHoistPoint.insertBefore(mockStmtNode);
              }
            }
          }
        }

        function visitVariableDeclarator(varDecl) {
          if (hoistedVariables.has(varDecl.node)) {
            // should be assert function, but it's not. So let's cast below
            varDecl.parentPath.assertVariableDeclaration();
            var _varDecl$parent = varDecl.parent,
                kind = _varDecl$parent.kind,
                declarations = _varDecl$parent.declarations;

            if (declarations.length === 1) {
              varDecl.parentPath.remove();
            } else {
              varDecl.remove();
            }

            varsHoistPoint.insertBefore((0, _types().variableDeclaration)(kind, [varDecl.node]));
          }
        }
      }
    }
  };
};
/* eslint-enable */


exports["default"] = _default;