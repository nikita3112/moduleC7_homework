"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var source, pos, end;

var openTokenDepth, templateDepth, lastTokenPos, lastSlashWasDivision, templateStack, templateStackDepth, openTokenPosStack, openClassPosStack, nextBraceIsClass, starExportMap, lastStarExportSpecifier, _exports, reexports;

function resetState() {
  openTokenDepth = 0;
  templateDepth = -1;
  lastTokenPos = -1;
  lastSlashWasDivision = false;
  templateStack = new Array(1024);
  templateStackDepth = 0;
  openTokenPosStack = new Array(1024);
  openClassPosStack = new Array(1024);
  nextBraceIsClass = false;
  starExportMap = Object.create(null);
  lastStarExportSpecifier = null;
  _exports = new Set();
  reexports = new Set();
} // RequireType


var Import = 0;
var ExportAssign = 1;
var ExportStar = 2;
var strictReserved = new Set(['implements', 'interface', 'let', 'package', 'private', 'protected', 'public', 'static', 'yield', 'enum']);

function parseCJS(source) {
  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '@';
  resetState();

  try {
    parseSource(source);
  } catch (e) {
    e.message += "\n  at ".concat(name, ":").concat(source.slice(0, pos).split('\n').length, ":").concat(pos - source.lastIndexOf('\n', pos - 1));
    e.loc = pos;
    throw e;
  }

  var result = {
    exports: _toConsumableArray(_exports),
    reexports: _toConsumableArray(reexports)
  };
  resetState();
  return result;
}

function addExport(name) {
  if (!strictReserved.has(name)) _exports.add(name);
}

function parseSource(cjsSource) {
  source = cjsSource;
  pos = -1;
  end = source.length - 1;
  var ch = 0; // Handle #!

  if (source.charCodeAt(0) === 35
  /*#*/
  && source.charCodeAt(1) === 33
  /*!*/
  ) {
      if (source.length === 2) return true;
      pos += 2;

      while (pos++ < end) {
        ch = source.charCodeAt(pos);
        if (ch === 10
        /*\n*/
        || ch === 13
        /*\r*/
        ) break;
      }
    }

  while (pos++ < end) {
    ch = source.charCodeAt(pos);
    if (ch === 32 || ch < 14 && ch > 8) continue;

    if (openTokenDepth === 0) {
      switch (ch) {
        case 105
        /*i*/
        :
          if (source.startsWith('mport', pos + 1) && keywordStart(pos)) throwIfImportStatement();
          lastTokenPos = pos;
          continue;

        case 114
        /*r*/
        :
          var startPos = pos;
          if (tryParseRequire(Import) && keywordStart(startPos)) tryBacktrackAddStarExportBinding(startPos - 1);
          lastTokenPos = pos;
          continue;

        case 95
        /*_*/
        :
          if (source.startsWith('_export', pos + 1) && (keywordStart(pos) || source.charCodeAt(pos - 1) === 46
          /*.*/
          )) {
            pos += 8;
            if (source.startsWith('Star', pos)) pos += 4;

            if (source.charCodeAt(pos) === 40
            /*(*/
            ) {
                openTokenPosStack[openTokenDepth++] = lastTokenPos;
                if (source.charCodeAt(++pos) === 114
                /*r*/
                ) tryParseRequire(ExportStar);
              }
          }

          lastTokenPos = pos;
          continue;
      }
    }

    switch (ch) {
      case 101
      /*e*/
      :
        if (source.startsWith('xport', pos + 1) && keywordStart(pos)) {
          if (source.charCodeAt(pos + 6) === 115
          /*s*/
          ) tryParseExportsDotAssign(false);else if (openTokenDepth === 0) throwIfExportStatement();
        }

        break;

      case 99
      /*c*/
      :
        if (keywordStart(pos) && source.startsWith('lass', pos + 1) && isBrOrWs(source.charCodeAt(pos + 5))) nextBraceIsClass = true;
        break;

      case 109
      /*m*/
      :
        if (source.startsWith('odule', pos + 1) && keywordStart(pos)) tryParseModuleExportsDotAssign();
        break;

      case 79
      /*O*/
      :
        if (source.startsWith('bject', pos + 1) && keywordStart(pos)) tryParseObjectDefineOrKeys(openTokenDepth === 0);
        break;

      case 40
      /*(*/
      :
        openTokenPosStack[openTokenDepth++] = lastTokenPos;
        break;

      case 41
      /*)*/
      :
        if (openTokenDepth === 0) throw new Error('Unexpected closing bracket.');
        openTokenDepth--;
        break;

      case 123
      /*{*/
      :
        openClassPosStack[openTokenDepth] = nextBraceIsClass;
        nextBraceIsClass = false;
        openTokenPosStack[openTokenDepth++] = lastTokenPos;
        break;

      case 125
      /*}*/
      :
        if (openTokenDepth === 0) throw new Error('Unexpected closing brace.');

        if (openTokenDepth-- === templateDepth) {
          templateDepth = templateStack[--templateStackDepth];
          templateString();
        } else {
          if (templateDepth !== -1 && openTokenDepth < templateDepth) throw new Error('Unexpected closing brace.');
        }

        break;

      case 60
      /*>*/
      :
        // TODO: <!-- XML comment support
        break;

      case 39
      /*'*/
      :
        singleQuoteString();
        break;

      case 34
      /*"*/
      :
        doubleQuoteString();
        break;

      case 47
      /*/*/
      :
        {
          var next_ch = source.charCodeAt(pos + 1);

          if (next_ch === 47
          /*/*/
          ) {
              lineComment(); // dont update lastToken

              continue;
            } else if (next_ch === 42
          /***/
          ) {
              blockComment(); // dont update lastToken

              continue;
            } else {
            // Division / regex ambiguity handling based on checking backtrack analysis of:
            // - what token came previously (lastToken)
            // - if a closing brace or paren, what token came before the corresponding
            //   opening brace or paren (lastOpenTokenIndex)
            var lastToken = source.charCodeAt(lastTokenPos);

            if (isExpressionPunctuator(lastToken) && !(lastToken === 46
            /*.*/
            && source.charCodeAt(lastTokenPos - 1) >= 48
            /*0*/
            && source.charCodeAt(lastTokenPos - 1) <= 57
            /*9*/
            ) && !(lastToken === 43
            /*+*/
            && source.charCodeAt(lastTokenPos - 1) === 43
            /*+*/
            ) && !(lastToken === 45
            /*-*/
            && source.charCodeAt(lastTokenPos - 1) === 45
            /*-*/
            ) || lastToken === 41
            /*)*/
            && isParenKeyword(openTokenPosStack[openTokenDepth]) || lastToken === 125
            /*}*/
            && (isExpressionTerminator(openTokenPosStack[openTokenDepth]) || openClassPosStack[openTokenDepth]) || lastToken === 47
            /*/*/
            && lastSlashWasDivision || isExpressionKeyword(lastTokenPos) || !lastToken) {
              regularExpression();
              lastSlashWasDivision = false;
            } else {
              lastSlashWasDivision = true;
            }
          }

          break;
        }

      case 96
      /*`*/
      :
        templateString();
        break;
    }

    lastTokenPos = pos;
  }

  if (templateDepth !== -1) throw new Error('Unterminated template.');
  if (openTokenDepth) throw new Error('Unterminated braces.');
}

function tryBacktrackAddStarExportBinding(bPos) {
  while (source.charCodeAt(bPos) === 32
  /* */
  && bPos >= 0) {
    bPos--;
  }

  if (source.charCodeAt(bPos) === 61
  /*=*/
  ) {
      bPos--;

      while (source.charCodeAt(bPos) === 32
      /* */
      && bPos >= 0) {
        bPos--;
      }

      var codePoint;
      var id_end = bPos;
      var identifierStart = false;

      while ((codePoint = codePointAtLast(bPos)) && bPos >= 0) {
        if (codePoint === 92
        /*\*/
        ) return;
        if (!isIdentifierChar(codePoint, true)) break;
        identifierStart = isIdentifierStart(codePoint, true);
        bPos -= codePointLen(codePoint);
      }

      if (identifierStart && source.charCodeAt(bPos) === 32
      /* */
      ) {
          var starExportId = source.slice(bPos + 1, id_end + 1);

          while (source.charCodeAt(bPos) === 32
          /* */
          && bPos >= 0) {
            bPos--;
          }

          switch (source.charCodeAt(bPos)) {
            case 114
            /*r*/
            :
              if (!source.startsWith('va', bPos - 2)) return;
              break;

            case 116
            /*t*/
            :
              if (!source.startsWith('le', bPos - 2) && !source.startsWith('cons', bPos - 4)) return;
              break;

            default:
              return;
          }

          starExportMap[starExportId] = lastStarExportSpecifier;
        }
    }
}

function tryParseObjectDefineOrKeys(keys) {
  pos += 6;
  var revertPos = pos - 1;
  var ch = commentWhitespace();

  if (ch === 46
  /*.*/
  ) {
      pos++;
      ch = commentWhitespace();

      if (ch === 100
      /*d*/
      && source.startsWith('efineProperty', pos + 1)) {
        while (true) {
          pos += 14;
          revertPos = pos - 1;
          ch = commentWhitespace();
          if (ch !== 40
          /*(*/
          ) break;
          pos++;
          ch = commentWhitespace();
          if (!readExportsOrModuleDotExports(ch)) break;
          ch = commentWhitespace();
          if (ch !== 44
          /*,*/
          ) break;
          pos++;
          ch = commentWhitespace();
          if (ch !== 39
          /*'*/
          && ch !== 34
          /*"*/
          ) break;
          var quot = ch;
          var exportPos = ++pos;
          if (!identifier() || source.charCodeAt(pos) !== quot) break;
          var expt = source.slice(exportPos, pos);
          pos++;
          ch = commentWhitespace();
          if (ch !== 44
          /*,*/
          ) break;
          pos++;
          ch = commentWhitespace();
          if (ch !== 123
          /*{*/
          ) break;
          pos++;
          ch = commentWhitespace();

          if (ch === 101
          /*e*/
          ) {
              if (!source.startsWith('numerable', pos + 1)) break;
              pos += 10;
              ch = commentWhitespace();
              if (ch !== 58
              /*:*/
              ) break;
              pos++;
              ch = commentWhitespace();
              if (ch !== 116
              /*t*/
              || !source.startsWith('rue', pos + 1)) break;
              pos += 4;
              ch = commentWhitespace();
              if (ch !== 44) break;
              pos++;
              ch = commentWhitespace();
            }

          if (ch === 118
          /*v*/
          ) {
              if (!source.startsWith('alue', pos + 1)) break;
              pos += 5;
              ch = commentWhitespace();
              if (ch !== 58
              /*:*/
              ) break;
              pos++;
              addExport(expt);
              break;
            } else if (ch === 103
          /*g*/
          ) {
              if (!source.startsWith('et', pos + 1)) break;
              pos += 3;
              ch = commentWhitespace();

              if (ch === 58
              /*:*/
              ) {
                  pos++;
                  ch = commentWhitespace();
                  if (ch !== 102
                  /*f*/
                  ) break;
                  if (!source.startsWith('unction', pos + 1)) break;
                  pos += 8;
                  var lastPos = pos;
                  ch = commentWhitespace();
                  if (ch !== 40 && (lastPos === pos || !identifier())) break;
                  ch = commentWhitespace();
                }

              if (ch !== 40
              /*(*/
              ) break;
              pos++;
              ch = commentWhitespace();
              if (ch !== 41
              /*)*/
              ) break;
              pos++;
              ch = commentWhitespace();
              if (ch !== 123
              /*{*/
              ) break;
              pos++;
              ch = commentWhitespace();
              if (ch !== 114
              /*r*/
              ) break;
              if (!source.startsWith('eturn', pos + 1)) break;
              pos += 6;
              ch = commentWhitespace();
              if (!identifier()) break;
              ch = commentWhitespace();

              if (ch === 46
              /*.*/
              ) {
                  pos++;
                  commentWhitespace();
                  if (!identifier()) break;
                  ch = commentWhitespace();
                } else if (ch === 91
              /*[*/
              ) {
                  pos++;
                  ch = commentWhitespace();
                  if (ch === 39
                  /*'*/
                  ) singleQuoteString();else if (ch === 34
                  /*"*/
                  ) doubleQuoteString();else break;
                  pos++;
                  ch = commentWhitespace();
                  if (ch !== 93
                  /*]*/
                  ) break;
                  pos++;
                  ch = commentWhitespace();
                }

              if (ch === 59
              /*;*/
              ) {
                  pos++;
                  ch = commentWhitespace();
                }

              if (ch !== 125
              /*}*/
              ) break;
              pos++;
              ch = commentWhitespace();
              if (ch !== 125
              /*}*/
              ) break;
              pos++;
              ch = commentWhitespace();
              if (ch !== 41
              /*)*/
              ) break;
              addExport(expt);
              return;
            }

          break;
        }
      } else if (keys && ch === 107
      /*k*/
      && source.startsWith('eys', pos + 1)) {
        while (true) {
          pos += 4;
          revertPos = pos - 1;
          ch = commentWhitespace();
          if (ch !== 40
          /*(*/
          ) break;
          pos++;
          ch = commentWhitespace();
          var id_start = pos;
          if (!identifier()) break;
          var id = source.slice(id_start, pos);
          ch = commentWhitespace();
          if (ch !== 41
          /*)*/
          ) break;
          revertPos = pos++;
          ch = commentWhitespace();
          if (ch !== 46
          /*.*/
          ) break;
          pos++;
          ch = commentWhitespace();
          if (ch !== 102
          /*f*/
          || !source.startsWith('orEach', pos + 1)) break;
          pos += 7;
          ch = commentWhitespace();
          revertPos = pos - 1;
          if (ch !== 40
          /*(*/
          ) break;
          pos++;
          ch = commentWhitespace();
          if (ch !== 102
          /*f*/
          || !source.startsWith('unction', pos + 1)) break;
          pos += 8;
          ch = commentWhitespace();
          if (ch !== 40
          /*(*/
          ) break;
          pos++;
          ch = commentWhitespace();
          var it_id_start = pos;
          if (!identifier()) break;
          var it_id = source.slice(it_id_start, pos);
          ch = commentWhitespace();
          if (ch !== 41
          /*)*/
          ) break;
          pos++;
          ch = commentWhitespace();
          if (ch !== 123
          /*{*/
          ) break;
          pos++;
          ch = commentWhitespace();
          if (ch !== 105
          /*i*/
          || source.charCodeAt(pos + 1) !== 102
          /*f*/
          ) break;
          pos += 2;
          ch = commentWhitespace();
          if (ch !== 40
          /*(*/
          ) break;
          pos++;
          ch = commentWhitespace();
          if (!source.startsWith(it_id, pos)) break;
          pos += it_id.length;
          ch = commentWhitespace(); // `if (` IDENTIFIER$2 `===` ( `'default'` | `"default"` ) `||` IDENTIFIER$2 `===` ( '__esModule' | `"__esModule"` ) `) return` `;`? |

          if (ch === 61
          /*=*/
          ) {
              if (!source.startsWith('==', pos + 1)) break;
              pos += 3;
              ch = commentWhitespace();
              if (ch !== 34
              /*"*/
              && ch !== 39
              /*'*/
              ) break;
              var _quot = ch;
              if (!source.startsWith('default', pos + 1)) break;
              pos += 8;
              ch = commentWhitespace();
              if (ch !== _quot) break;
              pos += 1;
              ch = commentWhitespace();
              if (ch !== 124
              /*|*/
              || source.charCodeAt(pos + 1) !== 124
              /*|*/
              ) break;
              pos += 2;
              ch = commentWhitespace();
              if (source.slice(pos, pos + it_id.length) !== it_id) break;
              pos += it_id.length;
              ch = commentWhitespace();
              if (ch !== 61
              /*=*/
              || source.slice(pos + 1, pos + 3) !== '==') break;
              pos += 3;
              ch = commentWhitespace();
              if (ch !== 34
              /*"*/
              && ch !== 39
              /*'*/
              ) break;
              _quot = ch;
              if (!source.startsWith('__esModule', pos + 1)) break;
              pos += 11;
              ch = commentWhitespace();
              if (ch !== _quot) break;
              pos += 1;
              ch = commentWhitespace();
              if (ch !== 41
              /*)*/
              ) break;
              pos += 1;
              ch = commentWhitespace();
              if (ch !== 114
              /*r*/
              || !source.startsWith('eturn', pos + 1)) break;
              pos += 6;
              ch = commentWhitespace();
              if (ch === 59
              /*;*/
              ) pos++;
              ch = commentWhitespace();
            } // `if (` IDENTIFIER$2 `!==` ( `'default'` | `"default"` ) `)`
          else if (ch === 33
            /*!*/
            ) {
                if (!source.startsWith('==', pos + 1)) break;
                pos += 3;
                ch = commentWhitespace();
                if (ch !== 34
                /*"*/
                && ch !== 39
                /*'*/
                ) break;
                var _quot2 = ch;
                if (!source.startsWith('default', pos + 1)) break;
                pos += 8;
                ch = commentWhitespace();
                if (ch !== _quot2) break;
                pos += 1;
                ch = commentWhitespace();
                if (ch !== 41
                /*)*/
                ) break;
                pos += 1;
                ch = commentWhitespace();
              } else break; // `if (` IDENTIFIER$2 `in` EXPORTS_IDENTIFIER `&&` EXPORTS_IDENTIFIER `[` IDENTIFIER$2 `] ===` IDENTIFIER$1 `[` IDENTIFIER$2 `]) return` `;`?


          if (ch === 105
          /*i*/
          && source.charCodeAt(pos + 1) === 102
          /*f*/
          ) {
              pos += 2;
              ch = commentWhitespace();
              if (ch !== 40
              /*(*/
              ) break;
              pos++;
              ch = commentWhitespace();
              if (!source.startsWith(it_id, pos)) break;
              pos += it_id.length;
              ch = commentWhitespace();
              if (ch !== 105
              /*i*/
              || !source.startsWith('n ', pos + 1)) break;
              pos += 3;
              ch = commentWhitespace();
              if (!readExportsOrModuleDotExports(ch)) break;
              ch = commentWhitespace();
              if (ch !== 38
              /*&*/
              || source.charCodeAt(pos + 1) !== 38
              /*&*/
              ) break;
              pos += 2;
              ch = commentWhitespace();
              if (!readExportsOrModuleDotExports(ch)) break;
              ch = commentWhitespace();
              if (ch !== 91
              /*[*/
              ) break;
              pos++;
              ch = commentWhitespace();
              if (!source.startsWith(it_id, pos)) break;
              pos += it_id.length;
              ch = commentWhitespace();
              if (ch !== 93
              /*]*/
              ) break;
              pos++;
              ch = commentWhitespace();
              if (ch !== 61
              /*=*/
              || !source.startsWith('==', pos + 1)) break;
              pos += 3;
              ch = commentWhitespace();
              if (!source.startsWith(id, pos)) break;
              pos += id.length;
              ch = commentWhitespace();
              if (ch !== 91
              /*[*/
              ) break;
              pos++;
              ch = commentWhitespace();
              if (!source.startsWith(it_id, pos)) break;
              pos += it_id.length;
              ch = commentWhitespace();
              if (ch !== 93
              /*]*/
              ) break;
              pos++;
              ch = commentWhitespace();
              if (ch !== 41
              /*)*/
              ) break;
              pos++;
              ch = commentWhitespace();
              if (ch !== 114
              /*r*/
              || !source.startsWith('eturn', pos + 1)) break;
              pos += 6;
              ch = commentWhitespace();
              if (ch === 59
              /*;*/
              ) pos++;
              ch = commentWhitespace();
            } // EXPORTS_IDENTIFIER `[` IDENTIFIER$2 `] =` IDENTIFIER$1 `[` IDENTIFIER$2 `]`


          if (readExportsOrModuleDotExports(ch)) {
            ch = commentWhitespace();
            if (ch !== 91
            /*[*/
            ) break;
            pos++;
            ch = commentWhitespace();
            if (source.slice(pos, pos + it_id.length) !== it_id) break;
            pos += it_id.length;
            ch = commentWhitespace();
            if (ch !== 93
            /*]*/
            ) break;
            pos++;
            ch = commentWhitespace();
            if (ch !== 61
            /*=*/
            ) break;
            pos++;
            ch = commentWhitespace();
            if (source.slice(pos, pos + id.length) !== id) break;
            pos += id.length;
            ch = commentWhitespace();
            if (ch !== 91
            /*[*/
            ) break;
            pos++;
            ch = commentWhitespace();
            if (source.slice(pos, pos + it_id.length) !== it_id) break;
            pos += it_id.length;
            ch = commentWhitespace();
            if (ch !== 93
            /*]*/
            ) break;
            pos++;
            ch = commentWhitespace();

            if (ch === 59
            /*;*/
            ) {
                pos++;
                ch = commentWhitespace();
              }
          } // `Object.defineProperty(` EXPORTS_IDENTIFIER `, ` IDENTIFIER$2 `, { enumerable: true, get: function () { return ` IDENTIFIER$1 `[` IDENTIFIER$2 `]; } })`
          else if (ch === 79
            /*O*/
            ) {
                if (source.slice(pos + 1, pos + 6) !== 'bject') break;
                pos += 6;
                ch = commentWhitespace();
                if (ch !== 46
                /*.*/
                ) break;
                pos++;
                ch = commentWhitespace();
                if (ch !== 100
                /*d*/
                || !source.startsWith('efineProperty', pos + 1)) break;
                pos += 14;
                ch = commentWhitespace();
                if (ch !== 40
                /*(*/
                ) break;
                pos++;
                ch = commentWhitespace();
                if (!readExportsOrModuleDotExports(ch)) break;
                ch = commentWhitespace();
                if (ch !== 44
                /*,*/
                ) break;
                pos++;
                ch = commentWhitespace();
                if (!source.startsWith(it_id, pos)) break;
                pos += it_id.length;
                ch = commentWhitespace();
                if (ch !== 44
                /*,*/
                ) break;
                pos++;
                ch = commentWhitespace();
                if (ch !== 123
                /*{*/
                ) break;
                pos++;
                ch = commentWhitespace();
                if (ch !== 101
                /*e*/
                || !source.startsWith('numerable', pos + 1)) break;
                pos += 10;
                ch = commentWhitespace();
                if (ch !== 58
                /*:*/
                ) break;
                pos++;
                ch = commentWhitespace();
                if (ch !== 116
                /*t*/
                && !source.startsWith('rue', pos + 1)) break;
                pos += 4;
                ch = commentWhitespace();
                if (ch !== 44
                /*,*/
                ) break;
                pos++;
                ch = commentWhitespace();
                if (ch !== 103
                /*g*/
                || !source.startsWith('et', pos + 1)) break;
                pos += 3;
                ch = commentWhitespace();
                if (ch !== 58
                /*:*/
                ) break;
                pos++;
                ch = commentWhitespace();
                if (ch !== 102
                /*f*/
                || !source.startsWith('unction', pos + 1)) break;
                pos += 8;
                ch = commentWhitespace();
                if (ch !== 40
                /*(*/
                ) break;
                pos++;
                ch = commentWhitespace();
                if (ch !== 41
                /*)*/
                ) break;
                pos++;
                ch = commentWhitespace();
                if (ch !== 123
                /*{*/
                ) break;
                pos++;
                ch = commentWhitespace();
                if (ch !== 114
                /*r*/
                || !source.startsWith('eturn', pos + 1)) break;
                pos += 6;
                ch = commentWhitespace();
                if (!source.startsWith(id, pos)) break;
                pos += id.length;
                ch = commentWhitespace();
                if (ch !== 91
                /*[*/
                ) break;
                pos++;
                ch = commentWhitespace();
                if (!source.startsWith(it_id, pos)) break;
                pos += it_id.length;
                ch = commentWhitespace();
                if (ch !== 93
                /*]*/
                ) break;
                pos++;
                ch = commentWhitespace();

                if (ch === 59
                /*;*/
                ) {
                    pos++;
                    ch = commentWhitespace();
                  }

                if (ch !== 125
                /*}*/
                ) break;
                pos++;
                ch = commentWhitespace();
                if (ch !== 125
                /*}*/
                ) break;
                pos++;
                ch = commentWhitespace();
                if (ch !== 41
                /*)*/
                ) break;
                pos++;
                ch = commentWhitespace();

                if (ch === 59
                /*;*/
                ) {
                    pos++;
                    ch = commentWhitespace();
                  }
              } else break;

          if (ch !== 125
          /*}*/
          ) break;
          pos++;
          ch = commentWhitespace();
          if (ch !== 41
          /*)*/
          ) break;
          var starExportSpecifier = starExportMap[id];

          if (starExportSpecifier) {
            reexports.add(starExportSpecifier);
            pos = revertPos;
            return;
          }

          return;
        }
      }
    }

  pos = revertPos;
}

function readExportsOrModuleDotExports(ch) {
  var revertPos = pos;

  if (ch === 109
  /*m*/
  && source.startsWith('odule', pos + 1)) {
    pos += 6;
    ch = commentWhitespace();

    if (ch !== 46
    /*.*/
    ) {
        pos = revertPos;
        return false;
      }

    pos++;
    ch = commentWhitespace();
  }

  if (ch === 101
  /*e*/
  && source.startsWith('xports', pos + 1)) {
    pos += 7;
    return true;
  } else {
    pos = revertPos;
    return false;
  }
}

function tryParseModuleExportsDotAssign() {
  pos += 6;
  var revertPos = pos - 1;
  var ch = commentWhitespace();

  if (ch === 46
  /*.*/
  ) {
      pos++;
      ch = commentWhitespace();

      if (ch === 101
      /*e*/
      && source.startsWith('xports', pos + 1)) {
        tryParseExportsDotAssign(true);
        return;
      }
    }

  pos = revertPos;
}

function tryParseExportsDotAssign(assign) {
  pos += 7;
  var revertPos = pos - 1;
  var ch = commentWhitespace();

  switch (ch) {
    // exports.asdf
    case 46
    /*.*/
    :
      {
        pos++;
        ch = commentWhitespace();
        var startPos = pos;

        if (identifier()) {
          var endPos = pos;
          ch = commentWhitespace();

          if (ch === 61
          /*=*/
          ) {
              addExport(source.slice(startPos, endPos));
              return;
            }
        }

        break;
      }
    // exports['asdf']

    case 91
    /*[*/
    :
      {
        pos++;
        ch = commentWhitespace();

        if (ch === 39
        /*'*/
        || ch === 34
        /*"*/
        ) {
            pos++;
            var _startPos = pos;

            if (identifier() && source.charCodeAt(pos) === ch) {
              var _endPos = pos++;

              ch = commentWhitespace();
              if (ch !== 93
              /*]*/
              ) break;
              pos++;
              ch = commentWhitespace();
              if (ch !== 61
              /*=*/
              ) break;
              addExport(source.slice(_startPos, _endPos));
            }
          }

        break;
      }
    // module.exports =

    case 61
    /*=*/
    :
      {
        if (assign) {
          if (reexports.size) reexports = new Set();
          pos++;
          ch = commentWhitespace(); // { ... }

          if (ch === 123
          /*{*/
          ) {
              tryParseLiteralExports();
              return;
            } // require('...')


          if (ch === 114
          /*r*/
          ) tryParseRequire(ExportAssign);
        }
      }
  }

  pos = revertPos;
}

function tryParseRequire(requireType) {
  // require('...')
  var revertPos = pos;

  if (source.startsWith('equire', pos + 1)) {
    pos += 7;
    var ch = commentWhitespace();

    if (ch === 40
    /*(*/
    ) {
        pos++;
        ch = commentWhitespace();
        var reexportStart = pos + 1;

        if (ch === 39
        /*'*/
        ) {
            singleQuoteString();
            var reexportEnd = pos++;
            ch = commentWhitespace();

            if (ch === 41
            /*)*/
            ) {
                switch (requireType) {
                  case ExportAssign:
                    reexports.add(source.slice(reexportStart, reexportEnd));
                    return true;

                  case ExportStar:
                    reexports.add(source.slice(reexportStart, reexportEnd));
                    return true;

                  default:
                    lastStarExportSpecifier = source.slice(reexportStart, reexportEnd);
                    return true;
                }
              }
          } else if (ch === 34
        /*"*/
        ) {
            doubleQuoteString();

            var _reexportEnd = pos++;

            ch = commentWhitespace();

            if (ch === 41
            /*)*/
            ) {
                switch (requireType) {
                  case ExportAssign:
                    reexports.add(source.slice(reexportStart, _reexportEnd));
                    return true;

                  case ExportStar:
                    reexports.add(source.slice(reexportStart, _reexportEnd));
                    return true;

                  default:
                    lastStarExportSpecifier = source.slice(reexportStart, _reexportEnd);
                    return true;
                }
              }
          }
      }

    pos = revertPos;
  }

  return false;
}

function tryParseLiteralExports() {
  var revertPos = pos - 1;

  while (pos++ < end) {
    var ch = commentWhitespace();
    var startPos = pos;

    if (identifier()) {
      var endPos = pos;
      ch = commentWhitespace();

      if (ch === 58
      /*:*/
      ) {
          pos++;
          ch = commentWhitespace(); // nothing more complex than identifier expressions for now

          if (!identifier()) {
            pos = revertPos;
            return;
          }

          ch = source.charCodeAt(pos);
        }

      addExport(source.slice(startPos, endPos));
    } else if (ch === 46
    /*.*/
    && source.startsWith('..', pos + 1)) {
      pos += 3;

      if (source.charCodeAt(pos) === 114
      /*r*/
      && tryParseRequire(ExportAssign)) {
        pos++;
      } else if (!identifier()) {
        pos = revertPos;
        return;
      }

      ch = commentWhitespace();
    } else if (ch === 39
    /*'*/
    || ch === 34
    /*"*/
    ) {
        var _startPos2 = ++pos;

        if (identifier() && source.charCodeAt(pos) === ch) {
          var _endPos2 = pos++;

          ch = commentWhitespace();

          if (ch === 58
          /*:*/
          ) {
              pos++;
              ch = commentWhitespace(); // nothing more complex than identifier expressions for now

              if (!identifier()) {
                pos = revertPos;
                return;
              }

              ch = source.charCodeAt(pos);
              addExport(source.slice(_startPos2, _endPos2));
            }
        }
      } else {
      pos = revertPos;
      return;
    }

    if (ch === 125
    /*}*/
    ) return;

    if (ch !== 44
    /*,*/
    ) {
        pos = revertPos;
        return;
      }
  }
} // --- Extracted from AcornJS ---
//(https://github.com/acornjs/acorn/blob/master/acorn/src/identifier.js#L23
//
// MIT License
// Copyright (C) 2012-2018 by various contributors (see AUTHORS)
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
// ## Character categories
// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.


var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
nonASCIIidentifierStartChars = nonASCIIidentifierChars = null; // These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by bin/generate-identifier-regex.js
// eslint-disable-next-line comma-spacing

var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938]; // eslint-disable-next-line comma-spacing

var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239]; // This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.

function isInAstralSet(code, set) {
  var pos = 0x10000;

  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) return false;
    pos += set[i + 1];
    if (pos >= code) return true;
  }
} // Test whether a given character code starts an identifier.


function isIdentifierStart(code, astral) {
  if (code < 65) return code === 36;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  if (astral === false) return false;
  return isInAstralSet(code, astralIdentifierStartCodes);
} // Test whether a given character is part of an identifier.


function isIdentifierChar(code, astral) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  if (astral === false) return false;
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}

function identifier() {
  var ch = source.codePointAt(pos);
  if (!isIdentifierStart(ch, true) || ch === '\\') return false;
  pos += codePointLen(ch);

  while (ch = source.codePointAt(pos)) {
    if (isIdentifierChar(ch, true)) {
      pos += codePointLen(ch);
    } else if (ch === '\\') {
      // no identifier escapes support for now
      return false;
    } else {
      break;
    }
  }

  return true;
}

function codePointLen(ch) {
  if (ch < 0x10000) return 1;
  return 2;
}

function codePointAtLast(bPos) {
  // Gives the UTF char for backtracking surrogates
  var ch = source.charCodeAt(bPos);
  if ((ch & 0xFC00) === 0xDC00) return ((source.charCodeAt(bPos - 1) & 0x3FF) << 10 | ch & 0x3FF) + 0x10000;
  return ch;
}

function throwIfImportStatement() {
  var startPos = pos;
  pos += 6;
  var ch = commentWhitespace();

  switch (ch) {
    // dynamic import
    case 40
    /*(*/
    :
      openTokenPosStack[openTokenDepth++] = startPos;
      return;
    // import.meta

    case 46
    /*.*/
    :
      throw new Error('Unexpected import.meta in CJS module.');
      return;

    default:
      // no space after "import" -> not an import keyword
      if (pos === startPos + 6) break;

    case 34
    /*"*/
    :
    case 39
    /*'*/
    :
    case 123
    /*{*/
    :
    case 42
    /***/
    :
      // import statement only permitted at base-level
      if (openTokenDepth !== 0) {
        pos--;
        return;
      } // import statements are a syntax error in CommonJS


      throw new Error('Unexpected import statement in CJS module.');
  }
}

function throwIfExportStatement() {
  pos += 6;
  var curPos = pos;
  var ch = commentWhitespace();
  if (pos === curPos && !isPunctuator(ch)) return;
  throw new Error('Unexpected export statement in CJS module.');
}

function commentWhitespace() {
  var ch;

  do {
    ch = source.charCodeAt(pos);

    if (ch === 47
    /*/*/
    ) {
        var next_ch = source.charCodeAt(pos + 1);
        if (next_ch === 47
        /*/*/
        ) lineComment();else if (next_ch === 42
        /***/
        ) blockComment();else return ch;
      } else if (!isBrOrWs(ch)) {
      return ch;
    }
  } while (pos++ < end);

  return ch;
}

function templateString() {
  while (pos++ < end) {
    var ch = source.charCodeAt(pos);

    if (ch === 36
    /*$*/
    && source.charCodeAt(pos + 1) === 123
    /*{*/
    ) {
        pos++;
        templateStack[templateStackDepth++] = templateDepth;
        templateDepth = ++openTokenDepth;
        return;
      }

    if (ch === 96
    /*`*/
    ) return;
    if (ch === 92
    /*\*/
    ) pos++;
  }

  syntaxError();
}

function blockComment() {
  pos++;

  while (pos++ < end) {
    var ch = source.charCodeAt(pos);

    if (ch === 42
    /***/
    && source.charCodeAt(pos + 1) === 47
    /*/*/
    ) {
        pos++;
        return;
      }
  }
}

function lineComment() {
  while (pos++ < end) {
    var ch = source.charCodeAt(pos);
    if (ch === 10
    /*\n*/
    || ch === 13
    /*\r*/
    ) return;
  }
}

function singleQuoteString() {
  while (pos++ < end) {
    var ch = source.charCodeAt(pos);
    if (ch === 39
    /*'*/
    ) return;

    if (ch === 92
    /*\*/
    ) {
        ch = source.charCodeAt(++pos);
        if (ch === 13
        /*\r*/
        && source.charCodeAt(pos + 1) === 10
        /*\n*/
        ) pos++;
      } else if (isBr(ch)) break;
  }

  throw new Error('Unterminated string.');
}

function doubleQuoteString() {
  while (pos++ < end) {
    var ch = source.charCodeAt(pos);
    if (ch === 34
    /*"*/
    ) return;

    if (ch === 92
    /*\*/
    ) {
        ch = source.charCodeAt(++pos);
        if (ch === 13
        /*\r*/
        && source.charCodeAt(pos + 1) === 10
        /*\n*/
        ) pos++;
      } else if (isBr(ch)) break;
  }

  throw new Error('Unterminated string.');
}

function regexCharacterClass() {
  while (pos++ < end) {
    var ch = source.charCodeAt(pos);
    if (ch === 93
    /*]*/
    ) return ch;
    if (ch === 92
    /*\*/
    ) pos++;else if (ch === 10
    /*\n*/
    || ch === 13
    /*\r*/
    ) break;
  }

  throw new Error('Syntax error reading regular expression class.');
}

function regularExpression() {
  while (pos++ < end) {
    var ch = source.charCodeAt(pos);
    if (ch === 47
    /*/*/
    ) return;
    if (ch === 91
    /*[*/
    ) ch = regexCharacterClass();else if (ch === 92
    /*\*/
    ) pos++;else if (ch === 10
    /*\n*/
    || ch === 13
    /*\r*/
    ) break;
  }

  throw new Error('Syntax error reading regular expression.');
} // Note: non-asii BR and whitespace checks omitted for perf / footprint
// if there is a significant user need this can be reconsidered


function isBr(c) {
  return c === 13
  /*\r*/
  || c === 10
  /*\n*/
  ;
}

function isBrOrWs(c) {
  return c > 8 && c < 14 || c === 32 || c === 160;
}

function isBrOrWsOrPunctuatorNotDot(c) {
  return c > 8 && c < 14 || c === 32 || c === 160 || isPunctuator(c) && c !== 46
  /*.*/
  ;
}

function keywordStart(pos) {
  return pos === 0 || isBrOrWsOrPunctuatorNotDot(source.charCodeAt(pos - 1));
}

function readPrecedingKeyword(pos, match) {
  if (pos < match.length - 1) return false;
  return source.startsWith(match, pos - match.length + 1) && (pos === 0 || isBrOrWsOrPunctuatorNotDot(source.charCodeAt(pos - match.length)));
}

function readPrecedingKeyword1(pos, ch) {
  return source.charCodeAt(pos) === ch && (pos === 0 || isBrOrWsOrPunctuatorNotDot(source.charCodeAt(pos - 1)));
} // Detects one of case, debugger, delete, do, else, in, instanceof, new,
//   return, throw, typeof, void, yield, await


function isExpressionKeyword(pos) {
  switch (source.charCodeAt(pos)) {
    case 100
    /*d*/
    :
      switch (source.charCodeAt(pos - 1)) {
        case 105
        /*i*/
        :
          // void
          return readPrecedingKeyword(pos - 2, 'vo');

        case 108
        /*l*/
        :
          // yield
          return readPrecedingKeyword(pos - 2, 'yie');

        default:
          return false;
      }

    case 101
    /*e*/
    :
      switch (source.charCodeAt(pos - 1)) {
        case 115
        /*s*/
        :
          switch (source.charCodeAt(pos - 2)) {
            case 108
            /*l*/
            :
              // else
              return readPrecedingKeyword1(pos - 3, 101
              /*e*/
              );

            case 97
            /*a*/
            :
              // case
              return readPrecedingKeyword1(pos - 3, 99
              /*c*/
              );

            default:
              return false;
          }

        case 116
        /*t*/
        :
          // delete
          return readPrecedingKeyword(pos - 2, 'dele');

        default:
          return false;
      }

    case 102
    /*f*/
    :
      if (source.charCodeAt(pos - 1) !== 111
      /*o*/
      || source.charCodeAt(pos - 2) !== 101
      /*e*/
      ) return false;

      switch (source.charCodeAt(pos - 3)) {
        case 99
        /*c*/
        :
          // instanceof
          return readPrecedingKeyword(pos - 4, 'instan');

        case 112
        /*p*/
        :
          // typeof
          return readPrecedingKeyword(pos - 4, 'ty');

        default:
          return false;
      }

    case 110
    /*n*/
    :
      // in, return
      return readPrecedingKeyword1(pos - 1, 105
      /*i*/
      ) || readPrecedingKeyword(pos - 1, 'retur');

    case 111
    /*o*/
    :
      // do
      return readPrecedingKeyword1(pos - 1, 100
      /*d*/
      );

    case 114
    /*r*/
    :
      // debugger
      return readPrecedingKeyword(pos - 1, 'debugge');

    case 116
    /*t*/
    :
      // await
      return readPrecedingKeyword(pos - 1, 'awai');

    case 119
    /*w*/
    :
      switch (source.charCodeAt(pos - 1)) {
        case 101
        /*e*/
        :
          // new
          return readPrecedingKeyword1(pos - 2, 110
          /*n*/
          );

        case 111
        /*o*/
        :
          // throw
          return readPrecedingKeyword(pos - 2, 'thr');

        default:
          return false;
      }

  }

  return false;
}

function isParenKeyword(curPos) {
  return source.charCodeAt(curPos) === 101
  /*e*/
  && source.startsWith('whil', curPos - 4) || source.charCodeAt(curPos) === 114
  /*r*/
  && source.startsWith('fo', curPos - 2) || source.charCodeAt(curPos - 1) === 105
  /*i*/
  && source.charCodeAt(curPos) === 102
  /*f*/
  ;
}

function isPunctuator(ch) {
  // 23 possible punctuator endings: !%&()*+,-./:;<=>?[]^{}|~
  return ch === 33
  /*!*/
  || ch === 37
  /*%*/
  || ch === 38
  /*&*/
  || ch > 39 && ch < 48 || ch > 57 && ch < 64 || ch === 91
  /*[*/
  || ch === 93
  /*]*/
  || ch === 94
  /*^*/
  || ch > 122 && ch < 127;
}

function isExpressionPunctuator(ch) {
  // 20 possible expression endings: !%&(*+,-.:;<=>?[^{|~
  return ch === 33
  /*!*/
  || ch === 37
  /*%*/
  || ch === 38
  /*&*/
  || ch > 39 && ch < 47 && ch !== 41 || ch > 57 && ch < 64 || ch === 91
  /*[*/
  || ch === 94
  /*^*/
  || ch > 122 && ch < 127 && ch !== 125
  /*}*/
  ;
}

function isExpressionTerminator(curPos) {
  // detects:
  // => ; ) finally catch else
  // as all of these followed by a { will indicate a statement brace
  switch (source.charCodeAt(curPos)) {
    case 62
    /*>*/
    :
      return source.charCodeAt(curPos - 1) === 61
      /*=*/
      ;

    case 59
    /*;*/
    :
    case 41
    /*)*/
    :
      return true;

    case 104
    /*h*/
    :
      return source.startsWith('catc', curPos - 4);

    case 121
    /*y*/
    :
      return source.startsWith('finall', curPos - 6);

    case 101
    /*e*/
    :
      return source.startsWith('els', curPos - 3);
  }

  return false;
}

var initPromise = Promise.resolve();

module.exports.init = function () {
  return initPromise;
};

module.exports.parse = parseCJS;