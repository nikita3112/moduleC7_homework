"use strict";

var xnv = require("xml-name-validator");

var attributeUtils = require("./attributes");

var _require = require("./constants"),
    NAMESPACES = _require.NAMESPACES,
    VOID_ELEMENTS = _require.VOID_ELEMENTS,
    NODE_TYPES = _require.NODE_TYPES;

var XML_CHAR = /^(\x09|\x0A|\x0D|[\x20-\uD7FF]|[\uE000-\uFFFD]|(?:[\uD800-\uDBFF][\uDC00-\uDFFF]))*$/;
var PUBID_CHAR = /^(\x20|\x0D|\x0A|[a-zA-Z0-9]|[-'()+,./:=?;!*#@$_%])*$/;

function asciiCaseInsensitiveMatch(a, b) {
  if (a.length !== b.length) {
    return false;
  }

  for (var i = 0; i < a.length; ++i) {
    if ((a.charCodeAt(i) | 32) !== (b.charCodeAt(i) | 32)) {
      return false;
    }
  }

  return true;
}

function recordNamespaceInformation(element, map, prefixMap) {
  var defaultNamespaceAttrValue = null;

  for (var i = 0; i < element.attributes.length; ++i) {
    var attr = element.attributes[i];

    if (attr.namespaceURI === NAMESPACES.XMLNS) {
      if (attr.prefix === null) {
        defaultNamespaceAttrValue = attr.value;
        continue;
      }

      var namespaceDefinition = attr.value;

      if (namespaceDefinition === NAMESPACES.XML) {
        continue;
      } // This is exactly the other way than the spec says, but that's intended.
      // All the maps coalesce null to the empty string (explained in the
      // spec), so instead of doing that every time, just do it once here.


      if (namespaceDefinition === null) {
        namespaceDefinition = "";
      }

      if (namespaceDefinition in map && map[namespaceDefinition].includes(attr.localName)) {
        continue;
      }

      if (!(namespaceDefinition in map)) {
        map[namespaceDefinition] = [];
      }

      map[namespaceDefinition].push(attr.localName);
      prefixMap[attr.localName] = namespaceDefinition;
    }
  }

  return defaultNamespaceAttrValue;
}

function serializeDocumentType(node, namespace, prefixMap, requireWellFormed) {
  if (requireWellFormed && !PUBID_CHAR.test(node.publicId)) {
    throw new Error("Failed to serialize XML: document type node publicId is not well-formed.");
  }

  if (requireWellFormed && (!XML_CHAR.test(node.systemId) || node.systemId.includes('"') && node.systemId.includes("'"))) {
    throw new Error("Failed to serialize XML: document type node systemId is not well-formed.");
  }

  var markup = "<!DOCTYPE ".concat(node.name);

  if (node.publicId !== "") {
    markup += " PUBLIC \"".concat(node.publicId, "\"");
  } else if (node.systemId !== "") {
    markup += " SYSTEM";
  }

  if (node.systemId !== "") {
    markup += " \"".concat(node.systemId, "\"");
  }

  return markup + ">";
}

function serializeProcessingInstruction(node, namespace, prefixMap, requireWellFormed) {
  if (requireWellFormed && (node.target.includes(":") || asciiCaseInsensitiveMatch(node.target, "xml"))) {
    throw new Error("Failed to serialize XML: processing instruction node target is not well-formed.");
  }

  if (requireWellFormed && (!XML_CHAR.test(node.data) || node.data.includes("?>"))) {
    throw new Error("Failed to serialize XML: processing instruction node data is not well-formed.");
  }

  return "<?".concat(node.target, " ").concat(node.data, "?>");
}

function serializeDocument(node, namespace, prefixMap, requireWellFormed, refs) {
  if (requireWellFormed && node.documentElement === null) {
    throw new Error("Failed to serialize XML: document does not have a document element.");
  }

  var serializedDocument = "";
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = node.childNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var child = _step.value;
      serializedDocument += xmlSerialization(child, namespace, prefixMap, requireWellFormed, refs);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return serializedDocument;
}

function serializeDocumentFragment(node, namespace, prefixMap, requireWellFormed, refs) {
  var markup = "";
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = node.childNodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var child = _step2.value;
      markup += xmlSerialization(child, namespace, prefixMap, requireWellFormed, refs);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return markup;
}

function serializeText(node, namespace, prefixMap, requireWellFormed) {
  if (requireWellFormed && !XML_CHAR.test(node.data)) {
    throw new Error("Failed to serialize XML: text node data is not well-formed.");
  }

  return node.data.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}

function serializeComment(node, namespace, prefixMap, requireWellFormed) {
  if (requireWellFormed && !XML_CHAR.test(node.data)) {
    throw new Error("Failed to serialize XML: comment node data is not well-formed.");
  }

  if (requireWellFormed && (node.data.includes("--") || node.data.endsWith("-"))) {
    throw new Error("Failed to serialize XML: found hyphens in illegal places in comment node data.");
  }

  return "<!--".concat(node.data, "-->");
}

function serializeElement(node, namespace, prefixMap, requireWellFormed, refs) {
  if (requireWellFormed && (node.localName.includes(":") || !xnv.name(node.localName))) {
    throw new Error("Failed to serialize XML: element node localName is not a valid XML name.");
  }

  var markup = "<";
  var qualifiedName = "";
  var skipEndTag = false;
  var ignoreNamespaceDefinitionAttr = false;
  var map = Object.assign({}, prefixMap);
  var localPrefixesMap = Object.create(null);
  var localDefaultNamespace = recordNamespaceInformation(node, map, localPrefixesMap);
  var inheritedNs = namespace;
  var ns = node.namespaceURI;

  if (inheritedNs === ns) {
    if (localDefaultNamespace !== null) {
      ignoreNamespaceDefinitionAttr = true;
    }

    if (ns === NAMESPACES.XML) {
      qualifiedName = "xml:" + node.localName;
    } else {
      qualifiedName = node.localName;
    }

    markup += qualifiedName;
  } else {
    var prefix = node.prefix;
    var candidatePrefix = attributeUtils.preferredPrefixString(map, ns, prefix);

    if (prefix === "xmlns") {
      if (requireWellFormed) {
        throw new Error("Failed to serialize XML: element nodes can't have a prefix of \"xmlns\".");
      }

      candidatePrefix = "xmlns";
    }

    if (candidatePrefix !== null) {
      qualifiedName = candidatePrefix + ":" + node.localName;

      if (localDefaultNamespace !== null && localDefaultNamespace !== NAMESPACES.XML) {
        inheritedNs = localDefaultNamespace === "" ? null : localDefaultNamespace;
      }

      markup += qualifiedName;
    } else if (prefix !== null) {
      if (prefix in localPrefixesMap) {
        prefix = attributeUtils.generatePrefix(map, ns, refs.prefixIndex++);
      }

      if (map[ns]) {
        map[ns].push(prefix);
      } else {
        map[ns] = [prefix];
      }

      qualifiedName = prefix + ":" + node.localName;
      markup += "".concat(qualifiedName, " xmlns:").concat(prefix, "=\"").concat(attributeUtils.serializeAttributeValue(ns, requireWellFormed), "\"");

      if (localDefaultNamespace !== null) {
        inheritedNs = localDefaultNamespace === "" ? null : localDefaultNamespace;
      }
    } else if (localDefaultNamespace === null || localDefaultNamespace !== ns) {
      ignoreNamespaceDefinitionAttr = true;
      qualifiedName = node.localName;
      inheritedNs = ns;
      markup += "".concat(qualifiedName, " xmlns=\"").concat(attributeUtils.serializeAttributeValue(ns, requireWellFormed), "\"");
    } else {
      qualifiedName = node.localName;
      inheritedNs = ns;
      markup += qualifiedName;
    }
  }

  markup += attributeUtils.serializeAttributes(node, map, localPrefixesMap, ignoreNamespaceDefinitionAttr, requireWellFormed, refs);

  if (ns === NAMESPACES.HTML && node.childNodes.length === 0 && VOID_ELEMENTS.has(node.localName)) {
    markup += " /";
    skipEndTag = true;
  } else if (ns !== NAMESPACES.HTML && node.childNodes.length === 0) {
    markup += "/";
    skipEndTag = true;
  }

  markup += ">";

  if (skipEndTag) {
    return markup;
  }

  if (ns === NAMESPACES.HTML && node.localName === "template") {
    markup += xmlSerialization(node.content, inheritedNs, map, requireWellFormed, refs);
  } else {
    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      for (var _iterator3 = node.childNodes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        var child = _step3.value;
        markup += xmlSerialization(child, inheritedNs, map, requireWellFormed, refs);
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
          _iterator3["return"]();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  }

  markup += "</".concat(qualifiedName, ">");
  return markup;
}

function serializeCDATASection(node) {
  return "<![CDATA[" + node.data + "]]>";
}
/**
 * @param {{prefixIndex: number}} refs
 */


function xmlSerialization(node, namespace, prefixMap, requireWellFormed, refs) {
  switch (node.nodeType) {
    case NODE_TYPES.ELEMENT_NODE:
      return serializeElement(node, namespace, prefixMap, requireWellFormed, refs);

    case NODE_TYPES.DOCUMENT_NODE:
      return serializeDocument(node, namespace, prefixMap, requireWellFormed, refs);

    case NODE_TYPES.COMMENT_NODE:
      return serializeComment(node, namespace, prefixMap, requireWellFormed);

    case NODE_TYPES.TEXT_NODE:
      return serializeText(node, namespace, prefixMap, requireWellFormed);

    case NODE_TYPES.DOCUMENT_FRAGMENT_NODE:
      return serializeDocumentFragment(node, namespace, prefixMap, requireWellFormed, refs);

    case NODE_TYPES.DOCUMENT_TYPE_NODE:
      return serializeDocumentType(node, namespace, prefixMap, requireWellFormed);

    case NODE_TYPES.PROCESSING_INSTRUCTION_NODE:
      return serializeProcessingInstruction(node, namespace, prefixMap, requireWellFormed);

    case NODE_TYPES.ATTRIBUTE_NODE:
      return "";

    case NODE_TYPES.CDATA_SECTION_NODE:
      return serializeCDATASection(node);

    default:
      throw new TypeError("Failed to serialize XML: only Nodes can be serialized.");
  }
}

module.exports = function (root) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$requireWellForme = _ref.requireWellFormed,
      requireWellFormed = _ref$requireWellForme === void 0 ? false : _ref$requireWellForme;

  var namespacePrefixMap = Object.create(null);
  namespacePrefixMap["http://www.w3.org/XML/1998/namespace"] = ["xml"];
  return xmlSerialization(root, null, namespacePrefixMap, requireWellFormed, {
    prefixIndex: 1
  });
};