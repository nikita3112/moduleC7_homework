'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

function fs() {
  var data = _interopRequireWildcard(require('graceful-fs'));

  fs = function fs() {
    return data;
  };

  return data;
}

function _jestHasteMap() {
  var data = require('jest-haste-map');

  _jestHasteMap = function _jestHasteMap() {
    return data;
  };

  return data;
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== 'function') return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var FAIL = 0;
var SUCCESS = 1;
/**
 * The TestSequencer will ultimately decide which tests should run first.
 * It is responsible for storing and reading from a local cache
 * map that stores context information for a given test, such as how long it
 * took to run during the last run and if it has failed or not.
 * Such information is used on:
 * TestSequencer.sort(tests: Array<Test>)
 * to sort the order of the provided tests.
 *
 * After the results are collected,
 * TestSequencer.cacheResults(tests: Array<Test>, results: AggregatedResult)
 * is called to store/update this information on the cache map.
 */

var TestSequencer =
/*#__PURE__*/
function () {
  function TestSequencer() {
    _classCallCheck(this, TestSequencer);

    _defineProperty(this, '_cache', new Map());
  }

  _createClass(TestSequencer, [{
    key: "_getCachePath",
    value: function _getCachePath(context) {
      var config = context.config;
      return (0, _jestHasteMap().getCacheFilePath)(config.cacheDirectory, 'perf-cache-' + config.name);
    }
  }, {
    key: "_getCache",
    value: function _getCache(test) {
      var context = test.context;

      if (!this._cache.has(context) && context.config.cache) {
        var cachePath = this._getCachePath(context);

        if (fs().existsSync(cachePath)) {
          try {
            this._cache.set(context, JSON.parse(fs().readFileSync(cachePath, 'utf8')));
          } catch (_unused) {}
        }
      }

      var cache = this._cache.get(context);

      if (!cache) {
        cache = {};

        this._cache.set(context, cache);
      }

      return cache;
    }
    /**
     * Sorting tests is very important because it has a great impact on the
     * user-perceived responsiveness and speed of the test run.
     *
     * If such information is on cache, tests are sorted based on:
     * -> Has it failed during the last run ?
     * Since it's important to provide the most expected feedback as quickly
     * as possible.
     * -> How long it took to run ?
     * Because running long tests first is an effort to minimize worker idle
     * time at the end of a long test run.
     * And if that information is not available they are sorted based on file size
     * since big test files usually take longer to complete.
     *
     * Note that a possible improvement would be to analyse other information
     * from the file other than its size.
     *
     */

  }, {
    key: "sort",
    value: function sort(tests) {
      var _this = this;

      var stats = {};

      var fileSize = function fileSize(_ref) {
        var path = _ref.path,
            hasteFS = _ref.context.hasteFS;
        return stats[path] || (stats[path] = hasteFS.getSize(path) || 0);
      };

      var hasFailed = function hasFailed(cache, test) {
        return cache[test.path] && cache[test.path][0] === FAIL;
      };

      var time = function time(cache, test) {
        return cache[test.path] && cache[test.path][1];
      };

      tests.forEach(function (test) {
        return test.duration = time(_this._getCache(test), test);
      });
      return tests.sort(function (testA, testB) {
        var cacheA = _this._getCache(testA);

        var cacheB = _this._getCache(testB);

        var failedA = hasFailed(cacheA, testA);
        var failedB = hasFailed(cacheB, testB);
        var hasTimeA = testA.duration != null;

        if (failedA !== failedB) {
          return failedA ? -1 : 1;
        } else if (hasTimeA != (testB.duration != null)) {
          // If only one of two tests has timing information, run it last
          return hasTimeA ? 1 : -1;
        } else if (testA.duration != null && testB.duration != null) {
          return testA.duration < testB.duration ? 1 : -1;
        } else {
          return fileSize(testA) < fileSize(testB) ? 1 : -1;
        }
      });
    }
  }, {
    key: "allFailedTests",
    value: function allFailedTests(tests) {
      var _this2 = this;

      var hasFailed = function hasFailed(cache, test) {
        var _cache$test$path;

        return ((_cache$test$path = cache[test.path]) === null || _cache$test$path === void 0 ? void 0 : _cache$test$path[0]) === FAIL;
      };

      return this.sort(tests.filter(function (test) {
        return hasFailed(_this2._getCache(test), test);
      }));
    }
  }, {
    key: "cacheResults",
    value: function cacheResults(tests, results) {
      var _this3 = this;

      var map = Object.create(null);
      tests.forEach(function (test) {
        return map[test.path] = test;
      });
      results.testResults.forEach(function (testResult) {
        if (testResult && map[testResult.testFilePath] && !testResult.skipped) {
          var cache = _this3._getCache(map[testResult.testFilePath]);

          var perf = testResult.perfStats;
          cache[testResult.testFilePath] = [testResult.numFailingTests ? FAIL : SUCCESS, perf.runtime || 0];
        }
      });

      this._cache.forEach(function (cache, context) {
        return fs().writeFileSync(_this3._getCachePath(context), JSON.stringify(cache));
      });
    }
  }]);

  return TestSequencer;
}();

exports["default"] = TestSequencer;