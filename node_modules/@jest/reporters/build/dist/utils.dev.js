'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.wrapAnsiString = exports.getSummary = exports.relativePath = exports.formatTestPath = exports.trimAndFormatPath = exports.printDisplayName = void 0;

function path() {
  var data = _interopRequireWildcard(require('path'));

  path = function path() {
    return data;
  };

  return data;
}

function _chalk() {
  var data = _interopRequireDefault(require('chalk'));

  _chalk = function _chalk() {
    return data;
  };

  return data;
}

function _slash() {
  var data = _interopRequireDefault(require('slash'));

  _slash = function _slash() {
    return data;
  };

  return data;
}

function _jestUtil() {
  var data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== 'function') return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var PROGRESS_BAR_WIDTH = 40;

var printDisplayName = function printDisplayName(config) {
  var displayName = config.displayName;

  var white = _chalk()["default"].reset.inverse.white;

  if (!displayName) {
    return '';
  }

  var name = displayName.name,
      color = displayName.color;
  var chosenColor = _chalk()["default"].reset.inverse[color] ? _chalk()["default"].reset.inverse[color] : white;
  return _chalk()["default"].supportsColor ? chosenColor(" ".concat(name, " ")) : name;
};

exports.printDisplayName = printDisplayName;

var trimAndFormatPath = function trimAndFormatPath(pad, config, testPath, columns) {
  var maxLength = columns - pad;
  var relative = relativePath(config, testPath);
  var basename = relative.basename;
  var dirname = relative.dirname; // length is ok

  if ((dirname + path().sep + basename).length <= maxLength) {
    return (0, _slash()["default"])(_chalk()["default"].dim(dirname + path().sep) + _chalk()["default"].bold(basename));
  } // we can fit trimmed dirname and full basename


  var basenameLength = basename.length;

  if (basenameLength + 4 < maxLength) {
    var dirnameLength = maxLength - 4 - basenameLength;
    dirname = '...' + dirname.slice(dirname.length - dirnameLength, dirname.length);
    return (0, _slash()["default"])(_chalk()["default"].dim(dirname + path().sep) + _chalk()["default"].bold(basename));
  }

  if (basenameLength + 4 === maxLength) {
    return (0, _slash()["default"])(_chalk()["default"].dim('...' + path().sep) + _chalk()["default"].bold(basename));
  } // can't fit dirname, but can fit trimmed basename


  return (0, _slash()["default"])(_chalk()["default"].bold('...' + basename.slice(basename.length - maxLength - 4, basename.length)));
};

exports.trimAndFormatPath = trimAndFormatPath;

var formatTestPath = function formatTestPath(config, testPath) {
  var _relativePath = relativePath(config, testPath),
      dirname = _relativePath.dirname,
      basename = _relativePath.basename;

  return (0, _slash()["default"])(_chalk()["default"].dim(dirname + path().sep) + _chalk()["default"].bold(basename));
};

exports.formatTestPath = formatTestPath;

var relativePath = function relativePath(config, testPath) {
  // this function can be called with ProjectConfigs or GlobalConfigs. GlobalConfigs
  // do not have config.cwd, only config.rootDir. Try using config.cwd, fallback
  // to config.rootDir. (Also, some unit just use config.rootDir, which is ok)
  testPath = path().relative(config.cwd || config.rootDir, testPath);
  var dirname = path().dirname(testPath);
  var basename = path().basename(testPath);
  return {
    basename: basename,
    dirname: dirname
  };
};

exports.relativePath = relativePath;

var getValuesCurrentTestCases = function getValuesCurrentTestCases() {
  var currentTestCases = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var numFailingTests = 0;
  var numPassingTests = 0;
  var numPendingTests = 0;
  var numTodoTests = 0;
  var numTotalTests = 0;
  currentTestCases.forEach(function (testCase) {
    switch (testCase.testCaseResult.status) {
      case 'failed':
        {
          numFailingTests++;
          break;
        }

      case 'passed':
        {
          numPassingTests++;
          break;
        }

      case 'skipped':
        {
          numPendingTests++;
          break;
        }

      case 'todo':
        {
          numTodoTests++;
          break;
        }
    }

    numTotalTests++;
  });
  return {
    numFailingTests: numFailingTests,
    numPassingTests: numPassingTests,
    numPendingTests: numPendingTests,
    numTodoTests: numTodoTests,
    numTotalTests: numTotalTests
  };
};

var getSummary = function getSummary(aggregatedResults, options) {
  var runTime = (Date.now() - aggregatedResults.startTime) / 1000;

  if (options && options.roundTime) {
    runTime = Math.floor(runTime);
  }

  var valuesForCurrentTestCases = getValuesCurrentTestCases(options === null || options === void 0 ? void 0 : options.currentTestCases);
  var estimatedTime = options && options.estimatedTime || 0;
  var snapshotResults = aggregatedResults.snapshot;
  var snapshotsAdded = snapshotResults.added;
  var snapshotsFailed = snapshotResults.unmatched;
  var snapshotsOutdated = snapshotResults.unchecked;
  var snapshotsFilesRemoved = snapshotResults.filesRemoved;
  var snapshotsDidUpdate = snapshotResults.didUpdate;
  var snapshotsPassed = snapshotResults.matched;
  var snapshotsTotal = snapshotResults.total;
  var snapshotsUpdated = snapshotResults.updated;
  var suitesFailed = aggregatedResults.numFailedTestSuites;
  var suitesPassed = aggregatedResults.numPassedTestSuites;
  var suitesPending = aggregatedResults.numPendingTestSuites;
  var suitesRun = suitesFailed + suitesPassed;
  var suitesTotal = aggregatedResults.numTotalTestSuites;
  var testsFailed = aggregatedResults.numFailedTests;
  var testsPassed = aggregatedResults.numPassedTests;
  var testsPending = aggregatedResults.numPendingTests;
  var testsTodo = aggregatedResults.numTodoTests;
  var testsTotal = aggregatedResults.numTotalTests;
  var width = options && options.width || 0;
  var suites = _chalk()["default"].bold('Test Suites: ') + (suitesFailed ? _chalk()["default"].bold.red("".concat(suitesFailed, " failed")) + ', ' : '') + (suitesPending ? _chalk()["default"].bold.yellow("".concat(suitesPending, " skipped")) + ', ' : '') + (suitesPassed ? _chalk()["default"].bold.green("".concat(suitesPassed, " passed")) + ', ' : '') + (suitesRun !== suitesTotal ? suitesRun + ' of ' + suitesTotal : suitesTotal) + " total";
  var updatedTestsFailed = testsFailed + valuesForCurrentTestCases.numFailingTests;
  var updatedTestsPending = testsPending + valuesForCurrentTestCases.numPendingTests;
  var updatedTestsTodo = testsTodo + valuesForCurrentTestCases.numTodoTests;
  var updatedTestsPassed = testsPassed + valuesForCurrentTestCases.numPassingTests;
  var updatedTestsTotal = testsTotal + valuesForCurrentTestCases.numTotalTests;
  var tests = _chalk()["default"].bold('Tests:       ') + (updatedTestsFailed > 0 ? _chalk()["default"].bold.red("".concat(updatedTestsFailed, " failed")) + ', ' : '') + (updatedTestsPending > 0 ? _chalk()["default"].bold.yellow("".concat(updatedTestsPending, " skipped")) + ', ' : '') + (updatedTestsTodo > 0 ? _chalk()["default"].bold.magenta("".concat(updatedTestsTodo, " todo")) + ', ' : '') + (updatedTestsPassed > 0 ? _chalk()["default"].bold.green("".concat(updatedTestsPassed, " passed")) + ', ' : '') + "".concat(updatedTestsTotal, " total");
  var snapshots = _chalk()["default"].bold('Snapshots:   ') + (snapshotsFailed ? _chalk()["default"].bold.red("".concat(snapshotsFailed, " failed")) + ', ' : '') + (snapshotsOutdated && !snapshotsDidUpdate ? _chalk()["default"].bold.yellow("".concat(snapshotsOutdated, " obsolete")) + ', ' : '') + (snapshotsOutdated && snapshotsDidUpdate ? _chalk()["default"].bold.green("".concat(snapshotsOutdated, " removed")) + ', ' : '') + (snapshotsFilesRemoved && !snapshotsDidUpdate ? _chalk()["default"].bold.yellow((0, _jestUtil().pluralize)('file', snapshotsFilesRemoved) + ' obsolete') + ', ' : '') + (snapshotsFilesRemoved && snapshotsDidUpdate ? _chalk()["default"].bold.green((0, _jestUtil().pluralize)('file', snapshotsFilesRemoved) + ' removed') + ', ' : '') + (snapshotsUpdated ? _chalk()["default"].bold.green("".concat(snapshotsUpdated, " updated")) + ', ' : '') + (snapshotsAdded ? _chalk()["default"].bold.green("".concat(snapshotsAdded, " written")) + ', ' : '') + (snapshotsPassed ? _chalk()["default"].bold.green("".concat(snapshotsPassed, " passed")) + ', ' : '') + "".concat(snapshotsTotal, " total");
  var time = renderTime(runTime, estimatedTime, width);
  return [suites, tests, snapshots, time].join('\n');
};

exports.getSummary = getSummary;

var renderTime = function renderTime(runTime, estimatedTime, width) {
  // If we are more than one second over the estimated time, highlight it.
  var renderedTime = estimatedTime && runTime >= estimatedTime + 1 ? _chalk()["default"].bold.yellow((0, _jestUtil().formatTime)(runTime, 0)) : (0, _jestUtil().formatTime)(runTime, 0);
  var time = _chalk()["default"].bold("Time:") + "        ".concat(renderedTime);

  if (runTime < estimatedTime) {
    time += ", estimated ".concat((0, _jestUtil().formatTime)(estimatedTime, 0));
  } // Only show a progress bar if the test run is actually going to take
  // some time.


  if (estimatedTime > 2 && runTime < estimatedTime && width) {
    var availableWidth = Math.min(PROGRESS_BAR_WIDTH, width);
    var length = Math.min(Math.floor(runTime / estimatedTime * availableWidth), availableWidth);

    if (availableWidth >= 2) {
      time += '\n' + _chalk()["default"].green('█').repeat(length) + _chalk()["default"].white('█').repeat(availableWidth - length);
    }
  }

  return time;
}; // word-wrap a string that contains ANSI escape sequences.
// ANSI escape sequences do not add to the string length.


var wrapAnsiString = function wrapAnsiString(string, terminalWidth) {
  if (terminalWidth === 0) {
    // if the terminal width is zero, don't bother word-wrapping
    return string;
  }

  var ANSI_REGEXP = /[\u001b\u009b]\[\d{1,2}m/g;
  var tokens = [];
  var lastIndex = 0;
  var match;

  while (match = ANSI_REGEXP.exec(string)) {
    var ansi = match[0];
    var index = match['index'];

    if (index != lastIndex) {
      tokens.push(['string', string.slice(lastIndex, index)]);
    }

    tokens.push(['ansi', ansi]);
    lastIndex = index + ansi.length;
  }

  if (lastIndex != string.length - 1) {
    tokens.push(['string', string.slice(lastIndex, string.length)]);
  }

  var lastLineLength = 0;
  return tokens.reduce(function (lines, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        kind = _ref2[0],
        token = _ref2[1];

    if (kind === 'string') {
      if (lastLineLength + token.length > terminalWidth) {
        while (token.length) {
          var chunk = token.slice(0, terminalWidth - lastLineLength);
          var remaining = token.slice(terminalWidth - lastLineLength, token.length);
          lines[lines.length - 1] += chunk;
          lastLineLength += chunk.length;
          token = remaining;

          if (token.length) {
            lines.push('');
            lastLineLength = 0;
          }
        }
      } else {
        lines[lines.length - 1] += token;
        lastLineLength += token.length;
      }
    } else {
      lines[lines.length - 1] += token;
    }

    return lines;
  }, ['']).join('\n');
};

exports.wrapAnsiString = wrapAnsiString;