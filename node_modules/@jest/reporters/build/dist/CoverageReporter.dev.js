'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

function path() {
  var data = _interopRequireWildcard(require('path'));

  path = function path() {
    return data;
  };

  return data;
}

function _v8Coverage() {
  var data = require('@bcoe/v8-coverage');

  _v8Coverage = function _v8Coverage() {
    return data;
  };

  return data;
}

function _chalk() {
  var data = _interopRequireDefault(require('chalk'));

  _chalk = function _chalk() {
    return data;
  };

  return data;
}

function _glob() {
  var data = _interopRequireDefault(require('glob'));

  _glob = function _glob() {
    return data;
  };

  return data;
}

function fs() {
  var data = _interopRequireWildcard(require('graceful-fs'));

  fs = function fs() {
    return data;
  };

  return data;
}

function _istanbulLibCoverage() {
  var data = _interopRequireDefault(require('istanbul-lib-coverage'));

  _istanbulLibCoverage = function _istanbulLibCoverage() {
    return data;
  };

  return data;
}

function _istanbulLibReport() {
  var data = _interopRequireDefault(require('istanbul-lib-report'));

  _istanbulLibReport = function _istanbulLibReport() {
    return data;
  };

  return data;
}

function _istanbulLibSourceMaps() {
  var data = _interopRequireDefault(require('istanbul-lib-source-maps'));

  _istanbulLibSourceMaps = function _istanbulLibSourceMaps() {
    return data;
  };

  return data;
}

function _istanbulReports() {
  var data = _interopRequireDefault(require('istanbul-reports'));

  _istanbulReports = function _istanbulReports() {
    return data;
  };

  return data;
}

function _v8ToIstanbul() {
  var data = _interopRequireDefault(require('v8-to-istanbul'));

  _v8ToIstanbul = function _v8ToIstanbul() {
    return data;
  };

  return data;
}

function _jestUtil() {
  var data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

function _jestWorker() {
  var data = _interopRequireDefault(require('jest-worker'));

  _jestWorker = function _jestWorker() {
    return data;
  };

  return data;
}

var _BaseReporter = _interopRequireDefault(require('./BaseReporter'));

var _getWatermarks = _interopRequireDefault(require('./getWatermarks'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== 'function') return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var FAIL_COLOR = _chalk()["default"].bold.red;

var RUNNING_TEST_COLOR = _chalk()["default"].bold.dim;

var CoverageReporter =
/*#__PURE__*/
function (_BaseReporter$default) {
  _inherits(CoverageReporter, _BaseReporter$default);

  function CoverageReporter(globalConfig, options) {
    var _this;

    _classCallCheck(this, CoverageReporter);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(CoverageReporter).call(this));

    _defineProperty(_assertThisInitialized(_this), '_coverageMap', void 0);

    _defineProperty(_assertThisInitialized(_this), '_globalConfig', void 0);

    _defineProperty(_assertThisInitialized(_this), '_sourceMapStore', void 0);

    _defineProperty(_assertThisInitialized(_this), '_options', void 0);

    _defineProperty(_assertThisInitialized(_this), '_v8CoverageResults', void 0);

    _this._coverageMap = _istanbulLibCoverage()["default"].createCoverageMap({});
    _this._globalConfig = globalConfig;
    _this._sourceMapStore = _istanbulLibSourceMaps()["default"].createSourceMapStore();
    _this._v8CoverageResults = [];
    _this._options = options || {};
    return _this;
  }

  _createClass(CoverageReporter, [{
    key: "onTestResult",
    value: function onTestResult(_test, testResult) {
      if (testResult.v8Coverage) {
        this._v8CoverageResults.push(testResult.v8Coverage);

        return;
      }

      if (testResult.coverage) {
        this._coverageMap.merge(testResult.coverage);
      }
    }
  }, {
    key: "onRunComplete",
    value: function onRunComplete(contexts, aggregatedResults) {
      var _ref, map, reportContext, coverageReporters;

      return regeneratorRuntime.async(function onRunComplete$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return regeneratorRuntime.awrap(this._addUntestedFiles(contexts));

            case 2:
              _context.next = 4;
              return regeneratorRuntime.awrap(this._getCoverageResult());

            case 4:
              _ref = _context.sent;
              map = _ref.map;
              reportContext = _ref.reportContext;

              try {
                coverageReporters = this._globalConfig.coverageReporters || [];

                if (!this._globalConfig.useStderr && coverageReporters.length < 1) {
                  coverageReporters.push('text-summary');
                }

                coverageReporters.forEach(function (reporter) {
                  var additionalOptions = {};

                  if (Array.isArray(reporter)) {
                    var _reporter = reporter;

                    var _reporter2 = _slicedToArray(_reporter, 2);

                    reporter = _reporter2[0];
                    additionalOptions = _reporter2[1];
                  }

                  _istanbulReports()["default"].create(reporter, _objectSpread({
                    maxCols: process.stdout.columns || Infinity
                  }, additionalOptions)) // @ts-expect-error
                  .execute(reportContext);
                });
                aggregatedResults.coverageMap = map;
              } catch (e) {
                console.error(_chalk()["default"].red("\n        Failed to write coverage reports:\n        ERROR: ".concat(e.toString(), "\n        STACK: ").concat(e.stack, "\n      ")));
              }

              this._checkThreshold(map);

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "_addUntestedFiles",
    value: function _addUntestedFiles(contexts) {
      var _this2 = this;

      var files, worker, instrumentation;
      return regeneratorRuntime.async(function _addUntestedFiles$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              files = [];
              contexts.forEach(function (context) {
                var config = context.config;

                if (_this2._globalConfig.collectCoverageFrom && _this2._globalConfig.collectCoverageFrom.length) {
                  context.hasteFS.matchFilesWithGlob(_this2._globalConfig.collectCoverageFrom, config.rootDir).forEach(function (filePath) {
                    return files.push({
                      config: config,
                      path: filePath
                    });
                  });
                }
              });

              if (files.length) {
                _context3.next = 4;
                break;
              }

              return _context3.abrupt("return");

            case 4:
              if (_jestUtil().isInteractive) {
                process.stderr.write(RUNNING_TEST_COLOR('Running coverage on untested files...'));
              }

              if (this._globalConfig.maxWorkers <= 1) {
                worker = require('./CoverageWorker');
              } else {
                worker = new (_jestWorker()["default"])(require.resolve('./CoverageWorker'), {
                  exposedMethods: ['worker'],
                  maxRetries: 2,
                  numWorkers: this._globalConfig.maxWorkers
                });
              }

              instrumentation = files.map(function _callee(fileObj) {
                var filename, config, hasCoverageData, result;
                return regeneratorRuntime.async(function _callee$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        filename = fileObj.path;
                        config = fileObj.config;
                        hasCoverageData = _this2._v8CoverageResults.some(function (v8Res) {
                          return v8Res.some(function (innerRes) {
                            return innerRes.result.url === filename;
                          });
                        });

                        if (!(!hasCoverageData && !_this2._coverageMap.data[filename] && 'worker' in worker)) {
                          _context2.next = 14;
                          break;
                        }

                        _context2.prev = 4;
                        _context2.next = 7;
                        return regeneratorRuntime.awrap(worker.worker({
                          config: config,
                          globalConfig: _this2._globalConfig,
                          options: _objectSpread({}, _this2._options, {
                            changedFiles: _this2._options.changedFiles && Array.from(_this2._options.changedFiles),
                            sourcesRelatedToTestsInChangedFiles: _this2._options.sourcesRelatedToTestsInChangedFiles && Array.from(_this2._options.sourcesRelatedToTestsInChangedFiles)
                          }),
                          path: filename
                        }));

                      case 7:
                        result = _context2.sent;

                        if (result) {
                          if (result.kind === 'V8Coverage') {
                            _this2._v8CoverageResults.push([{
                              codeTransformResult: undefined,
                              result: result.result
                            }]);
                          } else {
                            _this2._coverageMap.addFileCoverage(result.coverage);
                          }
                        }

                        _context2.next = 14;
                        break;

                      case 11:
                        _context2.prev = 11;
                        _context2.t0 = _context2["catch"](4);
                        console.error(_chalk()["default"].red(["Failed to collect coverage from ".concat(filename), "ERROR: ".concat(_context2.t0.message), "STACK: ".concat(_context2.t0.stack)].join('\n')));

                      case 14:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, null, null, [[4, 11]]);
              });
              _context3.prev = 7;
              _context3.next = 10;
              return regeneratorRuntime.awrap(Promise.all(instrumentation));

            case 10:
              _context3.next = 14;
              break;

            case 12:
              _context3.prev = 12;
              _context3.t0 = _context3["catch"](7);

            case 14:
              if (_jestUtil().isInteractive) {
                (0, _jestUtil().clearLine)(process.stderr);
              }

              if (!(worker && 'end' in worker && typeof worker.end === 'function')) {
                _context3.next = 18;
                break;
              }

              _context3.next = 18;
              return regeneratorRuntime.awrap(worker.end());

            case 18:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this, [[7, 12]]);
    }
  }, {
    key: "_checkThreshold",
    value: function _checkThreshold(map) {
      var coverageThreshold = this._globalConfig.coverageThreshold;

      if (coverageThreshold) {
        var check = function check(name, thresholds, actuals) {
          return ['statements', 'branches', 'lines', 'functions'].reduce(function (errors, key) {
            var actual = actuals[key].pct;
            var actualUncovered = actuals[key].total - actuals[key].covered;
            var threshold = thresholds[key];

            if (threshold !== undefined) {
              if (threshold < 0) {
                if (threshold * -1 < actualUncovered) {
                  errors.push("Jest: Uncovered count for ".concat(key, " (").concat(actualUncovered, ") ") + "exceeds ".concat(name, " threshold (").concat(-1 * threshold, ")"));
                }
              } else if (actual < threshold) {
                errors.push("Jest: \"".concat(name, "\" coverage threshold for ").concat(key, " (").concat(threshold, "%) not met: ").concat(actual, "%"));
              }
            }

            return errors;
          }, []);
        };

        var combineCoverage = function combineCoverage(filePaths) {
          return filePaths.map(function (filePath) {
            return map.fileCoverageFor(filePath);
          }).reduce(function (combinedCoverage, nextFileCoverage) {
            if (combinedCoverage === undefined || combinedCoverage === null) {
              return nextFileCoverage.toSummary();
            }

            return combinedCoverage.merge(nextFileCoverage.toSummary());
          }, undefined);
        };

        var THRESHOLD_GROUP_TYPES = {
          GLOB: 'glob',
          GLOBAL: 'global',
          PATH: 'path'
        };
        var coveredFiles = map.files();
        var thresholdGroups = Object.keys(coverageThreshold);
        var groupTypeByThresholdGroup = {};
        var filesByGlob = {};
        var coveredFilesSortedIntoThresholdGroup = coveredFiles.reduce(function (files, file) {
          var pathOrGlobMatches = thresholdGroups.reduce(function (agg, thresholdGroup) {
            var absoluteThresholdGroup = path().resolve(thresholdGroup); // The threshold group might be a path:

            if (file.indexOf(absoluteThresholdGroup) === 0) {
              groupTypeByThresholdGroup[thresholdGroup] = THRESHOLD_GROUP_TYPES.PATH;
              return agg.concat([[file, thresholdGroup]]);
            } // If the threshold group is not a path it might be a glob:
            // Note: glob.sync is slow. By memoizing the files matching each glob
            // (rather than recalculating it for each covered file) we save a tonne
            // of execution time.


            if (filesByGlob[absoluteThresholdGroup] === undefined) {
              filesByGlob[absoluteThresholdGroup] = _glob()["default"].sync(absoluteThresholdGroup).map(function (filePath) {
                return path().resolve(filePath);
              });
            }

            if (filesByGlob[absoluteThresholdGroup].indexOf(file) > -1) {
              groupTypeByThresholdGroup[thresholdGroup] = THRESHOLD_GROUP_TYPES.GLOB;
              return agg.concat([[file, thresholdGroup]]);
            }

            return agg;
          }, []);

          if (pathOrGlobMatches.length > 0) {
            return files.concat(pathOrGlobMatches);
          } // Neither a glob or a path? Toss it in global if there's a global threshold:


          if (thresholdGroups.indexOf(THRESHOLD_GROUP_TYPES.GLOBAL) > -1) {
            groupTypeByThresholdGroup[THRESHOLD_GROUP_TYPES.GLOBAL] = THRESHOLD_GROUP_TYPES.GLOBAL;
            return files.concat([[file, THRESHOLD_GROUP_TYPES.GLOBAL]]);
          } // A covered file that doesn't have a threshold:


          return files.concat([[file, undefined]]);
        }, []);

        var getFilesInThresholdGroup = function getFilesInThresholdGroup(thresholdGroup) {
          return coveredFilesSortedIntoThresholdGroup.filter(function (fileAndGroup) {
            return fileAndGroup[1] === thresholdGroup;
          }).map(function (fileAndGroup) {
            return fileAndGroup[0];
          });
        };

        var errors = [];
        thresholdGroups.forEach(function (thresholdGroup) {
          switch (groupTypeByThresholdGroup[thresholdGroup]) {
            case THRESHOLD_GROUP_TYPES.GLOBAL:
              {
                var coverage = combineCoverage(getFilesInThresholdGroup(THRESHOLD_GROUP_TYPES.GLOBAL));

                if (coverage) {
                  errors = errors.concat(check(thresholdGroup, coverageThreshold[thresholdGroup], coverage));
                }

                break;
              }

            case THRESHOLD_GROUP_TYPES.PATH:
              {
                var _coverage = combineCoverage(getFilesInThresholdGroup(thresholdGroup));

                if (_coverage) {
                  errors = errors.concat(check(thresholdGroup, coverageThreshold[thresholdGroup], _coverage));
                }

                break;
              }

            case THRESHOLD_GROUP_TYPES.GLOB:
              getFilesInThresholdGroup(thresholdGroup).forEach(function (fileMatchingGlob) {
                errors = errors.concat(check(fileMatchingGlob, coverageThreshold[thresholdGroup], map.fileCoverageFor(fileMatchingGlob).toSummary()));
              });
              break;

            default:
              // If the file specified by path is not found, error is returned.
              if (thresholdGroup !== THRESHOLD_GROUP_TYPES.GLOBAL) {
                errors = errors.concat("Jest: Coverage data for ".concat(thresholdGroup, " was not found."));
              }

            // Sometimes all files in the coverage data are matched by
            // PATH and GLOB threshold groups in which case, don't error when
            // the global threshold group doesn't match any files.
          }
        });
        errors = errors.filter(function (err) {
          return err !== undefined && err !== null && err.length > 0;
        });

        if (errors.length > 0) {
          this.log("".concat(FAIL_COLOR(errors.join('\n'))));

          this._setError(new Error(errors.join('\n')));
        }
      }
    }
  }, {
    key: "_getCoverageResult",
    value: function _getCoverageResult() {
      var mergedCoverages, fileTransforms, transformedCoverage, _map, _reportContext, map, reportContext;

      return regeneratorRuntime.async(function _getCoverageResult$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (!(this._globalConfig.coverageProvider === 'v8')) {
                _context5.next = 11;
                break;
              }

              mergedCoverages = (0, _v8Coverage().mergeProcessCovs)(this._v8CoverageResults.map(function (cov) {
                return {
                  result: cov.map(function (r) {
                    return r.result;
                  })
                };
              }));
              fileTransforms = new Map();

              this._v8CoverageResults.forEach(function (res) {
                return res.forEach(function (r) {
                  if (r.codeTransformResult && !fileTransforms.has(r.result.url)) {
                    fileTransforms.set(r.result.url, r.codeTransformResult);
                  }
                });
              });

              _context5.next = 6;
              return regeneratorRuntime.awrap(Promise.all(mergedCoverages.result.map(function _callee2(res) {
                var _fileTransform$wrappe, fileTransform, sourcemapContent, converter;

                return regeneratorRuntime.async(function _callee2$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        fileTransform = fileTransforms.get(res.url);
                        sourcemapContent = undefined;

                        if (fileTransform && fileTransform.sourceMapPath && fs().existsSync(fileTransform.sourceMapPath)) {
                          sourcemapContent = JSON.parse(fs().readFileSync(fileTransform.sourceMapPath, 'utf8'));
                        }

                        converter = (0, _v8ToIstanbul()["default"])(res.url, (_fileTransform$wrappe = fileTransform === null || fileTransform === void 0 ? void 0 : fileTransform.wrapperLength) !== null && _fileTransform$wrappe !== void 0 ? _fileTransform$wrappe : 0, fileTransform && sourcemapContent ? {
                          originalSource: fileTransform.originalCode,
                          source: fileTransform.code,
                          sourceMap: {
                            sourcemap: sourcemapContent
                          }
                        } : {
                          source: fs().readFileSync(res.url, 'utf8')
                        });
                        _context4.next = 6;
                        return regeneratorRuntime.awrap(converter.load());

                      case 6:
                        converter.applyCoverage(res.functions);
                        return _context4.abrupt("return", converter.toIstanbul());

                      case 8:
                      case "end":
                        return _context4.stop();
                    }
                  }
                });
              })));

            case 6:
              transformedCoverage = _context5.sent;
              _map = _istanbulLibCoverage()["default"].createCoverageMap({});
              transformedCoverage.forEach(function (res) {
                return _map.merge(res);
              });
              _reportContext = _istanbulLibReport()["default"].createContext({
                coverageMap: _map,
                dir: this._globalConfig.coverageDirectory,
                watermarks: (0, _getWatermarks["default"])(this._globalConfig)
              });
              return _context5.abrupt("return", {
                map: _map,
                reportContext: _reportContext
              });

            case 11:
              _context5.next = 13;
              return regeneratorRuntime.awrap(this._sourceMapStore.transformCoverage(this._coverageMap));

            case 13:
              map = _context5.sent;
              reportContext = _istanbulLibReport()["default"].createContext({
                coverageMap: map,
                dir: this._globalConfig.coverageDirectory,
                sourceFinder: this._sourceMapStore.sourceFinder,
                watermarks: (0, _getWatermarks["default"])(this._globalConfig)
              });
              return _context5.abrupt("return", {
                map: map,
                reportContext: reportContext
              });

            case 16:
            case "end":
              return _context5.stop();
          }
        }
      }, null, this);
    }
  }]);

  return CoverageReporter;
}(_BaseReporter["default"]);

exports["default"] = CoverageReporter;