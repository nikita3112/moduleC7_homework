'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.runCLI = runCLI;

function _chalk() {
  var data = _interopRequireDefault(require('chalk'));

  _chalk = function _chalk() {
    return data;
  };

  return data;
}

function _exit() {
  var data = _interopRequireDefault(require('exit'));

  _exit = function _exit() {
    return data;
  };

  return data;
}

function _rimraf() {
  var data = _interopRequireDefault(require('rimraf'));

  _rimraf = function _rimraf() {
    return data;
  };

  return data;
}

function _console() {
  var data = require('@jest/console');

  _console = function _console() {
    return data;
  };

  return data;
}

function _jestConfig() {
  var data = require('jest-config');

  _jestConfig = function _jestConfig() {
    return data;
  };

  return data;
}

function _jestHasteMap() {
  var data = _interopRequireDefault(require('jest-haste-map'));

  _jestHasteMap = function _jestHasteMap() {
    return data;
  };

  return data;
}

function _jestRuntime() {
  var data = _interopRequireDefault(require('jest-runtime'));

  _jestRuntime = function _jestRuntime() {
    return data;
  };

  return data;
}

function _jestUtil() {
  var data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

function _TestWatcher() {
  var data = _interopRequireDefault(require('../TestWatcher'));

  _TestWatcher = function _TestWatcher() {
    return data;
  };

  return data;
}

function _collectHandles() {
  var data = require('../collectHandles');

  _collectHandles = function _collectHandles() {
    return data;
  };

  return data;
}

function _getChangedFilesPromise() {
  var data = _interopRequireDefault(require('../getChangedFilesPromise'));

  _getChangedFilesPromise = function _getChangedFilesPromise() {
    return data;
  };

  return data;
}

function _getConfigsOfProjectsToRun() {
  var data = _interopRequireDefault(require('../getConfigsOfProjectsToRun'));

  _getConfigsOfProjectsToRun = function _getConfigsOfProjectsToRun() {
    return data;
  };

  return data;
}

function _getProjectNamesMissingWarning() {
  var data = _interopRequireDefault(require('../getProjectNamesMissingWarning'));

  _getProjectNamesMissingWarning = function _getProjectNamesMissingWarning() {
    return data;
  };

  return data;
}

function _getSelectProjectsMessage() {
  var data = _interopRequireDefault(require('../getSelectProjectsMessage'));

  _getSelectProjectsMessage = function _getSelectProjectsMessage() {
    return data;
  };

  return data;
}

function _createContext() {
  var data = _interopRequireDefault(require('../lib/createContext'));

  _createContext = function _createContext() {
    return data;
  };

  return data;
}

function _handleDeprecationWarnings() {
  var data = _interopRequireDefault(require('../lib/handleDeprecationWarnings'));

  _handleDeprecationWarnings = function _handleDeprecationWarnings() {
    return data;
  };

  return data;
}

function _logDebugMessages() {
  var data = _interopRequireDefault(require('../lib/logDebugMessages'));

  _logDebugMessages = function _logDebugMessages() {
    return data;
  };

  return data;
}

function _pluralize() {
  var data = _interopRequireDefault(require('../pluralize'));

  _pluralize = function _pluralize() {
    return data;
  };

  return data;
}

function _runJest() {
  var data = _interopRequireDefault(require('../runJest'));

  _runJest = function _runJest() {
    return data;
  };

  return data;
}

function _watch() {
  var data = _interopRequireDefault(require('../watch'));

  _watch = function _watch() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var preRunMessagePrint = _jestUtil().preRunMessage.print;

function runCLI(argv, projects) {
  var results, outputStream, _ref, globalConfig, configs, hasDeprecationWarnings, configsOfProjectsToRun, namesMissingWarning, _results, openHandles, formatted, openHandlesString, message;

  return regeneratorRuntime.async(function runCLI$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          // If we output a JSON object, we can't write anything to stdout, since
          // it'll break the JSON structure and it won't be valid.
          outputStream = argv.json || argv.useStderr ? process.stderr : process.stdout;
          _context.next = 3;
          return regeneratorRuntime.awrap((0, _jestConfig().readConfigs)(argv, projects));

        case 3:
          _ref = _context.sent;
          globalConfig = _ref.globalConfig;
          configs = _ref.configs;
          hasDeprecationWarnings = _ref.hasDeprecationWarnings;

          if (argv.debug) {
            (0, _logDebugMessages()["default"])(globalConfig, configs, outputStream);
          }

          if (argv.showConfig) {
            (0, _logDebugMessages()["default"])(globalConfig, configs, process.stdout);
            (0, _exit()["default"])(0);
          }

          if (argv.clearCache) {
            configs.forEach(function (config) {
              _rimraf()["default"].sync(config.cacheDirectory);

              process.stdout.write("Cleared ".concat(config.cacheDirectory, "\n"));
            });
            (0, _exit()["default"])(0);
          }

          configsOfProjectsToRun = configs;

          if (argv.selectProjects) {
            namesMissingWarning = (0, _getProjectNamesMissingWarning()["default"])(configs);

            if (namesMissingWarning) {
              outputStream.write(namesMissingWarning);
            }

            configsOfProjectsToRun = (0, _getConfigsOfProjectsToRun()["default"])(argv.selectProjects, configs);
            outputStream.write((0, _getSelectProjectsMessage()["default"])(configsOfProjectsToRun));
          }

          _context.next = 14;
          return regeneratorRuntime.awrap(_run10000(globalConfig, configsOfProjectsToRun, hasDeprecationWarnings, outputStream, function (r) {
            return results = r;
          }));

        case 14:
          if (!(argv.watch || argv.watchAll)) {
            _context.next = 16;
            break;
          }

          return _context.abrupt("return", new Promise(function () {}));

        case 16:
          if (results) {
            _context.next = 18;
            break;
          }

          throw new Error('AggregatedResult must be present after test run is complete');

        case 18:
          _results = results, openHandles = _results.openHandles;

          if (openHandles && openHandles.length) {
            formatted = (0, _collectHandles().formatHandleErrors)(openHandles, configs[0]);
            openHandlesString = (0, _pluralize()["default"])('open handle', formatted.length, 's');
            message = _chalk()["default"].red("\nJest has detected the following ".concat(openHandlesString, " potentially keeping Jest from exiting:\n\n")) + formatted.join('\n\n');
            console.error(message);
          }

          return _context.abrupt("return", {
            globalConfig: globalConfig,
            results: results
          });

        case 21:
        case "end":
          return _context.stop();
      }
    }
  });
}

var buildContextsAndHasteMaps = function buildContextsAndHasteMaps(configs, globalConfig, outputStream) {
  var hasteMapInstances, contexts;
  return regeneratorRuntime.async(function buildContextsAndHasteMaps$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          hasteMapInstances = Array(configs.length);
          _context3.next = 3;
          return regeneratorRuntime.awrap(Promise.all(configs.map(function _callee(config, index) {
            var hasteMapInstance;
            return regeneratorRuntime.async(function _callee$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    (0, _jestUtil().createDirectory)(config.cacheDirectory);
                    hasteMapInstance = _jestRuntime()["default"].createHasteMap(config, {
                      console: new (_console().CustomConsole)(outputStream, outputStream),
                      maxWorkers: Math.max(1, Math.floor(globalConfig.maxWorkers / configs.length)),
                      resetCache: !config.cache,
                      watch: globalConfig.watch || globalConfig.watchAll,
                      watchman: globalConfig.watchman
                    });
                    hasteMapInstances[index] = hasteMapInstance;
                    _context2.t0 = (0, _createContext()["default"]);
                    _context2.t1 = config;
                    _context2.next = 7;
                    return regeneratorRuntime.awrap(hasteMapInstance.build());

                  case 7:
                    _context2.t2 = _context2.sent;
                    return _context2.abrupt("return", (0, _context2.t0)(_context2.t1, _context2.t2));

                  case 9:
                  case "end":
                    return _context2.stop();
                }
              }
            });
          })));

        case 3:
          contexts = _context3.sent;
          return _context3.abrupt("return", {
            contexts: contexts,
            hasteMapInstances: hasteMapInstances
          });

        case 5:
        case "end":
          return _context3.stop();
      }
    }
  });
};

var _run10000 = function _run10000(globalConfig, configs, hasDeprecationWarnings, outputStream, onComplete) {
  var changedFilesPromise, filter, rawFilter, filterSetupPromise, _ref2, contexts, hasteMapInstances;

  return regeneratorRuntime.async(function _run10000$(_context6) {
    while (1) {
      switch (_context6.prev = _context6.next) {
        case 0:
          // Queries to hg/git can take a while, so we need to start the process
          // as soon as possible, so by the time we need the result it's already there.
          changedFilesPromise = (0, _getChangedFilesPromise()["default"])(globalConfig, configs); // Filter may need to do an HTTP call or something similar to setup.
          // We will wait on an async response from this before using the filter.

          if (globalConfig.filter && !globalConfig.skipFilter) {
            rawFilter = require(globalConfig.filter);

            if (rawFilter.setup) {
              // Wrap filter setup Promise to avoid "uncaught Promise" error.
              // If an error is returned, we surface it in the return value.
              filterSetupPromise = function _callee2() {
                return regeneratorRuntime.async(function _callee2$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        _context4.prev = 0;
                        _context4.next = 3;
                        return regeneratorRuntime.awrap(rawFilter.setup());

                      case 3:
                        _context4.next = 8;
                        break;

                      case 5:
                        _context4.prev = 5;
                        _context4.t0 = _context4["catch"](0);
                        return _context4.abrupt("return", _context4.t0);

                      case 8:
                        return _context4.abrupt("return", undefined);

                      case 9:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, null, null, [[0, 5]]);
              }();
            }

            filter = function filter(testPaths) {
              var err;
              return regeneratorRuntime.async(function filter$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      if (!filterSetupPromise) {
                        _context5.next = 6;
                        break;
                      }

                      _context5.next = 3;
                      return regeneratorRuntime.awrap(filterSetupPromise);

                    case 3:
                      err = _context5.sent;

                      if (!err) {
                        _context5.next = 6;
                        break;
                      }

                      throw err;

                    case 6:
                      return _context5.abrupt("return", rawFilter(testPaths));

                    case 7:
                    case "end":
                      return _context5.stop();
                  }
                }
              });
            };
          }

          _context6.next = 4;
          return regeneratorRuntime.awrap(buildContextsAndHasteMaps(configs, globalConfig, outputStream));

        case 4:
          _ref2 = _context6.sent;
          contexts = _ref2.contexts;
          hasteMapInstances = _ref2.hasteMapInstances;

          if (!(globalConfig.watch || globalConfig.watchAll)) {
            _context6.next = 12;
            break;
          }

          _context6.next = 10;
          return regeneratorRuntime.awrap(runWatch(contexts, configs, hasDeprecationWarnings, globalConfig, outputStream, hasteMapInstances, filter));

        case 10:
          _context6.next = 14;
          break;

        case 12:
          _context6.next = 14;
          return regeneratorRuntime.awrap(runWithoutWatch(globalConfig, contexts, outputStream, onComplete, changedFilesPromise, filter));

        case 14:
        case "end":
          return _context6.stop();
      }
    }
  });
};

var runWatch = function runWatch(contexts, _configs, hasDeprecationWarnings, globalConfig, outputStream, hasteMapInstances, filter) {
  return regeneratorRuntime.async(function runWatch$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          if (!hasDeprecationWarnings) {
            _context7.next = 10;
            break;
          }

          _context7.prev = 1;
          _context7.next = 4;
          return regeneratorRuntime.awrap((0, _handleDeprecationWarnings()["default"])(outputStream, process.stdin));

        case 4:
          return _context7.abrupt("return", (0, _watch()["default"])(globalConfig, contexts, outputStream, hasteMapInstances, undefined, undefined, filter));

        case 7:
          _context7.prev = 7;
          _context7.t0 = _context7["catch"](1);
          (0, _exit()["default"])(0);

        case 10:
          return _context7.abrupt("return", (0, _watch()["default"])(globalConfig, contexts, outputStream, hasteMapInstances, undefined, undefined, filter));

        case 11:
        case "end":
          return _context7.stop();
      }
    }
  }, null, null, [[1, 7]]);
};

var runWithoutWatch = function runWithoutWatch(globalConfig, contexts, outputStream, onComplete, changedFilesPromise, filter) {
  var startRun;
  return regeneratorRuntime.async(function runWithoutWatch$(_context9) {
    while (1) {
      switch (_context9.prev = _context9.next) {
        case 0:
          startRun = function startRun() {
            return regeneratorRuntime.async(function startRun$(_context8) {
              while (1) {
                switch (_context8.prev = _context8.next) {
                  case 0:
                    if (!globalConfig.listTests) {
                      preRunMessagePrint(outputStream);
                    }

                    return _context8.abrupt("return", (0, _runJest()["default"])({
                      changedFilesPromise: changedFilesPromise,
                      contexts: contexts,
                      failedTestsCache: undefined,
                      filter: filter,
                      globalConfig: globalConfig,
                      onComplete: onComplete,
                      outputStream: outputStream,
                      startRun: startRun,
                      testWatcher: new (_TestWatcher()["default"])({
                        isWatchMode: false
                      })
                    }));

                  case 2:
                  case "end":
                    return _context8.stop();
                }
              }
            });
          };

          return _context9.abrupt("return", startRun());

        case 2:
        case "end":
          return _context9.stop();
      }
    }
  });
};