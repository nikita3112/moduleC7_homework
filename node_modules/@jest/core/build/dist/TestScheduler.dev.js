'use strict';

function _defineProperty2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

function _chalk() {
  var data = _interopRequireDefault(require('chalk'));

  _chalk = function _chalk() {
    return data;
  };

  return data;
}

function _exit() {
  var data = _interopRequireDefault(require('exit'));

  _exit = function _exit() {
    return data;
  };

  return data;
}

function _reporters() {
  var data = require('@jest/reporters');

  _reporters = function _reporters() {
    return data;
  };

  return data;
}

function _testResult() {
  var data = require('@jest/test-result');

  _testResult = function _testResult() {
    return data;
  };

  return data;
}

function _jestMessageUtil() {
  var data = require('jest-message-util');

  _jestMessageUtil = function _jestMessageUtil() {
    return data;
  };

  return data;
}

function _jestRunner() {
  var data = _interopRequireDefault(require('jest-runner'));

  _jestRunner = function _jestRunner() {
    return data;
  };

  return data;
}

function _jestSnapshot() {
  var data = _interopRequireDefault(require('jest-snapshot'));

  _jestSnapshot = function _jestSnapshot() {
    return data;
  };

  return data;
}

function _jestUtil() {
  var data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

var _ReporterDispatcher = _interopRequireDefault(require('./ReporterDispatcher'));

var _testSchedulerHelper = require('./testSchedulerHelper');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
} // The default jest-runner is required because it is the default test runner
// and required implicitly through the `runner` ProjectConfig option.


_jestRunner()["default"];

var TestScheduler =
/*#__PURE__*/
function () {
  function TestScheduler(globalConfig, options, context) {
    _classCallCheck(this, TestScheduler);

    _defineProperty(this, '_dispatcher', void 0);

    _defineProperty(this, '_globalConfig', void 0);

    _defineProperty(this, '_options', void 0);

    _defineProperty(this, '_context', void 0);

    this._dispatcher = new _ReporterDispatcher["default"]();
    this._globalConfig = globalConfig;
    this._options = options;
    this._context = context;

    this._setupReporters();
  }

  _createClass(TestScheduler, [{
    key: "addReporter",
    value: function addReporter(reporter) {
      this._dispatcher.register(reporter);
    }
  }, {
    key: "removeReporter",
    value: function removeReporter(ReporterClass) {
      this._dispatcher.unregister(ReporterClass);
    }
  }, {
    key: "scheduleTests",
    value: function scheduleTests(tests, watcher) {
      var _this = this;

      var onTestFileStart, timings, contexts, aggregatedResults, estimatedTime, runInBand, onResult, onFailure, updateSnapshotState, testRunners, contextsByTestRunner, testsByRunner, _loop, _i, _Object$keys, anyTestFailures, anyReporterErrors;

      return regeneratorRuntime.async(function scheduleTests$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              onTestFileStart = this._dispatcher.onTestFileStart.bind(this._dispatcher);
              timings = [];
              contexts = new Set();
              tests.forEach(function (test) {
                contexts.add(test.context);

                if (test.duration) {
                  timings.push(test.duration);
                }
              });
              aggregatedResults = createAggregatedResults(tests.length);
              estimatedTime = Math.ceil(getEstimatedTime(timings, this._globalConfig.maxWorkers) / 1000);
              runInBand = (0, _testSchedulerHelper.shouldRunInBand)(tests, timings, this._globalConfig);

              onResult = function onResult(test, testResult) {
                var message, _message;

                return regeneratorRuntime.async(function onResult$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        if (!watcher.isInterrupted()) {
                          _context.next = 2;
                          break;
                        }

                        return _context.abrupt("return", Promise.resolve());

                      case 2:
                        if (!(testResult.testResults.length === 0)) {
                          _context.next = 5;
                          break;
                        }

                        message = 'Your test suite must contain at least one test.';
                        return _context.abrupt("return", onFailure(test, {
                          message: message,
                          stack: new Error(message).stack
                        }));

                      case 5:
                        if (!testResult.leaks) {
                          _context.next = 8;
                          break;
                        }

                        _message = _chalk()["default"].red.bold('EXPERIMENTAL FEATURE!\n') + 'Your test suite is leaking memory. Please ensure all references are cleaned.\n' + '\n' + 'There is a number of things that can leak memory:\n' + '  - Async operations that have not finished (e.g. fs.readFile).\n' + '  - Timers not properly mocked (e.g. setInterval, setTimeout).\n' + '  - Keeping references to the global scope.';
                        return _context.abrupt("return", onFailure(test, {
                          message: _message,
                          stack: new Error(_message).stack
                        }));

                      case 8:
                        (0, _testResult().addResult)(aggregatedResults, testResult);
                        _context.next = 11;
                        return regeneratorRuntime.awrap(_this._dispatcher.onTestFileResult(test, testResult, aggregatedResults));

                      case 11:
                        return _context.abrupt("return", _this._bailIfNeeded(contexts, aggregatedResults, watcher));

                      case 12:
                      case "end":
                        return _context.stop();
                    }
                  }
                });
              };

              onFailure = function onFailure(test, error) {
                var testResult;
                return regeneratorRuntime.async(function onFailure$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        if (!watcher.isInterrupted()) {
                          _context2.next = 2;
                          break;
                        }

                        return _context2.abrupt("return");

                      case 2:
                        testResult = (0, _testResult().buildFailureTestResult)(test.path, error);
                        testResult.failureMessage = (0, _jestMessageUtil().formatExecError)(testResult.testExecError, test.context.config, _this._globalConfig, test.path);
                        (0, _testResult().addResult)(aggregatedResults, testResult);
                        _context2.next = 7;
                        return regeneratorRuntime.awrap(_this._dispatcher.onTestFileResult(test, testResult, aggregatedResults));

                      case 7:
                      case "end":
                        return _context2.stop();
                    }
                  }
                });
              };

              updateSnapshotState = function updateSnapshotState() {
                contexts.forEach(function (context) {
                  var status = _jestSnapshot()["default"].cleanup(context.hasteFS, _this._globalConfig.updateSnapshot, _jestSnapshot()["default"].buildSnapshotResolver(context.config), context.config.testPathIgnorePatterns);

                  aggregatedResults.snapshot.filesRemoved += status.filesRemoved;
                  aggregatedResults.snapshot.filesRemovedList = (aggregatedResults.snapshot.filesRemovedList || []).concat(status.filesRemovedList);
                });
                var updateAll = _this._globalConfig.updateSnapshot === 'all';
                aggregatedResults.snapshot.didUpdate = updateAll;
                aggregatedResults.snapshot.failure = !!(!updateAll && (aggregatedResults.snapshot.unchecked || aggregatedResults.snapshot.unmatched || aggregatedResults.snapshot.filesRemoved));
              };

              _context4.next = 12;
              return regeneratorRuntime.awrap(this._dispatcher.onRunStart(aggregatedResults, {
                estimatedTime: estimatedTime,
                showStatus: !runInBand
              }));

            case 12:
              testRunners = Object.create(null);
              contextsByTestRunner = new WeakMap();
              contexts.forEach(function (context) {
                var config = context.config;

                if (!testRunners[config.runner]) {
                  var _this$_context, _this$_context2;

                  var Runner = require(config.runner);

                  var runner = new Runner(_this._globalConfig, {
                    changedFiles: (_this$_context = _this._context) === null || _this$_context === void 0 ? void 0 : _this$_context.changedFiles,
                    sourcesRelatedToTestsInChangedFiles: (_this$_context2 = _this._context) === null || _this$_context2 === void 0 ? void 0 : _this$_context2.sourcesRelatedToTestsInChangedFiles
                  });
                  testRunners[config.runner] = runner;
                  contextsByTestRunner.set(runner, context);
                }
              });
              testsByRunner = this._partitionTests(testRunners, tests);

              if (!testsByRunner) {
                _context4.next = 32;
                break;
              }

              _context4.prev = 17;

              _loop = function _loop() {
                var runner, testRunner, context, tests, testRunnerOptions, unsubscribes;
                return regeneratorRuntime.async(function _loop$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        runner = _Object$keys[_i];
                        testRunner = testRunners[runner];
                        context = contextsByTestRunner.get(testRunner);
                        invariant(context);
                        tests = testsByRunner[runner];
                        testRunnerOptions = {
                          serial: runInBand || Boolean(testRunner.isSerial)
                        };
                        /**
                         * Test runners with event emitters are still not supported
                         * for third party test runners.
                         */

                        if (!testRunner.__PRIVATE_UNSTABLE_API_supportsEventEmitters__) {
                          _context3.next = 13;
                          break;
                        }

                        unsubscribes = [testRunner.on('test-file-start', function (_ref) {
                          var _ref2 = _slicedToArray(_ref, 1),
                              test = _ref2[0];

                          return onTestFileStart(test);
                        }), testRunner.on('test-file-success', function (_ref3) {
                          var _ref4 = _slicedToArray(_ref3, 2),
                              test = _ref4[0],
                              testResult = _ref4[1];

                          return onResult(test, testResult);
                        }), testRunner.on('test-file-failure', function (_ref5) {
                          var _ref6 = _slicedToArray(_ref5, 2),
                              test = _ref6[0],
                              error = _ref6[1];

                          return onFailure(test, error);
                        }), testRunner.on('test-case-result', function (_ref7) {
                          var _ref8 = _slicedToArray(_ref7, 2),
                              testPath = _ref8[0],
                              testCaseResult = _ref8[1];

                          var test = {
                            context: context,
                            path: testPath
                          };

                          _this._dispatcher.onTestCaseResult(test, testCaseResult);
                        })];
                        _context3.next = 10;
                        return regeneratorRuntime.awrap(testRunner.runTests(tests, watcher, undefined, undefined, undefined, testRunnerOptions));

                      case 10:
                        unsubscribes.forEach(function (sub) {
                          return sub();
                        });
                        _context3.next = 15;
                        break;

                      case 13:
                        _context3.next = 15;
                        return regeneratorRuntime.awrap(testRunner.runTests(tests, watcher, onTestFileStart, onResult, onFailure, testRunnerOptions));

                      case 15:
                      case "end":
                        return _context3.stop();
                    }
                  }
                });
              };

              _i = 0, _Object$keys = Object.keys(testRunners);

            case 20:
              if (!(_i < _Object$keys.length)) {
                _context4.next = 26;
                break;
              }

              _context4.next = 23;
              return regeneratorRuntime.awrap(_loop());

            case 23:
              _i++;
              _context4.next = 20;
              break;

            case 26:
              _context4.next = 32;
              break;

            case 28:
              _context4.prev = 28;
              _context4.t0 = _context4["catch"](17);

              if (watcher.isInterrupted()) {
                _context4.next = 32;
                break;
              }

              throw _context4.t0;

            case 32:
              updateSnapshotState();
              aggregatedResults.wasInterrupted = watcher.isInterrupted();
              _context4.next = 36;
              return regeneratorRuntime.awrap(this._dispatcher.onRunComplete(contexts, aggregatedResults));

            case 36:
              anyTestFailures = !(aggregatedResults.numFailedTests === 0 && aggregatedResults.numRuntimeErrorTestSuites === 0);
              anyReporterErrors = this._dispatcher.hasErrors();
              aggregatedResults.success = !(anyTestFailures || aggregatedResults.snapshot.failure || anyReporterErrors);
              return _context4.abrupt("return", aggregatedResults);

            case 40:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this, [[17, 28]]);
    }
  }, {
    key: "_partitionTests",
    value: function _partitionTests(testRunners, tests) {
      if (Object.keys(testRunners).length > 1) {
        return tests.reduce(function (testRuns, test) {
          var runner = test.context.config.runner;

          if (!testRuns[runner]) {
            testRuns[runner] = [];
          }

          testRuns[runner].push(test);
          return testRuns;
        }, Object.create(null));
      } else if (tests.length > 0 && tests[0] != null) {
        // If there is only one runner, don't partition the tests.
        return Object.assign(Object.create(null), _defineProperty2({}, tests[0].context.config.runner, tests));
      } else {
        return null;
      }
    }
  }, {
    key: "_shouldAddDefaultReporters",
    value: function _shouldAddDefaultReporters(reporters) {
      var _this2 = this;

      return !reporters || !!reporters.find(function (reporter) {
        return _this2._getReporterProps(reporter).path === 'default';
      });
    }
  }, {
    key: "_setupReporters",
    value: function _setupReporters() {
      var _this$_globalConfig = this._globalConfig,
          collectCoverage = _this$_globalConfig.collectCoverage,
          notify = _this$_globalConfig.notify,
          reporters = _this$_globalConfig.reporters;

      var isDefault = this._shouldAddDefaultReporters(reporters);

      if (isDefault) {
        this._setupDefaultReporters(collectCoverage);
      }

      if (!isDefault && collectCoverage) {
        var _this$_context3, _this$_context4;

        this.addReporter(new (_reporters().CoverageReporter)(this._globalConfig, {
          changedFiles: (_this$_context3 = this._context) === null || _this$_context3 === void 0 ? void 0 : _this$_context3.changedFiles,
          sourcesRelatedToTestsInChangedFiles: (_this$_context4 = this._context) === null || _this$_context4 === void 0 ? void 0 : _this$_context4.sourcesRelatedToTestsInChangedFiles
        }));
      }

      if (notify) {
        this.addReporter(new (_reporters().NotifyReporter)(this._globalConfig, this._options.startRun, this._context));
      }

      if (reporters && Array.isArray(reporters)) {
        this._addCustomReporters(reporters);
      }
    }
  }, {
    key: "_setupDefaultReporters",
    value: function _setupDefaultReporters(collectCoverage) {
      this.addReporter(this._globalConfig.verbose ? new (_reporters().VerboseReporter)(this._globalConfig) : new (_reporters().DefaultReporter)(this._globalConfig));

      if (collectCoverage) {
        var _this$_context5, _this$_context6;

        this.addReporter(new (_reporters().CoverageReporter)(this._globalConfig, {
          changedFiles: (_this$_context5 = this._context) === null || _this$_context5 === void 0 ? void 0 : _this$_context5.changedFiles,
          sourcesRelatedToTestsInChangedFiles: (_this$_context6 = this._context) === null || _this$_context6 === void 0 ? void 0 : _this$_context6.sourcesRelatedToTestsInChangedFiles
        }));
      }

      this.addReporter(new (_reporters().SummaryReporter)(this._globalConfig));
    }
  }, {
    key: "_addCustomReporters",
    value: function _addCustomReporters(reporters) {
      var _this3 = this;

      reporters.forEach(function (reporter) {
        var _this3$_getReporterPr = _this3._getReporterProps(reporter),
            options = _this3$_getReporterPr.options,
            path = _this3$_getReporterPr.path;

        if (path === 'default') return;

        try {
          // TODO: Use `requireAndTranspileModule` for Jest 26
          var Reporter = (0, _jestUtil().interopRequireDefault)(require(path))["default"];

          _this3.addReporter(new Reporter(_this3._globalConfig, options));
        } catch (error) {
          error.message = 'An error occurred while adding the reporter at path "' + _chalk()["default"].bold(path) + '".' + error.message;
          throw error;
        }
      });
    }
    /**
     * Get properties of a reporter in an object
     * to make dealing with them less painful.
     */

  }, {
    key: "_getReporterProps",
    value: function _getReporterProps(reporter) {
      if (typeof reporter === 'string') {
        return {
          options: this._options,
          path: reporter
        };
      } else if (Array.isArray(reporter)) {
        var _reporter = _slicedToArray(reporter, 2),
            path = _reporter[0],
            options = _reporter[1];

        return {
          options: options,
          path: path
        };
      }

      throw new Error('Reporter should be either a string or an array');
    }
  }, {
    key: "_bailIfNeeded",
    value: function _bailIfNeeded(contexts, aggregatedResults, watcher) {
      if (this._globalConfig.bail !== 0 && aggregatedResults.numFailedTests >= this._globalConfig.bail) {
        if (watcher.isWatchMode()) {
          watcher.setState({
            interrupted: true
          });
        } else {
          var failureExit = function failureExit() {
            return (0, _exit()["default"])(1);
          };

          return this._dispatcher.onRunComplete(contexts, aggregatedResults).then(failureExit)["catch"](failureExit);
        }
      }

      return Promise.resolve();
    }
  }]);

  return TestScheduler;
}();

exports["default"] = TestScheduler;

function invariant(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}

var createAggregatedResults = function createAggregatedResults(numTotalTestSuites) {
  var result = (0, _testResult().makeEmptyAggregatedTestResult)();
  result.numTotalTestSuites = numTotalTestSuites;
  result.startTime = Date.now();
  result.success = false;
  return result;
};

var getEstimatedTime = function getEstimatedTime(timings, workers) {
  if (!timings.length) {
    return 0;
  }

  var max = Math.max.apply(null, timings);
  return timings.length <= workers ? max : Math.max(timings.reduce(function (sum, time) {
    return sum + time;
  }) / workers, max);
};