'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

function os() {
  var data = _interopRequireWildcard(require('os'));

  os = function os() {
    return data;
  };

  return data;
}

function path() {
  var data = _interopRequireWildcard(require('path'));

  path = function path() {
    return data;
  };

  return data;
}

function _micromatch() {
  var data = _interopRequireDefault(require('micromatch'));

  _micromatch = function _micromatch() {
    return data;
  };

  return data;
}

function _jestConfig() {
  var data = require('jest-config');

  _jestConfig = function _jestConfig() {
    return data;
  };

  return data;
}

function _jestRegexUtil() {
  var data = require('jest-regex-util');

  _jestRegexUtil = function _jestRegexUtil() {
    return data;
  };

  return data;
}

function _jestResolveDependencies() {
  var data = _interopRequireDefault(require('jest-resolve-dependencies'));

  _jestResolveDependencies = function _jestResolveDependencies() {
    return data;
  };

  return data;
}

function _jestSnapshot() {
  var data = require('jest-snapshot');

  _jestSnapshot = function _jestSnapshot() {
    return data;
  };

  return data;
}

function _jestUtil() {
  var data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== 'function') return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var regexToMatcher = function regexToMatcher(testRegex) {
  var regexes = testRegex.map(function (testRegex) {
    return new RegExp(testRegex);
  });
  return function (path) {
    return regexes.some(function (regex) {
      var result = regex.test(path); // prevent stateful regexes from breaking, just in case

      regex.lastIndex = 0;
      return result;
    });
  };
};

var toTests = function toTests(context, tests) {
  return tests.map(function (path) {
    return {
      context: context,
      duration: undefined,
      path: path
    };
  });
};

var hasSCM = function hasSCM(changedFilesInfo) {
  var repos = changedFilesInfo.repos; // no SCM (git/hg/...) is found in any of the roots.

  var noSCM = Object.values(repos).every(function (scm) {
    return scm.size === 0;
  });
  return !noSCM;
};

var SearchSource =
/*#__PURE__*/
function () {
  function SearchSource(context) {
    _classCallCheck(this, SearchSource);

    _defineProperty(this, '_context', void 0);

    _defineProperty(this, '_dependencyResolver', void 0);

    _defineProperty(this, '_testPathCases', []);

    var config = context.config;
    this._context = context;
    this._dependencyResolver = null;
    var rootPattern = new RegExp(config.roots.map(function (dir) {
      return (0, _jestRegexUtil().escapePathForRegex)(dir + path().sep);
    }).join('|'));

    this._testPathCases.push({
      isMatch: function isMatch(path) {
        return rootPattern.test(path);
      },
      stat: 'roots'
    });

    if (config.testMatch.length) {
      this._testPathCases.push({
        isMatch: (0, _jestUtil().globsToMatcher)(config.testMatch),
        stat: 'testMatch'
      });
    }

    if (config.testPathIgnorePatterns.length) {
      var testIgnorePatternsRegex = new RegExp(config.testPathIgnorePatterns.join('|'));

      this._testPathCases.push({
        isMatch: function isMatch(path) {
          return !testIgnorePatternsRegex.test(path);
        },
        stat: 'testPathIgnorePatterns'
      });
    }

    if (config.testRegex.length) {
      this._testPathCases.push({
        isMatch: regexToMatcher(config.testRegex),
        stat: 'testRegex'
      });
    }
  }

  _createClass(SearchSource, [{
    key: "_getOrBuildDependencyResolver",
    value: function _getOrBuildDependencyResolver() {
      if (!this._dependencyResolver) {
        this._dependencyResolver = new (_jestResolveDependencies()["default"])(this._context.resolver, this._context.hasteFS, (0, _jestSnapshot().buildSnapshotResolver)(this._context.config));
      }

      return this._dependencyResolver;
    }
  }, {
    key: "_filterTestPathsWithStats",
    value: function _filterTestPathsWithStats(allPaths, testPathPattern) {
      var data = {
        stats: {
          roots: 0,
          testMatch: 0,
          testPathIgnorePatterns: 0,
          testRegex: 0
        },
        tests: [],
        total: allPaths.length
      };
      var testCases = Array.from(this._testPathCases); // clone

      if (testPathPattern) {
        var regex = (0, _jestUtil().testPathPatternToRegExp)(testPathPattern);
        testCases.push({
          isMatch: function isMatch(path) {
            return regex.test(path);
          },
          stat: 'testPathPattern'
        });
        data.stats.testPathPattern = 0;
      }

      data.tests = allPaths.filter(function (test) {
        var filterResult = true;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = testCases[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = _step.value,
                isMatch = _step$value.isMatch,
                stat = _step$value.stat;

            if (isMatch(test.path)) {
              data.stats[stat]++;
            } else {
              filterResult = false;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return filterResult;
      });
      return data;
    }
  }, {
    key: "_getAllTestPaths",
    value: function _getAllTestPaths(testPathPattern) {
      return this._filterTestPathsWithStats(toTests(this._context, this._context.hasteFS.getAllFiles()), testPathPattern);
    }
  }, {
    key: "isTestFilePath",
    value: function isTestFilePath(path) {
      return this._testPathCases.every(function (testCase) {
        return testCase.isMatch(path);
      });
    }
  }, {
    key: "findMatchingTests",
    value: function findMatchingTests(testPathPattern) {
      return this._getAllTestPaths(testPathPattern);
    }
  }, {
    key: "findRelatedTests",
    value: function findRelatedTests(allPaths, collectCoverage) {
      var _this = this;

      var dependencyResolver = this._getOrBuildDependencyResolver();

      if (!collectCoverage) {
        return {
          tests: toTests(this._context, dependencyResolver.resolveInverse(allPaths, this.isTestFilePath.bind(this), {
            skipNodeResolution: this._context.config.skipNodeResolution
          }))
        };
      }

      var testModulesMap = dependencyResolver.resolveInverseModuleMap(allPaths, this.isTestFilePath.bind(this), {
        skipNodeResolution: this._context.config.skipNodeResolution
      });
      var allPathsAbsolute = Array.from(allPaths).map(function (p) {
        return path().resolve(p);
      });
      var collectCoverageFrom = new Set();
      testModulesMap.forEach(function (testModule) {
        if (!testModule.dependencies) {
          return;
        }

        testModule.dependencies.forEach(function (p) {
          if (!allPathsAbsolute.includes(p)) {
            return;
          }

          var filename = (0, _jestConfig().replaceRootDirInPath)(_this._context.config.rootDir, p);
          collectCoverageFrom.add(path().isAbsolute(filename) ? path().relative(_this._context.config.rootDir, filename) : filename);
        });
      });
      return {
        collectCoverageFrom: collectCoverageFrom,
        tests: toTests(this._context, testModulesMap.map(function (testModule) {
          return testModule.file;
        }))
      };
    }
  }, {
    key: "findTestsByPaths",
    value: function findTestsByPaths(paths) {
      var _this2 = this;

      return {
        tests: toTests(this._context, paths.map(function (p) {
          return path().resolve(_this2._context.config.cwd, p);
        }).filter(this.isTestFilePath.bind(this)))
      };
    }
  }, {
    key: "findRelatedTestsFromPattern",
    value: function findRelatedTestsFromPattern(paths, collectCoverage) {
      var _this3 = this;

      if (Array.isArray(paths) && paths.length) {
        var resolvedPaths = paths.map(function (p) {
          return path().resolve(_this3._context.config.cwd, p);
        });
        return this.findRelatedTests(new Set(resolvedPaths), collectCoverage);
      }

      return {
        tests: []
      };
    }
  }, {
    key: "findTestRelatedToChangedFiles",
    value: function findTestRelatedToChangedFiles(changedFilesInfo, collectCoverage) {
      if (!hasSCM(changedFilesInfo)) {
        return {
          noSCM: true,
          tests: []
        };
      }

      var changedFiles = changedFilesInfo.changedFiles;
      return this.findRelatedTests(changedFiles, collectCoverage);
    }
  }, {
    key: "_getTestPaths",
    value: function _getTestPaths(globalConfig, changedFiles) {
      var _this4 = this;

      if (globalConfig.onlyChanged) {
        if (!changedFiles) {
          throw new Error('Changed files must be set when running with -o.');
        }

        return this.findTestRelatedToChangedFiles(changedFiles, globalConfig.collectCoverage);
      }

      var paths = globalConfig.nonFlagArgs;

      if (globalConfig.findRelatedTests && 'win32' === os().platform()) {
        var allFiles = this._context.hasteFS.getAllFiles();

        var options = {
          nocase: true,
          windows: false
        };
        paths = paths.map(function (p) {
          var relativePath = path().resolve(_this4._context.config.cwd, p).replace(/\\/g, '\\\\');
          var match = (0, _micromatch()["default"])(allFiles, relativePath, options);
          return match[0];
        }).filter(Boolean);
      }

      if (globalConfig.runTestsByPath && paths && paths.length) {
        return this.findTestsByPaths(paths);
      } else if (globalConfig.findRelatedTests && paths && paths.length) {
        return this.findRelatedTestsFromPattern(paths, globalConfig.collectCoverage);
      } else if (globalConfig.testPathPattern != null) {
        return this.findMatchingTests(globalConfig.testPathPattern);
      } else {
        return {
          tests: []
        };
      }
    }
  }, {
    key: "getTestPaths",
    value: function getTestPaths(globalConfig, changedFiles, filter) {
      var searchResult, filterPath, tests, filterResult, filteredSet;
      return regeneratorRuntime.async(function getTestPaths$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              searchResult = this._getTestPaths(globalConfig, changedFiles);
              filterPath = globalConfig.filter;

              if (!filter) {
                _context.next = 11;
                break;
              }

              tests = searchResult.tests;
              _context.next = 6;
              return regeneratorRuntime.awrap(filter(tests.map(function (test) {
                return test.path;
              })));

            case 6:
              filterResult = _context.sent;

              if (Array.isArray(filterResult.filtered)) {
                _context.next = 9;
                break;
              }

              throw new Error("Filter ".concat(filterPath, " did not return a valid test list"));

            case 9:
              filteredSet = new Set(filterResult.filtered.map(function (result) {
                return result.test;
              }));
              return _context.abrupt("return", _objectSpread({}, searchResult, {
                tests: tests.filter(function (test) {
                  return filteredSet.has(test.path);
                })
              }));

            case 11:
              return _context.abrupt("return", searchResult);

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "findRelatedSourcesFromTestsInChangedFiles",
    value: function findRelatedSourcesFromTestsInChangedFiles(changedFilesInfo) {
      var _this5 = this;

      if (!hasSCM(changedFilesInfo)) {
        return [];
      }

      var changedFiles = changedFilesInfo.changedFiles;

      var dependencyResolver = this._getOrBuildDependencyResolver();

      var relatedSourcesSet = new Set();
      changedFiles.forEach(function (filePath) {
        if (_this5.isTestFilePath(filePath)) {
          var sourcePaths = dependencyResolver.resolve(filePath, {
            skipNodeResolution: _this5._context.config.skipNodeResolution
          });
          sourcePaths.forEach(function (sourcePath) {
            return relatedSourcesSet.add(sourcePath);
          });
        }
      });
      return Array.from(relatedSourcesSet);
    }
  }]);

  return SearchSource;
}();

exports["default"] = SearchSource;