'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = runJest;

function path() {
  var data = _interopRequireWildcard(require('path'));

  path = function path() {
    return data;
  };

  return data;
}

function _chalk() {
  var data = _interopRequireDefault(require('chalk'));

  _chalk = function _chalk() {
    return data;
  };

  return data;
}

function _exit() {
  var data = _interopRequireDefault(require('exit'));

  _exit = function _exit() {
    return data;
  };

  return data;
}

function fs() {
  var data = _interopRequireWildcard(require('graceful-fs'));

  fs = function fs() {
    return data;
  };

  return data;
}

function _console() {
  var data = require('@jest/console');

  _console = function _console() {
    return data;
  };

  return data;
}

function _testResult() {
  var data = require('@jest/test-result');

  _testResult = function _testResult() {
    return data;
  };

  return data;
}

function _jestUtil() {
  var data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

function _jestWatcher() {
  var data = require('jest-watcher');

  _jestWatcher = function _jestWatcher() {
    return data;
  };

  return data;
}

var _SearchSource = _interopRequireDefault(require('./SearchSource'));

var _TestScheduler = _interopRequireDefault(require('./TestScheduler'));

var _collectHandles = _interopRequireDefault(require('./collectHandles'));

var _getNoTestsFoundMessage = _interopRequireDefault(require('./getNoTestsFoundMessage'));

var _runGlobalHook = _interopRequireDefault(require('./runGlobalHook'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== 'function') return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var getTestPaths = function getTestPaths(globalConfig, source, outputStream, changedFiles, jestHooks, filter) {
  var data, shouldTestArray, filteredTests;
  return regeneratorRuntime.async(function getTestPaths$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return regeneratorRuntime.awrap(source.getTestPaths(globalConfig, changedFiles, filter));

        case 2:
          data = _context.sent;

          if (!data.tests.length && globalConfig.onlyChanged && data.noSCM) {
            new (_console().CustomConsole)(outputStream, outputStream).log('Jest can only find uncommitted changed files in a git or hg ' + 'repository. If you make your project a git or hg ' + 'repository (`git init` or `hg init`), Jest will be able ' + 'to only run tests related to files changed since the last ' + 'commit.');
          }

          _context.next = 6;
          return regeneratorRuntime.awrap(Promise.all(data.tests.map(function (test) {
            return jestHooks.shouldRunTestSuite({
              config: test.context.config,
              duration: test.duration,
              testPath: test.path
            });
          })));

        case 6:
          shouldTestArray = _context.sent;
          filteredTests = data.tests.filter(function (_test, i) {
            return shouldTestArray[i];
          });
          return _context.abrupt("return", _objectSpread({}, data, {
            allTests: filteredTests.length,
            tests: filteredTests
          }));

        case 9:
        case "end":
          return _context.stop();
      }
    }
  });
};

var processResults = function processResults(runResults, options) {
  var outputFile = options.outputFile,
      isJSON = options.json,
      onComplete = options.onComplete,
      outputStream = options.outputStream,
      testResultsProcessor = options.testResultsProcessor,
      collectHandles = options.collectHandles;

  if (collectHandles) {
    runResults.openHandles = collectHandles();
  } else {
    runResults.openHandles = [];
  }

  if (testResultsProcessor) {
    runResults = require(testResultsProcessor)(runResults);
  }

  if (isJSON) {
    if (outputFile) {
      var cwd = (0, _jestUtil().tryRealpath)(process.cwd());
      var filePath = path().resolve(cwd, outputFile);
      fs().writeFileSync(filePath, JSON.stringify((0, _testResult().formatTestResults)(runResults)));
      outputStream.write("Test results written to: ".concat(path().relative(cwd, filePath), "\n"));
    } else {
      process.stdout.write(JSON.stringify((0, _testResult().formatTestResults)(runResults)));
    }
  }

  return onComplete && onComplete(runResults);
};

var testSchedulerContext = {
  firstRun: true,
  previousSuccess: true
};

function runJest(_ref) {
  var contexts, globalConfig, outputStream, testWatcher, _ref$jestHooks, jestHooks, startRun, changedFilesPromise, onComplete, failedTestsCache, filter, Sequencer, sequencer, allTests, _ref2, repos, noSCM, searchSources, testRunData, testsPaths, hasTests, noTestsFoundMessage, newConfig, collectHandles, changedFilesInfo, sourcesRelatedToTestsInChangedFilesArray, results;

  return regeneratorRuntime.async(function runJest$(_context3) {
    while (1) {
      switch (_context3.prev = _context3.next) {
        case 0:
          contexts = _ref.contexts, globalConfig = _ref.globalConfig, outputStream = _ref.outputStream, testWatcher = _ref.testWatcher, _ref$jestHooks = _ref.jestHooks, jestHooks = _ref$jestHooks === void 0 ? new (_jestWatcher().JestHook)().getEmitter() : _ref$jestHooks, startRun = _ref.startRun, changedFilesPromise = _ref.changedFilesPromise, onComplete = _ref.onComplete, failedTestsCache = _ref.failedTestsCache, filter = _ref.filter;
          Sequencer = (0, _jestUtil().interopRequireDefault)(require(globalConfig.testSequencer))["default"];
          sequencer = new Sequencer();
          allTests = [];

          if (!(changedFilesPromise && globalConfig.watch)) {
            _context3.next = 11;
            break;
          }

          _context3.next = 7;
          return regeneratorRuntime.awrap(changedFilesPromise);

        case 7:
          _ref2 = _context3.sent;
          repos = _ref2.repos;
          noSCM = Object.keys(repos).every(function (scm) {
            return repos[scm].size === 0;
          });

          if (noSCM) {
            process.stderr.write('\n' + _chalk()["default"].bold('--watch') + ' is not supported without git/hg, please use --watchAll ' + '\n');
            (0, _exit()["default"])(1);
          }

        case 11:
          searchSources = contexts.map(function (context) {
            return new _SearchSource["default"](context);
          });
          _context3.next = 14;
          return regeneratorRuntime.awrap(Promise.all(contexts.map(function _callee(context, index) {
            var searchSource, matches;
            return regeneratorRuntime.async(function _callee$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    searchSource = searchSources[index];
                    _context2.t0 = regeneratorRuntime;
                    _context2.t1 = getTestPaths;
                    _context2.t2 = globalConfig;
                    _context2.t3 = searchSource;
                    _context2.t4 = outputStream;
                    _context2.t5 = changedFilesPromise;

                    if (!_context2.t5) {
                      _context2.next = 11;
                      break;
                    }

                    _context2.next = 10;
                    return regeneratorRuntime.awrap(changedFilesPromise);

                  case 10:
                    _context2.t5 = _context2.sent;

                  case 11:
                    _context2.t6 = _context2.t5;
                    _context2.t7 = jestHooks;
                    _context2.t8 = filter;
                    _context2.t9 = (0, _context2.t1)(_context2.t2, _context2.t3, _context2.t4, _context2.t6, _context2.t7, _context2.t8);
                    _context2.next = 17;
                    return _context2.t0.awrap.call(_context2.t0, _context2.t9);

                  case 17:
                    matches = _context2.sent;
                    allTests = allTests.concat(matches.tests);
                    return _context2.abrupt("return", {
                      context: context,
                      matches: matches
                    });

                  case 20:
                  case "end":
                    return _context2.stop();
                }
              }
            });
          })));

        case 14:
          testRunData = _context3.sent;
          _context3.next = 17;
          return regeneratorRuntime.awrap(sequencer.sort(allTests));

        case 17:
          allTests = _context3.sent;

          if (!globalConfig.listTests) {
            _context3.next = 23;
            break;
          }

          testsPaths = Array.from(new Set(allTests.map(function (test) {
            return test.path;
          })));

          if (globalConfig.json) {
            console.log(JSON.stringify(testsPaths));
          } else {
            console.log(testsPaths.join('\n'));
          }

          onComplete && onComplete((0, _testResult().makeEmptyAggregatedTestResult)());
          return _context3.abrupt("return");

        case 23:
          if (globalConfig.onlyFailures) {
            if (failedTestsCache) {
              allTests = failedTestsCache.filterTests(allTests);
              globalConfig = failedTestsCache.updateConfig(globalConfig);
            } else {
              allTests = sequencer.allFailedTests(allTests);
            }
          }

          hasTests = allTests.length > 0;

          if (!hasTests) {
            noTestsFoundMessage = (0, _getNoTestsFoundMessage["default"])(testRunData, globalConfig);

            if (globalConfig.passWithNoTests || globalConfig.findRelatedTests || globalConfig.lastCommit || globalConfig.onlyChanged) {
              new (_console().CustomConsole)(outputStream, outputStream).log(noTestsFoundMessage);
            } else {
              new (_console().CustomConsole)(outputStream, outputStream).error(noTestsFoundMessage);
              (0, _exit()["default"])(1);
            }
          } else if (allTests.length === 1 && globalConfig.silent !== true && globalConfig.verbose !== false) {
            newConfig = _objectSpread({}, globalConfig, {
              verbose: true
            });
            globalConfig = Object.freeze(newConfig);
          }

          if (globalConfig.detectOpenHandles) {
            collectHandles = (0, _collectHandles["default"])();
          }

          if (!hasTests) {
            _context3.next = 30;
            break;
          }

          _context3.next = 30;
          return regeneratorRuntime.awrap((0, _runGlobalHook["default"])({
            allTests: allTests,
            globalConfig: globalConfig,
            moduleName: 'globalSetup'
          }));

        case 30:
          if (!changedFilesPromise) {
            _context3.next = 35;
            break;
          }

          _context3.next = 33;
          return regeneratorRuntime.awrap(changedFilesPromise);

        case 33:
          changedFilesInfo = _context3.sent;

          if (changedFilesInfo.changedFiles) {
            testSchedulerContext.changedFiles = changedFilesInfo.changedFiles;
            sourcesRelatedToTestsInChangedFilesArray = contexts.map(function (_, index) {
              var searchSource = searchSources[index];
              var relatedSourceFromTestsInChangedFiles = searchSource.findRelatedSourcesFromTestsInChangedFiles(changedFilesInfo);
              return relatedSourceFromTestsInChangedFiles;
            }).reduce(function (total, paths) {
              return total.concat(paths);
            }, []);
            testSchedulerContext.sourcesRelatedToTestsInChangedFiles = new Set(sourcesRelatedToTestsInChangedFilesArray);
          }

        case 35:
          _context3.next = 37;
          return regeneratorRuntime.awrap(new _TestScheduler["default"](globalConfig, {
            startRun: startRun
          }, testSchedulerContext).scheduleTests(allTests, testWatcher));

        case 37:
          results = _context3.sent;
          sequencer.cacheResults(allTests, results);

          if (!hasTests) {
            _context3.next = 42;
            break;
          }

          _context3.next = 42;
          return regeneratorRuntime.awrap((0, _runGlobalHook["default"])({
            allTests: allTests,
            globalConfig: globalConfig,
            moduleName: 'globalTeardown'
          }));

        case 42:
          _context3.next = 44;
          return regeneratorRuntime.awrap(processResults(results, {
            collectHandles: collectHandles,
            json: globalConfig.json,
            onComplete: onComplete,
            outputFile: globalConfig.outputFile,
            outputStream: outputStream,
            testResultsProcessor: globalConfig.testResultsProcessor
          }));

        case 44:
        case "end":
          return _context3.stop();
      }
    }
  });
}