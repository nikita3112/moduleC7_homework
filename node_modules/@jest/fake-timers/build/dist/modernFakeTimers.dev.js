'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

function _fakeTimers() {
  var data = require('@sinonjs/fake-timers');

  _fakeTimers = function _fakeTimers() {
    return data;
  };

  return data;
}

function _jestMessageUtil() {
  var data = require('jest-message-util');

  _jestMessageUtil = function _jestMessageUtil() {
    return data;
  };

  return data;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var FakeTimers =
/*#__PURE__*/
function () {
  function FakeTimers(_ref) {
    var global = _ref.global,
        config = _ref.config,
        maxLoops = _ref.maxLoops;

    _classCallCheck(this, FakeTimers);

    _defineProperty(this, '_clock', void 0);

    _defineProperty(this, '_config', void 0);

    _defineProperty(this, '_fakingTime', void 0);

    _defineProperty(this, '_global', void 0);

    _defineProperty(this, '_fakeTimers', void 0);

    _defineProperty(this, '_maxLoops', void 0);

    this._global = global;
    this._config = config;
    this._maxLoops = maxLoops || 100000;
    this._fakingTime = false;
    this._fakeTimers = (0, _fakeTimers().withGlobal)(global);
  }

  _createClass(FakeTimers, [{
    key: "clearAllTimers",
    value: function clearAllTimers() {
      if (this._fakingTime) {
        this._clock.reset();
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.useRealTimers();
    }
  }, {
    key: "runAllTimers",
    value: function runAllTimers() {
      if (this._checkFakeTimers()) {
        this._clock.runAll();
      }
    }
  }, {
    key: "runOnlyPendingTimers",
    value: function runOnlyPendingTimers() {
      if (this._checkFakeTimers()) {
        this._clock.runToLast();
      }
    }
  }, {
    key: "advanceTimersToNextTimer",
    value: function advanceTimersToNextTimer() {
      var steps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      if (this._checkFakeTimers()) {
        for (var i = steps; i > 0; i--) {
          this._clock.next(); // Fire all timers at this point: https://github.com/sinonjs/fake-timers/issues/250


          this._clock.tick(0);

          if (this._clock.countTimers() === 0) {
            break;
          }
        }
      }
    }
  }, {
    key: "advanceTimersByTime",
    value: function advanceTimersByTime(msToRun) {
      if (this._checkFakeTimers()) {
        this._clock.tick(msToRun);
      }
    }
  }, {
    key: "runAllTicks",
    value: function runAllTicks() {
      if (this._checkFakeTimers()) {
        // @ts-expect-error
        this._clock.runMicrotasks();
      }
    }
  }, {
    key: "useRealTimers",
    value: function useRealTimers() {
      if (this._fakingTime) {
        this._clock.uninstall();

        this._fakingTime = false;
      }
    }
  }, {
    key: "useFakeTimers",
    value: function useFakeTimers() {
      if (!this._fakingTime) {
        var toFake = Object.keys(this._fakeTimers.timers);
        this._clock = this._fakeTimers.install({
          loopLimit: this._maxLoops,
          now: Date.now(),
          target: this._global,
          toFake: toFake
        });
        this._fakingTime = true;
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      if (this._checkFakeTimers()) {
        var now = this._clock.now;

        this._clock.reset();

        this._clock.setSystemTime(now);
      }
    }
  }, {
    key: "setSystemTime",
    value: function setSystemTime(now) {
      if (this._checkFakeTimers()) {
        this._clock.setSystemTime(now);
      }
    }
  }, {
    key: "getRealSystemTime",
    value: function getRealSystemTime() {
      return Date.now();
    }
  }, {
    key: "getTimerCount",
    value: function getTimerCount() {
      if (this._checkFakeTimers()) {
        return this._clock.countTimers();
      }

      return 0;
    }
  }, {
    key: "_checkFakeTimers",
    value: function _checkFakeTimers() {
      if (!this._fakingTime) {
        this._global.console.warn('A function to advance timers was called but the timers API is not ' + 'mocked with fake timers. Call `jest.useFakeTimers()` in this test or ' + 'enable fake timers globally by setting `"timers": "fake"` in the ' + 'configuration file\nStack Trace:\n' + (0, _jestMessageUtil().formatStackTrace)(new Error().stack, this._config, {
          noStackTrace: false
        }));
      }

      return this._fakingTime;
    }
  }]);

  return FakeTimers;
}();

exports["default"] = FakeTimers;