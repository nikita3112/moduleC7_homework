'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.createTranspilingRequire = createTranspilingRequire;
exports["default"] = void 0;

function _crypto() {
  var data = require('crypto');

  _crypto = function _crypto() {
    return data;
  };

  return data;
}

function path() {
  var data = _interopRequireWildcard(require('path'));

  path = function path() {
    return data;
  };

  return data;
}

function _core() {
  var data = require('@babel/core');

  _core = function _core() {
    return data;
  };

  return data;
}

function _babelPluginIstanbul() {
  var data = _interopRequireDefault(require('babel-plugin-istanbul'));

  _babelPluginIstanbul = function _babelPluginIstanbul() {
    return data;
  };

  return data;
}

function _convertSourceMap() {
  var data = require('convert-source-map');

  _convertSourceMap = function _convertSourceMap() {
    return data;
  };

  return data;
}

function _fastJsonStableStringify() {
  var data = _interopRequireDefault(require('fast-json-stable-stringify'));

  _fastJsonStableStringify = function _fastJsonStableStringify() {
    return data;
  };

  return data;
}

function fs() {
  var data = _interopRequireWildcard(require('graceful-fs'));

  fs = function fs() {
    return data;
  };

  return data;
}

function _pirates() {
  var data = require('pirates');

  _pirates = function _pirates() {
    return data;
  };

  return data;
}

function _slash() {
  var data = _interopRequireDefault(require('slash'));

  _slash = function _slash() {
    return data;
  };

  return data;
}

function _writeFileAtomic() {
  var data = require('write-file-atomic');

  _writeFileAtomic = function _writeFileAtomic() {
    return data;
  };

  return data;
}

function _jestHasteMap() {
  var data = _interopRequireDefault(require('jest-haste-map'));

  _jestHasteMap = function _jestHasteMap() {
    return data;
  };

  return data;
}

function _jestUtil() {
  var data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

var _enhanceUnexpectedTokenMessage = _interopRequireDefault(require('./enhanceUnexpectedTokenMessage'));

var _shouldInstrument = _interopRequireDefault(require('./shouldInstrument'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== 'function') return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
} // Use `require` to avoid TS rootDir


var _require = require('../package.json'),
    VERSION = _require.version; // This data structure is used to avoid recalculating some data every time that
// we need to transform a file. Since ScriptTransformer is instantiated for each
// file we need to keep this object in the local scope of this module.


var projectCaches = new Map(); // To reset the cache for specific changesets (rather than package version).

var CACHE_VERSION = '1';

function waitForPromiseWithCleanup(promise, cleanup) {
  return regeneratorRuntime.async(function waitForPromiseWithCleanup$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.prev = 0;
          _context.next = 3;
          return regeneratorRuntime.awrap(promise);

        case 3:
          _context.prev = 3;
          cleanup();
          return _context.finish(3);

        case 6:
        case "end":
          return _context.stop();
      }
    }
  }, null, null, [[0,, 3, 6]]);
}

var ScriptTransformer =
/*#__PURE__*/
function () {
  function ScriptTransformer(config) {
    _classCallCheck(this, ScriptTransformer);

    _defineProperty(this, '_cache', void 0);

    _defineProperty(this, '_config', void 0);

    _defineProperty(this, '_transformCache', void 0);

    _defineProperty(this, '_transformConfigCache', void 0);

    this._config = config;
    this._transformCache = new Map();
    this._transformConfigCache = new Map();
    var configString = (0, _fastJsonStableStringify()["default"])(this._config);
    var projectCache = projectCaches.get(configString);

    if (!projectCache) {
      projectCache = {
        configString: configString,
        ignorePatternsRegExp: calcIgnorePatternRegExp(this._config),
        transformRegExp: calcTransformRegExp(this._config),
        transformedFiles: new Map()
      };
      projectCaches.set(configString, projectCache);
    }

    this._cache = projectCache;
  }

  _createClass(ScriptTransformer, [{
    key: "_getCacheKey",
    value: function _getCacheKey(fileData, filename, instrument, supportsDynamicImport, supportsStaticESM) {
      var configString = this._cache.configString;

      var transformer = this._getTransformer(filename);

      if (transformer && typeof transformer.getCacheKey === 'function') {
        return (0, _crypto().createHash)('md5').update(transformer.getCacheKey(fileData, filename, configString, {
          config: this._config,
          instrument: instrument,
          rootDir: this._config.rootDir,
          supportsDynamicImport: supportsDynamicImport,
          supportsStaticESM: supportsStaticESM
        })).update(CACHE_VERSION).digest('hex');
      } else {
        return (0, _crypto().createHash)('md5').update(fileData).update(configString).update(instrument ? 'instrument' : '').update(filename).update(CACHE_VERSION).digest('hex');
      }
    }
  }, {
    key: "_getFileCachePath",
    value: function _getFileCachePath(filename, content, instrument, supportsDynamicImport, supportsStaticESM) {
      var baseCacheDir = _jestHasteMap()["default"].getCacheFilePath(this._config.cacheDirectory, 'jest-transform-cache-' + this._config.name, VERSION);

      var cacheKey = this._getCacheKey(content, filename, instrument, supportsDynamicImport, supportsStaticESM); // Create sub folders based on the cacheKey to avoid creating one
      // directory with many files.


      var cacheDir = path().join(baseCacheDir, cacheKey[0] + cacheKey[1]);
      var cacheFilenamePrefix = path().basename(filename, path().extname(filename)).replace(/\W/g, '');
      var cachePath = (0, _slash()["default"])(path().join(cacheDir, cacheFilenamePrefix + '_' + cacheKey));
      (0, _jestUtil().createDirectory)(cacheDir);
      return cachePath;
    }
  }, {
    key: "_getTransformPath",
    value: function _getTransformPath(filename) {
      var transformRegExp = this._cache.transformRegExp;

      if (!transformRegExp) {
        return undefined;
      }

      for (var i = 0; i < transformRegExp.length; i++) {
        if (transformRegExp[i][0].test(filename)) {
          var transformPath = transformRegExp[i][1];

          this._transformConfigCache.set(transformPath, transformRegExp[i][2]);

          return transformPath;
        }
      }

      return undefined;
    }
  }, {
    key: "_getTransformer",
    value: function _getTransformer(filename) {
      if (!this._config.transform || !this._config.transform.length) {
        return null;
      }

      var transformPath = this._getTransformPath(filename);

      if (!transformPath) {
        return null;
      }

      var transformer = this._transformCache.get(transformPath);

      if (transformer) {
        return transformer;
      }

      var transform = require(transformPath);

      if (!transform) {
        throw new TypeError('Jest: a transform must export something.');
      }

      var transformerConfig = this._transformConfigCache.get(transformPath);

      if (typeof transform.createTransformer === 'function') {
        transform = transform.createTransformer(transformerConfig);
      }

      if (typeof transform.process !== 'function') {
        throw new TypeError('Jest: a transform must export a `process` function.');
      }

      this._transformCache.set(transformPath, transform);

      return transform;
    }
  }, {
    key: "_instrumentFile",
    value: function _instrumentFile(filename, input, supportsDynamicImport, supportsStaticESM, canMapToInput) {
      var inputCode = typeof input === 'string' ? input : input.code;
      var inputMap = typeof input === 'string' ? null : input.map;
      var result = (0, _core().transformSync)(inputCode, {
        auxiliaryCommentBefore: ' istanbul ignore next ',
        babelrc: false,
        caller: {
          name: '@jest/transform',
          supportsDynamicImport: supportsDynamicImport,
          supportsStaticESM: supportsStaticESM
        },
        configFile: false,
        filename: filename,
        plugins: [[_babelPluginIstanbul()["default"], {
          compact: false,
          // files outside `cwd` will not be instrumented
          cwd: this._config.rootDir,
          exclude: [],
          extension: false,
          inputSourceMap: inputMap,
          useInlineSourceMaps: false
        }]],
        sourceMaps: canMapToInput ? 'both' : false
      });

      if (result && result.code) {
        return result;
      }

      return input;
    } // We don't want to expose transformers to the outside - this function is just
    // to warm up `this._transformCache`

  }, {
    key: "preloadTransformer",
    value: function preloadTransformer(filepath) {
      this._getTransformer(filepath);
    } // TODO: replace third argument with TransformOptions in Jest 26

  }, {
    key: "transformSource",
    value: function transformSource(filepath, content, instrument) {
      var supportsDynamicImport = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var supportsStaticESM = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var filename = (0, _jestUtil().tryRealpath)(filepath);

      var transform = this._getTransformer(filename);

      var cacheFilePath = this._getFileCachePath(filename, content, instrument, supportsDynamicImport, supportsStaticESM);

      var sourceMapPath = cacheFilePath + '.map'; // Ignore cache if `config.cache` is set (--no-cache)

      var code = this._config.cache ? readCodeCacheFile(cacheFilePath) : null;
      var shouldCallTransform = transform && this.shouldTransform(filename); // That means that the transform has a custom instrumentation
      // logic and will handle it based on `config.collectCoverage` option

      var transformWillInstrument = shouldCallTransform && transform && transform.canInstrument;

      if (code) {
        // This is broken: we return the code, and a path for the source map
        // directly from the cache. But, nothing ensures the source map actually
        // matches that source code. They could have gotten out-of-sync in case
        // two separate processes write concurrently to the same cache files.
        return {
          code: code,
          originalCode: content,
          sourceMapPath: sourceMapPath
        };
      }

      var transformed = {
        code: content,
        map: null
      };

      if (transform && shouldCallTransform) {
        var processed = transform.process(content, filename, this._config, {
          instrument: instrument,
          supportsDynamicImport: supportsDynamicImport,
          supportsStaticESM: supportsStaticESM
        });

        if (typeof processed === 'string') {
          transformed.code = processed;
        } else if (processed != null && typeof processed.code === 'string') {
          transformed = processed;
        } else {
          throw new TypeError("Jest: a transform's `process` function must return a string, " + 'or an object with `code` key containing this string.');
        }
      }

      if (!transformed.map) {
        try {
          //Could be a potential freeze here.
          //See: https://github.com/facebook/jest/pull/5177#discussion_r158883570
          var inlineSourceMap = (0, _convertSourceMap().fromSource)(transformed.code);

          if (inlineSourceMap) {
            transformed.map = inlineSourceMap.toObject();
          }
        } catch (_unused) {
          var transformPath = this._getTransformPath(filename);

          console.warn("jest-transform: The source map produced for the file ".concat(filename, " ") + "by ".concat(transformPath, " was invalid. Proceeding without source ") + 'mapping for that file.');
        }
      } // Apply instrumentation to the code if necessary, keeping the instrumented code and new map


      var map = transformed.map;

      if (!transformWillInstrument && instrument) {
        /**
         * We can map the original source code to the instrumented code ONLY if
         * - the process of transforming the code produced a source map e.g. ts-jest
         * - we did not transform the source code
         *
         * Otherwise we cannot make any statements about how the instrumented code corresponds to the original code,
         * and we should NOT emit any source maps
         *
         */
        var shouldEmitSourceMaps = transform != null && map != null || transform == null;

        var instrumented = this._instrumentFile(filename, transformed, supportsDynamicImport, supportsStaticESM, shouldEmitSourceMaps);

        code = typeof instrumented === 'string' ? instrumented : instrumented.code;
        map = typeof instrumented === 'string' ? null : instrumented.map;
      } else {
        code = transformed.code;
      }

      if (map) {
        var sourceMapContent = typeof map === 'string' ? map : JSON.stringify(map);
        writeCacheFile(sourceMapPath, sourceMapContent);
      } else {
        sourceMapPath = null;
      }

      writeCodeCacheFile(cacheFilePath, code);
      return {
        code: code,
        originalCode: content,
        sourceMapPath: sourceMapPath
      };
    }
  }, {
    key: "_transformAndBuildScript",
    value: function _transformAndBuildScript(filename, options, instrument, fileSource) {
      var isCoreModule = options.isCoreModule,
          isInternalModule = options.isInternalModule,
          supportsDynamicImport = options.supportsDynamicImport,
          supportsStaticESM = options.supportsStaticESM;
      var content = stripShebang(fileSource || fs().readFileSync(filename, 'utf8'));
      var code = content;
      var sourceMapPath = null;
      var willTransform = !isInternalModule && !isCoreModule && (this.shouldTransform(filename) || instrument);

      try {
        if (willTransform) {
          var transformedSource = this.transformSource(filename, content, instrument, supportsDynamicImport, supportsStaticESM);
          code = transformedSource.code;
          sourceMapPath = transformedSource.sourceMapPath;
        }

        return {
          code: code,
          originalCode: content,
          sourceMapPath: sourceMapPath
        };
      } catch (e) {
        throw (0, _enhanceUnexpectedTokenMessage["default"])(e);
      }
    }
  }, {
    key: "transform",
    value: function transform(filename, options, fileSource) {
      var scriptCacheKey = undefined;
      var instrument = false;

      if (!options.isCoreModule) {
        instrument = options.coverageProvider === 'babel' && (0, _shouldInstrument["default"])(filename, options, this._config);
        scriptCacheKey = getScriptCacheKey(filename, instrument);

        var _result = this._cache.transformedFiles.get(scriptCacheKey);

        if (_result) {
          return _result;
        }
      }

      var result = this._transformAndBuildScript(filename, options, instrument, fileSource);

      if (scriptCacheKey) {
        this._cache.transformedFiles.set(scriptCacheKey, result);
      }

      return result;
    }
  }, {
    key: "transformJson",
    value: function transformJson(filename, options, fileSource) {
      var isCoreModule = options.isCoreModule,
          isInternalModule = options.isInternalModule,
          supportsDynamicImport = options.supportsDynamicImport,
          supportsStaticESM = options.supportsStaticESM;
      var willTransform = !isInternalModule && !isCoreModule && this.shouldTransform(filename);

      if (willTransform) {
        var _this$transformSource = this.transformSource(filename, fileSource, false, supportsDynamicImport, supportsStaticESM),
            transformedJsonSource = _this$transformSource.code;

        return transformedJsonSource;
      }

      return fileSource;
    }
  }, {
    key: "requireAndTranspileModule",
    value: function requireAndTranspileModule(moduleName, callback) {
      var _this = this;

      // Load the transformer to avoid a cycle where we need to load a
      // transformer in order to transform it in the require hooks
      this.preloadTransformer(moduleName);
      var transforming = false;
      var revertHook = (0, _pirates().addHook)(function (code, filename) {
        try {
          transforming = true;
          return (// we might wanna do `supportsDynamicImport` at some point
            _this.transformSource(filename, code, false, false, false).code || code
          );
        } finally {
          transforming = false;
        }
      }, {
        exts: this._config.moduleFileExtensions.map(function (ext) {
          return ".".concat(ext);
        }),
        ignoreNodeModules: false,
        matcher: function matcher(filename) {
          if (transforming) {
            // Don't transform any dependency required by the transformer itself
            return false;
          }

          return _this.shouldTransform(filename);
        }
      });

      var module = require(moduleName);

      if (!callback) {
        revertHook();
        return module;
      }

      try {
        var cbResult = callback(module);

        if ((0, _jestUtil().isPromise)(cbResult)) {
          return waitForPromiseWithCleanup(cbResult, revertHook).then(function () {
            return module;
          });
        }
      } finally {
        revertHook();
      }

      return module;
    }
    /**
     * @deprecated use `this.shouldTransform` instead
     */
    // @ts-expect-error: Unused and private - remove in Jest 25

  }, {
    key: "_shouldTransform",
    value: function _shouldTransform(filename) {
      return this.shouldTransform(filename);
    }
  }, {
    key: "shouldTransform",
    value: function shouldTransform(filename) {
      var ignoreRegexp = this._cache.ignorePatternsRegExp;
      var isIgnored = ignoreRegexp ? ignoreRegexp.test(filename) : false;
      return !!this._config.transform && !!this._config.transform.length && !isIgnored;
    }
  }]);

  return ScriptTransformer;
}(); // TODO: do we need to define the generics twice?


exports["default"] = ScriptTransformer;

function createTranspilingRequire(config) {
  var transformer = new ScriptTransformer(config);
  return function requireAndTranspileModule(resolverPath) {
    var applyInteropRequireDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var transpiledModule = transformer.requireAndTranspileModule(resolverPath);
    return applyInteropRequireDefault ? (0, _jestUtil().interopRequireDefault)(transpiledModule)["default"] : transpiledModule;
  };
}

var removeFile = function removeFile(path) {
  try {
    fs().unlinkSync(path);
  } catch (_unused2) {}
};

var stripShebang = function stripShebang(content) {
  // If the file data starts with a shebang remove it. Leaves the empty line
  // to keep stack trace line numbers correct.
  if (content.startsWith('#!')) {
    return content.replace(/^#!.*/, '');
  } else {
    return content;
  }
};
/**
 * This is like `writeCacheFile` but with an additional sanity checksum. We
 * cannot use the same technique for source maps because we expose source map
 * cache file paths directly to callsites, with the expectation they can read
 * it right away. This is not a great system, because source map cache file
 * could get corrupted, out-of-sync, etc.
 */


function writeCodeCacheFile(cachePath, code) {
  var checksum = (0, _crypto().createHash)('md5').update(code).digest('hex');
  writeCacheFile(cachePath, checksum + '\n' + code);
}
/**
 * Read counterpart of `writeCodeCacheFile`. We verify that the content of the
 * file matches the checksum, in case some kind of corruption happened. This
 * could happen if an older version of `jest-runtime` writes non-atomically to
 * the same cache, for example.
 */


function readCodeCacheFile(cachePath) {
  var content = readCacheFile(cachePath);

  if (content == null) {
    return null;
  }

  var code = content.substr(33);
  var checksum = (0, _crypto().createHash)('md5').update(code).digest('hex');

  if (checksum === content.substr(0, 32)) {
    return code;
  }

  return null;
}
/**
 * Writing to the cache atomically relies on 'rename' being atomic on most
 * file systems. Doing atomic write reduces the risk of corruption by avoiding
 * two processes to write to the same file at the same time. It also reduces
 * the risk of reading a file that's being overwritten at the same time.
 */


var writeCacheFile = function writeCacheFile(cachePath, fileData) {
  try {
    (0, _writeFileAtomic().sync)(cachePath, fileData, {
      encoding: 'utf8',
      fsync: false
    });
  } catch (e) {
    if (cacheWriteErrorSafeToIgnore(e, cachePath)) {
      return;
    }

    e.message = 'jest: failed to cache transform results in: ' + cachePath + '\nFailure message: ' + e.message;
    removeFile(cachePath);
    throw e;
  }
};
/**
 * On Windows, renames are not atomic, leading to EPERM exceptions when two
 * processes attempt to rename to the same target file at the same time.
 * If the target file exists we can be reasonably sure another process has
 * legitimately won a cache write race and ignore the error.
 */


var cacheWriteErrorSafeToIgnore = function cacheWriteErrorSafeToIgnore(e, cachePath) {
  return process.platform === 'win32' && e.code === 'EPERM' && fs().existsSync(cachePath);
};

var readCacheFile = function readCacheFile(cachePath) {
  if (!fs().existsSync(cachePath)) {
    return null;
  }

  var fileData;

  try {
    fileData = fs().readFileSync(cachePath, 'utf8');
  } catch (e) {
    e.message = 'jest: failed to read cache file: ' + cachePath + '\nFailure message: ' + e.message;
    removeFile(cachePath);
    throw e;
  }

  if (fileData == null) {
    // We must have somehow created the file but failed to write to it,
    // let's delete it and retry.
    removeFile(cachePath);
  }

  return fileData;
};

var getScriptCacheKey = function getScriptCacheKey(filename, instrument) {
  var mtime = fs().statSync(filename).mtime;
  return filename + '_' + mtime.getTime() + (instrument ? '_instrumented' : '');
};

var calcIgnorePatternRegExp = function calcIgnorePatternRegExp(config) {
  if (!config.transformIgnorePatterns || config.transformIgnorePatterns.length === 0) {
    return undefined;
  }

  return new RegExp(config.transformIgnorePatterns.join('|'));
};

var calcTransformRegExp = function calcTransformRegExp(config) {
  if (!config.transform.length) {
    return undefined;
  }

  var transformRegexp = [];

  for (var i = 0; i < config.transform.length; i++) {
    transformRegexp.push([new RegExp(config.transform[i][0]), config.transform[i][1], config.transform[i][2]]);
  }

  return transformRegexp;
};