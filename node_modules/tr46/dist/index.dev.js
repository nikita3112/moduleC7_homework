"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var punycode = require("punycode");

var regexes = require("./lib/regexes.js");

var mappingTable = require("./lib/mappingTable.json");

var _require = require("./lib/statusMapping.js"),
    STATUS_MAPPING = _require.STATUS_MAPPING;

function containsNonASCII(str) {
  return /[^\x00-\x7F]/.test(str);
}

function findStatus(val, _ref) {
  var useSTD3ASCIIRules = _ref.useSTD3ASCIIRules;
  var start = 0;
  var end = mappingTable.length - 1;

  while (start <= end) {
    var mid = Math.floor((start + end) / 2);
    var target = mappingTable[mid];
    var min = Array.isArray(target[0]) ? target[0][0] : target[0];
    var max = Array.isArray(target[0]) ? target[0][1] : target[0];

    if (min <= val && max >= val) {
      if (useSTD3ASCIIRules && (target[1] === STATUS_MAPPING.disallowed_STD3_valid || target[1] === STATUS_MAPPING.disallowed_STD3_mapped)) {
        return [STATUS_MAPPING.disallowed].concat(_toConsumableArray(target.slice(2)));
      } else if (target[1] === STATUS_MAPPING.disallowed_STD3_valid) {
        return [STATUS_MAPPING.valid].concat(_toConsumableArray(target.slice(2)));
      } else if (target[1] === STATUS_MAPPING.disallowed_STD3_mapped) {
        return [STATUS_MAPPING.mapped].concat(_toConsumableArray(target.slice(2)));
      }

      return target.slice(1);
    } else if (min > val) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }

  return null;
}

function mapChars(domainName, _ref2) {
  var useSTD3ASCIIRules = _ref2.useSTD3ASCIIRules,
      processingOption = _ref2.processingOption;
  var hasError = false;
  var processed = "";
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = domainName[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var ch = _step.value;

      var _findStatus = findStatus(ch.codePointAt(0), {
        useSTD3ASCIIRules: useSTD3ASCIIRules
      }),
          _findStatus2 = _slicedToArray(_findStatus, 2),
          status = _findStatus2[0],
          mapping = _findStatus2[1];

      switch (status) {
        case STATUS_MAPPING.disallowed:
          hasError = true;
          processed += ch;
          break;

        case STATUS_MAPPING.ignored:
          break;

        case STATUS_MAPPING.mapped:
          processed += mapping;
          break;

        case STATUS_MAPPING.deviation:
          if (processingOption === "transitional") {
            processed += mapping;
          } else {
            processed += ch;
          }

          break;

        case STATUS_MAPPING.valid:
          processed += ch;
          break;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return {
    string: processed,
    error: hasError
  };
}

function validateLabel(label, _ref3) {
  var checkHyphens = _ref3.checkHyphens,
      checkBidi = _ref3.checkBidi,
      checkJoiners = _ref3.checkJoiners,
      processingOption = _ref3.processingOption,
      useSTD3ASCIIRules = _ref3.useSTD3ASCIIRules;

  if (label.normalize("NFC") !== label) {
    return false;
  }

  var codePoints = Array.from(label);

  if (checkHyphens) {
    if (codePoints[2] === "-" && codePoints[3] === "-" || label.startsWith("-") || label.endsWith("-")) {
      return false;
    }
  }

  if (label.includes(".") || codePoints.length > 0 && regexes.combiningMarks.test(codePoints[0])) {
    return false;
  }

  for (var _i2 = 0, _codePoints = codePoints; _i2 < _codePoints.length; _i2++) {
    var _ch = _codePoints[_i2];

    var _findStatus3 = findStatus(_ch.codePointAt(0), {
      useSTD3ASCIIRules: useSTD3ASCIIRules
    }),
        _findStatus4 = _slicedToArray(_findStatus3, 1),
        status = _findStatus4[0];

    if (processingOption === "transitional" && status !== STATUS_MAPPING.valid || processingOption === "nontransitional" && status !== STATUS_MAPPING.valid && status !== STATUS_MAPPING.deviation) {
      return false;
    }
  } // https://tools.ietf.org/html/rfc5892#appendix-A


  if (checkJoiners) {
    var last = 0;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = codePoints.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _step2$value = _slicedToArray(_step2.value, 2),
            i = _step2$value[0],
            ch = _step2$value[1];

        if (ch === "\u200C" || ch === "\u200D") {
          if (i > 0) {
            if (regexes.combiningClassVirama.test(codePoints[i - 1])) {
              continue;
            }

            if (ch === "\u200C") {
              // TODO: make this more efficient
              var next = codePoints.indexOf("\u200C", i + 1);
              var test = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);

              if (regexes.validZWNJ.test(test.join(""))) {
                last = i + 1;
                continue;
              }
            }
          }

          return false;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  } // https://tools.ietf.org/html/rfc5893#section-2


  if (checkBidi) {
    var rtl; // 1

    if (regexes.bidiS1LTR.test(codePoints[0])) {
      rtl = false;
    } else if (regexes.bidiS1RTL.test(codePoints[0])) {
      rtl = true;
    } else {
      return false;
    }

    if (rtl) {
      // 2-4
      if (!regexes.bidiS2.test(label) || !regexes.bidiS3.test(label) || regexes.bidiS4EN.test(label) && regexes.bidiS4AN.test(label)) {
        return false;
      }
    } else if (!regexes.bidiS5.test(label) || !regexes.bidiS6.test(label)) {
      // 5-6
      return false;
    }
  }

  return true;
}

function isBidiDomain(labels) {
  var domain = labels.map(function (label) {
    if (label.startsWith("xn--")) {
      try {
        return punycode.decode(label.substring(4));
      } catch (err) {
        return "";
      }
    }

    return label;
  }).join(".");
  return regexes.bidiDomain.test(domain);
}

function processing(domainName, options) {
  var processingOption = options.processingOption; // 1. Map.

  var _mapChars = mapChars(domainName, options),
      string = _mapChars.string,
      error = _mapChars.error; // 2. Normalize.


  string = string.normalize("NFC"); // 3. Break.

  var labels = string.split(".");
  var isBidi = isBidiDomain(labels); // 4. Convert/Validate.

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = labels.entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var _step3$value = _slicedToArray(_step3.value, 2),
          i = _step3$value[0],
          origLabel = _step3$value[1];

      var label = origLabel;
      var curProcessing = processingOption;

      if (label.startsWith("xn--")) {
        try {
          label = punycode.decode(label.substring(4));
          labels[i] = label;
        } catch (err) {
          error = true;
          continue;
        }

        curProcessing = "nontransitional";
      } // No need to validate if we already know there is an error.


      if (error) {
        continue;
      }

      var validation = validateLabel(label, Object.assign({}, options, {
        processingOption: curProcessing,
        checkBidi: options.checkBidi && isBidi
      }));

      if (!validation) {
        error = true;
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return {
    string: labels.join("."),
    error: error
  };
}

function toASCII(domainName) {
  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref4$checkHyphens = _ref4.checkHyphens,
      checkHyphens = _ref4$checkHyphens === void 0 ? false : _ref4$checkHyphens,
      _ref4$checkBidi = _ref4.checkBidi,
      checkBidi = _ref4$checkBidi === void 0 ? false : _ref4$checkBidi,
      _ref4$checkJoiners = _ref4.checkJoiners,
      checkJoiners = _ref4$checkJoiners === void 0 ? false : _ref4$checkJoiners,
      _ref4$useSTD3ASCIIRul = _ref4.useSTD3ASCIIRules,
      useSTD3ASCIIRules = _ref4$useSTD3ASCIIRul === void 0 ? false : _ref4$useSTD3ASCIIRul,
      _ref4$processingOptio = _ref4.processingOption,
      processingOption = _ref4$processingOptio === void 0 ? "nontransitional" : _ref4$processingOptio,
      _ref4$verifyDNSLength = _ref4.verifyDNSLength,
      verifyDNSLength = _ref4$verifyDNSLength === void 0 ? false : _ref4$verifyDNSLength;

  if (processingOption !== "transitional" && processingOption !== "nontransitional") {
    throw new RangeError("processingOption must be either transitional or nontransitional");
  }

  var result = processing(domainName, {
    processingOption: processingOption,
    checkHyphens: checkHyphens,
    checkBidi: checkBidi,
    checkJoiners: checkJoiners,
    useSTD3ASCIIRules: useSTD3ASCIIRules
  });
  var labels = result.string.split(".");
  labels = labels.map(function (l) {
    if (containsNonASCII(l)) {
      try {
        return "xn--" + punycode.encode(l);
      } catch (e) {
        result.error = true;
      }
    }

    return l;
  });

  if (verifyDNSLength) {
    var total = labels.join(".").length;

    if (total > 253 || total === 0) {
      result.error = true;
    }

    for (var i = 0; i < labels.length; ++i) {
      if (labels[i].length > 63 || labels[i].length === 0) {
        result.error = true;
        break;
      }
    }
  }

  if (result.error) {
    return null;
  }

  return labels.join(".");
}

function toUnicode(domainName) {
  var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref5$checkHyphens = _ref5.checkHyphens,
      checkHyphens = _ref5$checkHyphens === void 0 ? false : _ref5$checkHyphens,
      _ref5$checkBidi = _ref5.checkBidi,
      checkBidi = _ref5$checkBidi === void 0 ? false : _ref5$checkBidi,
      _ref5$checkJoiners = _ref5.checkJoiners,
      checkJoiners = _ref5$checkJoiners === void 0 ? false : _ref5$checkJoiners,
      _ref5$useSTD3ASCIIRul = _ref5.useSTD3ASCIIRules,
      useSTD3ASCIIRules = _ref5$useSTD3ASCIIRul === void 0 ? false : _ref5$useSTD3ASCIIRul,
      _ref5$processingOptio = _ref5.processingOption,
      processingOption = _ref5$processingOptio === void 0 ? "nontransitional" : _ref5$processingOptio;

  var result = processing(domainName, {
    processingOption: processingOption,
    checkHyphens: checkHyphens,
    checkBidi: checkBidi,
    checkJoiners: checkJoiners,
    useSTD3ASCIIRules: useSTD3ASCIIRules
  });
  return {
    domain: result.string,
    error: result.error
  };
}

module.exports = {
  toASCII: toASCII,
  toUnicode: toUnicode
};