'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _chalk() {
  var data = _interopRequireDefault(require('chalk'));

  _chalk = function _chalk() {
    return data;
  };

  return data;
}

function _emittery() {
  var data = _interopRequireDefault(require('emittery'));

  _emittery = function _emittery() {
    return data;
  };

  return data;
}

function _exit() {
  var data = _interopRequireDefault(require('exit'));

  _exit = function _exit() {
    return data;
  };

  return data;
}

function _throat() {
  var data = _interopRequireDefault(require('throat'));

  _throat = function _throat() {
    return data;
  };

  return data;
}

function _jestUtil() {
  var data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

function _jestWorker() {
  var data = _interopRequireDefault(require('jest-worker'));

  _jestWorker = function _jestWorker() {
    return data;
  };

  return data;
}

var _runTest = _interopRequireDefault(require('./runTest'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var TEST_WORKER_PATH = require.resolve('./testWorker');

var TestRunner =
/*#__PURE__*/
function () {
  function TestRunner(globalConfig, context) {
    _classCallCheck(this, TestRunner);

    _defineProperty(this, '_globalConfig', void 0);

    _defineProperty(this, '_context', void 0);

    _defineProperty(this, 'eventEmitter', new (_emittery()["default"].Typed)());

    _defineProperty(this, '__PRIVATE_UNSTABLE_API_supportsEventEmitters__', true);

    _defineProperty(this, 'isSerial', void 0);

    _defineProperty(this, 'on', this.eventEmitter.on.bind(this.eventEmitter));

    this._globalConfig = globalConfig;
    this._context = context || {};
  }

  _createClass(TestRunner, [{
    key: "runTests",
    value: function runTests(tests, watcher, onStart, onResult, onFailure, options) {
      return regeneratorRuntime.async(function runTests$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return regeneratorRuntime.awrap(options.serial ? this._createInBandTestRun(tests, watcher, onStart, onResult, onFailure) : this._createParallelTestRun(tests, watcher, onStart, onResult, onFailure));

            case 2:
              return _context.abrupt("return", _context.sent);

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "_createInBandTestRun",
    value: function _createInBandTestRun(tests, watcher, onStart, onResult, onFailure) {
      var _this = this;

      var mutex;
      return regeneratorRuntime.async(function _createInBandTestRun$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              process.env.JEST_WORKER_ID = '1';
              mutex = (0, _throat()["default"])(1);
              return _context3.abrupt("return", tests.reduce(function (promise, test) {
                return mutex(function () {
                  return promise.then(function _callee() {
                    var sendMessageToJest;
                    return regeneratorRuntime.async(function _callee$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (!watcher.isInterrupted()) {
                              _context2.next = 2;
                              break;
                            }

                            throw new CancelRun();

                          case 2:
                            if (!onStart) {
                              _context2.next = 8;
                              break;
                            }

                            _context2.next = 5;
                            return regeneratorRuntime.awrap(onStart(test));

                          case 5:
                            return _context2.abrupt("return", (0, _runTest["default"])(test.path, _this._globalConfig, test.context.config, test.context.resolver, _this._context, undefined));

                          case 8:
                            // `deepCyclicCopy` used here to avoid mem-leak
                            sendMessageToJest = function sendMessageToJest(eventName, args) {
                              return _this.eventEmitter.emit(eventName, (0, _jestUtil().deepCyclicCopy)(args, {
                                keepPrototype: false
                              }));
                            };

                            _context2.next = 11;
                            return regeneratorRuntime.awrap(_this.eventEmitter.emit('test-file-start', [test]));

                          case 11:
                            return _context2.abrupt("return", (0, _runTest["default"])(test.path, _this._globalConfig, test.context.config, test.context.resolver, _this._context, sendMessageToJest));

                          case 12:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    });
                  }).then(function (result) {
                    if (onResult) {
                      return onResult(test, result);
                    } else {
                      return _this.eventEmitter.emit('test-file-success', [test, result]);
                    }
                  })["catch"](function (err) {
                    if (onFailure) {
                      return onFailure(test, err);
                    } else {
                      return _this.eventEmitter.emit('test-file-failure', [test, err]);
                    }
                  });
                });
              }, Promise.resolve()));

            case 3:
            case "end":
              return _context3.stop();
          }
        }
      });
    }
  }, {
    key: "_createParallelTestRun",
    value: function _createParallelTestRun(tests, watcher, onStart, onResult, onFailure) {
      var _this2 = this;

      var resolvers, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, test, worker, mutex, runTestInWorker, onError, onInterrupt, runAllTests, cleanup;

      return regeneratorRuntime.async(function _createParallelTestRun$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              resolvers = new Map();
              _iteratorNormalCompletion = true;
              _didIteratorError = false;
              _iteratorError = undefined;
              _context7.prev = 4;

              for (_iterator = tests[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                test = _step.value;

                if (!resolvers.has(test.context.config.name)) {
                  resolvers.set(test.context.config.name, {
                    config: test.context.config,
                    serializableModuleMap: test.context.moduleMap.toJSON()
                  });
                }
              }

              _context7.next = 12;
              break;

            case 8:
              _context7.prev = 8;
              _context7.t0 = _context7["catch"](4);
              _didIteratorError = true;
              _iteratorError = _context7.t0;

            case 12:
              _context7.prev = 12;
              _context7.prev = 13;

              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }

            case 15:
              _context7.prev = 15;

              if (!_didIteratorError) {
                _context7.next = 18;
                break;
              }

              throw _iteratorError;

            case 18:
              return _context7.finish(15);

            case 19:
              return _context7.finish(12);

            case 20:
              worker = new (_jestWorker()["default"])(TEST_WORKER_PATH, {
                exposedMethods: ['worker'],
                forkOptions: {
                  stdio: 'pipe'
                },
                maxRetries: 3,
                numWorkers: this._globalConfig.maxWorkers,
                setupArgs: [{
                  serializableResolvers: Array.from(resolvers.values())
                }]
              });
              if (worker.getStdout()) worker.getStdout().pipe(process.stdout);
              if (worker.getStderr()) worker.getStderr().pipe(process.stderr);
              mutex = (0, _throat()["default"])(this._globalConfig.maxWorkers); // Send test suites to workers continuously instead of all at once to track
              // the start time of individual tests.

              runTestInWorker = function runTestInWorker(test) {
                return mutex(function _callee2() {
                  var promise;
                  return regeneratorRuntime.async(function _callee2$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          if (!watcher.isInterrupted()) {
                            _context4.next = 2;
                            break;
                          }

                          return _context4.abrupt("return", Promise.reject());

                        case 2:
                          if (!onStart) {
                            _context4.next = 7;
                            break;
                          }

                          _context4.next = 5;
                          return regeneratorRuntime.awrap(onStart(test));

                        case 5:
                          _context4.next = 9;
                          break;

                        case 7:
                          _context4.next = 9;
                          return regeneratorRuntime.awrap(_this2.eventEmitter.emit('test-file-start', [test]));

                        case 9:
                          promise = worker.worker({
                            config: test.context.config,
                            context: _objectSpread({}, _this2._context, {
                              changedFiles: _this2._context.changedFiles && Array.from(_this2._context.changedFiles),
                              sourcesRelatedToTestsInChangedFiles: _this2._context.sourcesRelatedToTestsInChangedFiles && Array.from(_this2._context.sourcesRelatedToTestsInChangedFiles)
                            }),
                            globalConfig: _this2._globalConfig,
                            path: test.path
                          });

                          if (promise.UNSTABLE_onCustomMessage) {
                            // TODO: Get appropriate type for `onCustomMessage`
                            promise.UNSTABLE_onCustomMessage(function (_ref) {
                              var _ref2 = _slicedToArray(_ref, 2),
                                  event = _ref2[0],
                                  payload = _ref2[1];

                              _this2.eventEmitter.emit(event, payload);
                            });
                          }

                          return _context4.abrupt("return", promise);

                        case 12:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  });
                });
              };

              onError = function onError(err, test) {
                return regeneratorRuntime.async(function onError$(_context5) {
                  while (1) {
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        if (!onFailure) {
                          _context5.next = 5;
                          break;
                        }

                        _context5.next = 3;
                        return regeneratorRuntime.awrap(onFailure(test, err));

                      case 3:
                        _context5.next = 7;
                        break;

                      case 5:
                        _context5.next = 7;
                        return regeneratorRuntime.awrap(_this2.eventEmitter.emit('test-file-failure', [test, err]));

                      case 7:
                        if (err.type === 'ProcessTerminatedError') {
                          console.error('A worker process has quit unexpectedly! ' + 'Most likely this is an initialization error.');
                          (0, _exit()["default"])(1);
                        }

                      case 8:
                      case "end":
                        return _context5.stop();
                    }
                  }
                });
              };

              onInterrupt = new Promise(function (_, reject) {
                watcher.on('change', function (state) {
                  if (state.interrupted) {
                    reject(new CancelRun());
                  }
                });
              });
              runAllTests = Promise.all(tests.map(function (test) {
                return runTestInWorker(test).then(function (result) {
                  if (onResult) {
                    return onResult(test, result);
                  } else {
                    return _this2.eventEmitter.emit('test-file-success', [test, result]);
                  }
                })["catch"](function (error) {
                  return onError(error, test);
                });
              }));

              cleanup = function cleanup() {
                var _ref3, forceExited;

                return regeneratorRuntime.async(function cleanup$(_context6) {
                  while (1) {
                    switch (_context6.prev = _context6.next) {
                      case 0:
                        _context6.next = 2;
                        return regeneratorRuntime.awrap(worker.end());

                      case 2:
                        _ref3 = _context6.sent;
                        forceExited = _ref3.forceExited;

                        if (forceExited) {
                          console.error(_chalk()["default"].yellow('A worker process has failed to exit gracefully and has been force exited. ' + 'This is likely caused by tests leaking due to improper teardown. ' + 'Try running with --detectOpenHandles to find leaks.'));
                        }

                      case 5:
                      case "end":
                        return _context6.stop();
                    }
                  }
                });
              };

              return _context7.abrupt("return", Promise.race([runAllTests, onInterrupt]).then(cleanup, cleanup));

            case 30:
            case "end":
              return _context7.stop();
          }
        }
      }, null, this, [[4, 8, 12, 20], [13,, 15, 19]]);
    }
  }]);

  return TestRunner;
}();

var CancelRun =
/*#__PURE__*/
function (_Error) {
  _inherits(CancelRun, _Error);

  function CancelRun(message) {
    var _this3;

    _classCallCheck(this, CancelRun);

    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(CancelRun).call(this, message));
    _this3.name = 'CancelRun';
    return _this3;
  }

  return CancelRun;
}(_wrapNativeSuper(Error));

module.exports = TestRunner;