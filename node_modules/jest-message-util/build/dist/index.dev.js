'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.separateMessageFromStack = exports.formatResultsErrors = exports.formatStackTrace = exports.getTopFrame = exports.getStackTraceLines = exports.formatExecError = void 0;

var path = _interopRequireWildcard(require('path'));

var _codeFrame = require('@babel/code-frame');

var _chalk = _interopRequireDefault(require('chalk'));

var fs = _interopRequireWildcard(require('graceful-fs'));

var _micromatch = _interopRequireDefault(require('micromatch'));

var _slash = _interopRequireDefault(require('slash'));

var _stackUtils = _interopRequireDefault(require('stack-utils'));

var _prettyFormat = _interopRequireDefault(require('pretty-format'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== 'function') return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var _Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;

var _Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;

var jestReadFile = global[_Symbol["for"]('jest-native-read-file')] || fs.readFileSync; // stack utils tries to create pretty stack by making paths relative.

var stackUtils = new _stackUtils["default"]({
  cwd: 'something which does not exist'
});
var nodeInternals = [];

try {
  // https://github.com/tapjs/stack-utils/issues/54
  nodeInternals = _stackUtils["default"].nodeInternals().concat(/\s*\(node:/);
} catch (_unused) {// `StackUtils.nodeInternals()` fails in browsers. We don't need to remove
  // node internals in the browser though, so no issue.
}

var PATH_NODE_MODULES = "".concat(path.sep, "node_modules").concat(path.sep);
var PATH_JEST_PACKAGES = "".concat(path.sep, "jest").concat(path.sep, "packages").concat(path.sep); // filter for noisy stack trace lines

var JASMINE_IGNORE = /^\s+at(?:(?:.jasmine\-)|\s+jasmine\.buildExpectationResult)/;
var JEST_INTERNALS_IGNORE = /^\s+at.*?jest(-.*?)?(\/|\\)(build|node_modules|packages)(\/|\\)/;
var ANONYMOUS_FN_IGNORE = /^\s+at <anonymous>.*$/;
var ANONYMOUS_PROMISE_IGNORE = /^\s+at (new )?Promise \(<anonymous>\).*$/;
var ANONYMOUS_GENERATOR_IGNORE = /^\s+at Generator.next \(<anonymous>\).*$/;
var NATIVE_NEXT_IGNORE = /^\s+at next \(native\).*$/;
var TITLE_INDENT = '  ';
var MESSAGE_INDENT = '    ';
var STACK_INDENT = '      ';
var ANCESTRY_SEPARATOR = " \u203A ";

var TITLE_BULLET = _chalk["default"].bold("\u25CF ");

var STACK_TRACE_COLOR = _chalk["default"].dim;
var STACK_PATH_REGEXP = /\s*at.*\(?(\:\d*\:\d*|native)\)?/;
var EXEC_ERROR_MESSAGE = 'Test suite failed to run';
var NOT_EMPTY_LINE_REGEXP = /^(?!$)/gm;

var indentAllLines = function indentAllLines(lines, indent) {
  return lines.replace(NOT_EMPTY_LINE_REGEXP, indent);
};

var trim = function trim(string) {
  return (string || '').trim();
}; // Some errors contain not only line numbers in stack traces
// e.g. SyntaxErrors can contain snippets of code, and we don't
// want to trim those, because they may have pointers to the column/character
// which will get misaligned.


var trimPaths = function trimPaths(string) {
  return string.match(STACK_PATH_REGEXP) ? trim(string) : string;
};

var getRenderedCallsite = function getRenderedCallsite(fileContent, line, column) {
  var renderedCallsite = (0, _codeFrame.codeFrameColumns)(fileContent, {
    start: {
      column: column,
      line: line
    }
  }, {
    highlightCode: true
  });
  renderedCallsite = indentAllLines(renderedCallsite, MESSAGE_INDENT);
  renderedCallsite = "\n".concat(renderedCallsite, "\n");
  return renderedCallsite;
};

var blankStringRegexp = /^\s*$/;

function checkForCommonEnvironmentErrors(error) {
  if (error.includes('ReferenceError: document is not defined') || error.includes('ReferenceError: window is not defined') || error.includes('ReferenceError: navigator is not defined')) {
    return warnAboutWrongTestEnvironment(error, 'jsdom');
  } else if (error.includes('.unref is not a function')) {
    return warnAboutWrongTestEnvironment(error, 'node');
  }

  return error;
}

function warnAboutWrongTestEnvironment(error, env) {
  return _chalk["default"].bold.red("The error below may be caused by using the wrong test environment, see ".concat(_chalk["default"].dim.underline('https://jestjs.io/docs/en/configuration#testenvironment-string'), ".\nConsider using the \"").concat(env, "\" test environment.\n\n")) + error;
} // ExecError is an error thrown outside of the test suite (not inside an `it` or
// `before/after each` hooks). If it's thrown, none of the tests in the file
// are executed.


var formatExecError = function formatExecError(error, config, options, testPath, reuseMessage) {
  if (!error || typeof error === 'number') {
    error = new Error("Expected an Error, but \"".concat(String(error), "\" was thrown"));
    error.stack = '';
  }

  var message, stack;

  if (typeof error === 'string' || !error) {
    error || (error = 'EMPTY ERROR');
    message = '';
    stack = error;
  } else {
    message = error.message;
    stack = typeof error.stack === 'string' ? error.stack : "thrown: ".concat((0, _prettyFormat["default"])(error, {
      maxDepth: 3
    }));
  }

  var separated = separateMessageFromStack(stack || '');
  stack = separated.stack;

  if (separated.message.includes(trim(message))) {
    // Often stack trace already contains the duplicate of the message
    message = separated.message;
  }

  message = checkForCommonEnvironmentErrors(message);
  message = indentAllLines(message, MESSAGE_INDENT);
  stack = stack && !options.noStackTrace ? '\n' + formatStackTrace(stack, config, options, testPath) : '';

  if (typeof stack !== 'string' || blankStringRegexp.test(message) && blankStringRegexp.test(stack)) {
    // this can happen if an empty object is thrown.
    message = "thrown: ".concat((0, _prettyFormat["default"])(error, {
      maxDepth: 3
    }));
  }

  var messageToUse;

  if (reuseMessage) {
    messageToUse = " ".concat(message.trim());
  } else {
    messageToUse = "".concat(EXEC_ERROR_MESSAGE, "\n\n").concat(message);
  }

  return TITLE_INDENT + TITLE_BULLET + messageToUse + stack + '\n';
};

exports.formatExecError = formatExecError;

var removeInternalStackEntries = function removeInternalStackEntries(lines, options) {
  var pathCounter = 0;
  return lines.filter(function (line) {
    if (ANONYMOUS_FN_IGNORE.test(line)) {
      return false;
    }

    if (ANONYMOUS_PROMISE_IGNORE.test(line)) {
      return false;
    }

    if (ANONYMOUS_GENERATOR_IGNORE.test(line)) {
      return false;
    }

    if (NATIVE_NEXT_IGNORE.test(line)) {
      return false;
    }

    if (nodeInternals.some(function (internal) {
      return internal.test(line);
    })) {
      return false;
    }

    if (!STACK_PATH_REGEXP.test(line)) {
      return true;
    }

    if (JASMINE_IGNORE.test(line)) {
      return false;
    }

    if (++pathCounter === 1) {
      return true; // always keep the first line even if it's from Jest
    }

    if (options.noStackTrace) {
      return false;
    }

    if (JEST_INTERNALS_IGNORE.test(line)) {
      return false;
    }

    return true;
  });
};

var formatPaths = function formatPaths(config, relativeTestPath, line) {
  // Extract the file path from the trace line.
  var match = line.match(/(^\s*at .*?\(?)([^()]+)(:[0-9]+:[0-9]+\)?.*$)/);

  if (!match) {
    return line;
  }

  var filePath = (0, _slash["default"])(path.relative(config.rootDir, match[2])); // highlight paths from the current test file

  if (config.testMatch && config.testMatch.length && (0, _micromatch["default"])([filePath], config.testMatch).length > 0 || filePath === relativeTestPath) {
    filePath = _chalk["default"].reset.cyan(filePath);
  }

  return STACK_TRACE_COLOR(match[1]) + filePath + STACK_TRACE_COLOR(match[3]);
};

var getStackTraceLines = function getStackTraceLines(stack) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    noCodeFrame: false,
    noStackTrace: false
  };
  return removeInternalStackEntries(stack.split(/\n/), options);
};

exports.getStackTraceLines = getStackTraceLines;

var getTopFrame = function getTopFrame(lines) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = lines[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var line = _step.value;

      if (line.includes(PATH_NODE_MODULES) || line.includes(PATH_JEST_PACKAGES)) {
        continue;
      }

      var parsedFrame = stackUtils.parseLine(line.trim());

      if (parsedFrame && parsedFrame.file) {
        return parsedFrame;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return null;
};

exports.getTopFrame = getTopFrame;

var formatStackTrace = function formatStackTrace(stack, config, options, testPath) {
  var lines = getStackTraceLines(stack, options);
  var renderedCallsite = '';
  var relativeTestPath = testPath ? (0, _slash["default"])(path.relative(config.rootDir, testPath)) : null;

  if (!options.noStackTrace && !options.noCodeFrame) {
    var topFrame = getTopFrame(lines);

    if (topFrame) {
      var column = topFrame.column,
          filename = topFrame.file,
          line = topFrame.line;

      if (line && filename && path.isAbsolute(filename)) {
        var fileContent;

        try {
          // TODO: check & read HasteFS instead of reading the filesystem:
          // see: https://github.com/facebook/jest/pull/5405#discussion_r164281696
          fileContent = jestReadFile(filename, 'utf8');
          renderedCallsite = getRenderedCallsite(fileContent, line, column);
        } catch (_unused2) {// the file does not exist or is inaccessible, we ignore
        }
      }
    }
  }

  var stacktrace = lines.filter(Boolean).map(function (line) {
    return STACK_INDENT + formatPaths(config, relativeTestPath, trimPaths(line));
  }).join('\n');
  return renderedCallsite ? "".concat(renderedCallsite, "\n").concat(stacktrace) : "\n".concat(stacktrace);
};

exports.formatStackTrace = formatStackTrace;

var formatResultsErrors = function formatResultsErrors(testResults, config, options, testPath) {
  var failedResults = testResults.reduce(function (errors, result) {
    result.failureMessages.map(checkForCommonEnvironmentErrors).forEach(function (content) {
      return errors.push({
        content: content,
        result: result
      });
    });
    return errors;
  }, []);

  if (!failedResults.length) {
    return null;
  }

  return failedResults.map(function (_ref) {
    var result = _ref.result,
        content = _ref.content;

    var _separateMessageFromS = separateMessageFromStack(content),
        message = _separateMessageFromS.message,
        stack = _separateMessageFromS.stack;

    stack = options.noStackTrace ? '' : STACK_TRACE_COLOR(formatStackTrace(stack, config, options, testPath)) + '\n';
    message = indentAllLines(message, MESSAGE_INDENT);
    var title = _chalk["default"].bold.red(TITLE_INDENT + TITLE_BULLET + result.ancestorTitles.join(ANCESTRY_SEPARATOR) + (result.ancestorTitles.length ? ANCESTRY_SEPARATOR : '') + result.title) + '\n';
    return title + '\n' + message + '\n' + stack;
  }).join('\n');
};

exports.formatResultsErrors = formatResultsErrors;
var errorRegexp = /^Error:?\s*$/;

var removeBlankErrorLine = function removeBlankErrorLine(str) {
  return str.split('\n') // Lines saying just `Error:` are useless
  .filter(function (line) {
    return !errorRegexp.test(line);
  }).join('\n').trimRight();
}; // jasmine and worker farm sometimes don't give us access to the actual
// Error object, so we have to regexp out the message from the stack string
// to format it.


var separateMessageFromStack = function separateMessageFromStack(content) {
  if (!content) {
    return {
      message: '',
      stack: ''
    };
  } // All lines up to what looks like a stack -- or if nothing looks like a stack
  // (maybe it's a code frame instead), just the first non-empty line.
  // If the error is a plain "Error:" instead of a SyntaxError or TypeError we
  // remove the prefix from the message because it is generally not useful.


  var messageMatch = content.match(/^(?:Error: )?([\s\S]*?(?=\n\s*at\s.*:\d*:\d*)|\s*.*)([\s\S]*)$/);

  if (!messageMatch) {
    // For typescript
    throw new Error('If you hit this error, the regex above is buggy.');
  }

  var message = removeBlankErrorLine(messageMatch[1]);
  var stack = removeBlankErrorLine(messageMatch[2]);
  return {
    message: message,
    stack: stack
  };
};

exports.separateMessageFromStack = separateMessageFromStack;