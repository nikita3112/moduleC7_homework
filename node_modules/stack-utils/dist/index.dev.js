'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var escapeStringRegexp = require('escape-string-regexp');

var natives = [].concat(require('module').builtinModules, 'bootstrap_node', 'node').map(function (n) {
  return new RegExp("(?:\\((?:node:)?".concat(n, "(?:\\.js)?:\\d+:\\d+\\)$|^\\s*at (?:node:)?").concat(n, "(?:\\.js)?:\\d+:\\d+$)"));
});
natives.push(/\((?:node:)?internal\/[^:]+:\d+:\d+\)$/, /\s*at (?:node:)?internal\/[^:]+:\d+:\d+$/, /\/\.node-spawn-wrap-\w+-\w+\/node:\d+:\d+\)?$/);

var StackUtils =
/*#__PURE__*/
function () {
  function StackUtils(opts) {
    _classCallCheck(this, StackUtils);

    opts = _objectSpread({
      ignoredPackages: []
    }, opts);

    if ('internals' in opts === false) {
      opts.internals = StackUtils.nodeInternals();
    }

    if ('cwd' in opts === false) {
      opts.cwd = process.cwd();
    }

    this._cwd = opts.cwd.replace(/\\/g, '/');
    this._internals = [].concat(opts.internals, ignoredPackagesRegExp(opts.ignoredPackages));
    this._wrapCallSite = opts.wrapCallSite || false;
  }

  _createClass(StackUtils, [{
    key: "clean",
    value: function clean(stack) {
      var _this = this;

      var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      indent = ' '.repeat(indent);

      if (!Array.isArray(stack)) {
        stack = stack.split('\n');
      }

      if (!/^\s*at /.test(stack[0]) && /^\s*at /.test(stack[1])) {
        stack = stack.slice(1);
      }

      var outdent = false;
      var lastNonAtLine = null;
      var result = [];
      stack.forEach(function (st) {
        st = st.replace(/\\/g, '/');

        if (_this._internals.some(function (internal) {
          return internal.test(st);
        })) {
          return;
        }

        var isAtLine = /^\s*at /.test(st);

        if (outdent) {
          st = st.trimEnd().replace(/^(\s+)at /, '$1');
        } else {
          st = st.trim();

          if (isAtLine) {
            st = st.slice(3);
          }
        }

        st = st.replace("".concat(_this._cwd, "/"), '');

        if (st) {
          if (isAtLine) {
            if (lastNonAtLine) {
              result.push(lastNonAtLine);
              lastNonAtLine = null;
            }

            result.push(st);
          } else {
            outdent = true;
            lastNonAtLine = st;
          }
        }
      });
      return result.map(function (line) {
        return "".concat(indent).concat(line, "\n");
      }).join('');
    }
  }, {
    key: "captureString",
    value: function captureString(limit) {
      var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.captureString;

      if (typeof limit === 'function') {
        fn = limit;
        limit = Infinity;
      }

      var stackTraceLimit = Error.stackTraceLimit;

      if (limit) {
        Error.stackTraceLimit = limit;
      }

      var obj = {};
      Error.captureStackTrace(obj, fn);
      var stack = obj.stack;
      Error.stackTraceLimit = stackTraceLimit;
      return this.clean(stack);
    }
  }, {
    key: "capture",
    value: function capture(limit) {
      var _this2 = this;

      var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.capture;

      if (typeof limit === 'function') {
        fn = limit;
        limit = Infinity;
      }

      var prepareStackTrace = Error.prepareStackTrace,
          stackTraceLimit = Error.stackTraceLimit;

      Error.prepareStackTrace = function (obj, site) {
        if (_this2._wrapCallSite) {
          return site.map(_this2._wrapCallSite);
        }

        return site;
      };

      if (limit) {
        Error.stackTraceLimit = limit;
      }

      var obj = {};
      Error.captureStackTrace(obj, fn);
      var stack = obj.stack;
      Object.assign(Error, {
        prepareStackTrace: prepareStackTrace,
        stackTraceLimit: stackTraceLimit
      });
      return stack;
    }
  }, {
    key: "at",
    value: function at() {
      var fn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.at;

      var _this$capture = this.capture(1, fn),
          _this$capture2 = _slicedToArray(_this$capture, 1),
          site = _this$capture2[0];

      if (!site) {
        return {};
      }

      var res = {
        line: site.getLineNumber(),
        column: site.getColumnNumber()
      };
      setFile(res, site.getFileName(), this._cwd);

      if (site.isConstructor()) {
        res.constructor = true;
      }

      if (site.isEval()) {
        res.evalOrigin = site.getEvalOrigin();
      } // Node v10 stopped with the isNative() on callsites, apparently

      /* istanbul ignore next */


      if (site.isNative()) {
        res["native"] = true;
      }

      var typename;

      try {
        typename = site.getTypeName();
      } catch (_) {}

      if (typename && typename !== 'Object' && typename !== '[object Object]') {
        res.type = typename;
      }

      var fname = site.getFunctionName();

      if (fname) {
        res["function"] = fname;
      }

      var meth = site.getMethodName();

      if (meth && fname !== meth) {
        res.method = meth;
      }

      return res;
    }
  }, {
    key: "parseLine",
    value: function parseLine(line) {
      var match = line && line.match(re);

      if (!match) {
        return null;
      }

      var ctor = match[1] === 'new';
      var fname = match[2];
      var evalOrigin = match[3];
      var evalFile = match[4];
      var evalLine = Number(match[5]);
      var evalCol = Number(match[6]);
      var file = match[7];
      var lnum = match[8];
      var col = match[9];

      var _native = match[10] === 'native';

      var closeParen = match[11] === ')';
      var method;
      var res = {};

      if (lnum) {
        res.line = Number(lnum);
      }

      if (col) {
        res.column = Number(col);
      }

      if (closeParen && file) {
        // make sure parens are balanced
        // if we have a file like "asdf) [as foo] (xyz.js", then odds are
        // that the fname should be += " (asdf) [as foo]" and the file
        // should be just "xyz.js"
        // walk backwards from the end to find the last unbalanced (
        var closes = 0;

        for (var i = file.length - 1; i > 0; i--) {
          if (file.charAt(i) === ')') {
            closes++;
          } else if (file.charAt(i) === '(' && file.charAt(i - 1) === ' ') {
            closes--;

            if (closes === -1 && file.charAt(i - 1) === ' ') {
              var before = file.slice(0, i - 1);
              var after = file.slice(i + 1);
              file = after;
              fname += " (".concat(before);
              break;
            }
          }
        }
      }

      if (fname) {
        var methodMatch = fname.match(methodRe);

        if (methodMatch) {
          fname = methodMatch[1];
          method = methodMatch[2];
        }
      }

      setFile(res, file, this._cwd);

      if (ctor) {
        res.constructor = true;
      }

      if (evalOrigin) {
        res.evalOrigin = evalOrigin;
        res.evalLine = evalLine;
        res.evalColumn = evalCol;
        res.evalFile = evalFile && evalFile.replace(/\\/g, '/');
      }

      if (_native) {
        res["native"] = true;
      }

      if (fname) {
        res["function"] = fname;
      }

      if (method && fname !== method) {
        res.method = method;
      }

      return res;
    }
  }], [{
    key: "nodeInternals",
    value: function nodeInternals() {
      return _toConsumableArray(natives);
    }
  }]);

  return StackUtils;
}();

function setFile(result, filename, cwd) {
  if (filename) {
    filename = filename.replace(/\\/g, '/');

    if (filename.startsWith("".concat(cwd, "/"))) {
      filename = filename.slice(cwd.length + 1);
    }

    result.file = filename;
  }
}

function ignoredPackagesRegExp(ignoredPackages) {
  if (ignoredPackages.length === 0) {
    return [];
  }

  var packages = ignoredPackages.map(function (mod) {
    return escapeStringRegexp(mod);
  });
  return new RegExp("[/\\\\]node_modules[/\\\\](?:".concat(packages.join('|'), ")[/\\\\][^:]+:\\d+:\\d+"));
}

var re = new RegExp('^' + // Sometimes we strip out the '    at' because it's noisy
'(?:\\s*at )?' + // $1 = ctor if 'new'
'(?:(new) )?' + // $2 = function name (can be literally anything)
// May contain method at the end as [as xyz]
'(?:(.*?) \\()?' + // (eval at <anonymous> (file.js:1:1),
// $3 = eval origin
// $4:$5:$6 are eval file/line/col, but not normally reported
'(?:eval at ([^ ]+) \\((.+?):(\\d+):(\\d+)\\), )?' + // file:line:col
// $7:$8:$9
// $10 = 'native' if native
'(?:(.+?):(\\d+):(\\d+)|(native))' + // maybe close the paren, then end
// if $11 is ), then we only allow balanced parens in the filename
// any imbalance is placed on the fname.  This is a heuristic, and
// bound to be incorrect in some edge cases.  The bet is that
// having weird characters in method names is more common than
// having weird characters in filenames, which seems reasonable.
'(\\)?)$');
var methodRe = /^(.*?) \[as (.*?)\]$/;
module.exports = StackUtils;