'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.extract = extract;
exports.strip = strip;
exports.parse = parse;
exports.parseWithComments = parseWithComments;
exports.print = print;

function _os() {
  var data = require('os');

  _os = function _os() {
    return data;
  };

  return data;
}

function _detectNewline() {
  var data = _interopRequireDefault(require('detect-newline'));

  _detectNewline = function _detectNewline() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var commentEndRe = /\*\/$/;
var commentStartRe = /^\/\*\*/;
var docblockRe = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/;
var lineCommentRe = /(^|\s+)\/\/([^\r\n]*)/g;
var ltrimNewlineRe = /^(\r?\n)+/;
var multilineRe = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g;
var propertyRe = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g;
var stringStartRe = /(\r?\n|^) *\* ?/g;
var STRING_ARRAY = [];

function extract(contents) {
  var match = contents.match(docblockRe);
  return match ? match[0].trimLeft() : '';
}

function strip(contents) {
  var match = contents.match(docblockRe);
  return match && match[0] ? contents.substring(match[0].length) : contents;
}

function parse(docblock) {
  return parseWithComments(docblock).pragmas;
}

function parseWithComments(docblock) {
  var line = (0, _detectNewline()["default"])(docblock) || _os().EOL;

  docblock = docblock.replace(commentStartRe, '').replace(commentEndRe, '').replace(stringStartRe, '$1'); // Normalize multi-line directives

  var prev = '';

  while (prev !== docblock) {
    prev = docblock;
    docblock = docblock.replace(multilineRe, "".concat(line, "$1 $2").concat(line));
  }

  docblock = docblock.replace(ltrimNewlineRe, '').trimRight();
  var result = Object.create(null);
  var comments = docblock.replace(propertyRe, '').replace(ltrimNewlineRe, '').trimRight();
  var match;

  while (match = propertyRe.exec(docblock)) {
    // strip linecomments from pragmas
    var nextPragma = match[2].replace(lineCommentRe, '');

    if (typeof result[match[1]] === 'string' || Array.isArray(result[match[1]])) {
      result[match[1]] = STRING_ARRAY.concat(result[match[1]], nextPragma);
    } else {
      result[match[1]] = nextPragma;
    }
  }

  return {
    comments: comments,
    pragmas: result
  };
}

function print(_ref) {
  var _ref$comments = _ref.comments,
      comments = _ref$comments === void 0 ? '' : _ref$comments,
      _ref$pragmas = _ref.pragmas,
      pragmas = _ref$pragmas === void 0 ? {} : _ref$pragmas;

  var line = (0, _detectNewline()["default"])(comments) || _os().EOL;

  var head = '/**';
  var start = ' *';
  var tail = ' */';
  var keys = Object.keys(pragmas);
  var printedObject = keys.map(function (key) {
    return printKeyValues(key, pragmas[key]);
  }).reduce(function (arr, next) {
    return arr.concat(next);
  }, []).map(function (keyValue) {
    return start + ' ' + keyValue + line;
  }).join('');

  if (!comments) {
    if (keys.length === 0) {
      return '';
    }

    if (keys.length === 1 && !Array.isArray(pragmas[keys[0]])) {
      var value = pragmas[keys[0]];
      return "".concat(head, " ").concat(printKeyValues(keys[0], value)[0]).concat(tail);
    }
  }

  var printedComments = comments.split(line).map(function (textLine) {
    return "".concat(start, " ").concat(textLine);
  }).join(line) + line;
  return head + line + (comments ? printedComments : '') + (comments && keys.length ? start + line : '') + printedObject + tail;
}

function printKeyValues(key, valueOrArray) {
  return STRING_ARRAY.concat(valueOrArray).map(function (value) {
    return "@".concat(key, " ").concat(value).trim();
  });
}