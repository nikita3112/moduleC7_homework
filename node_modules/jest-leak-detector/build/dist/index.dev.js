'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = void 0;

function _util() {
  var data = require('util');

  _util = function _util() {
    return data;
  };

  return data;
}

function _v() {
  var data = require('v8');

  _v = function _v() {
    return data;
  };

  return data;
}

function _vm() {
  var data = require('vm');

  _vm = function _vm() {
    return data;
  };

  return data;
}

function _jestGetType() {
  var data = require('jest-get-type');

  _jestGetType = function _jestGetType() {
    return data;
  };

  return data;
}

function _prettyFormat() {
  var data = _interopRequireDefault(require('pretty-format'));

  _prettyFormat = function _prettyFormat() {
    return data;
  };

  return data;
}

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var tick = (0, _util().promisify)(setImmediate);

var _default =
/*#__PURE__*/
function () {
  function _default(value) {
    var _this = this;

    _classCallCheck(this, _default);

    _defineProperty(this, '_isReferenceBeingHeld', void 0);

    if ((0, _jestGetType().isPrimitive)(value)) {
      throw new TypeError(['Primitives cannot leak memory.', 'You passed a ' + _typeof(value) + ': <' + (0, _prettyFormat()["default"])(value) + '>'].join(' '));
    }

    var weak;

    try {
      // eslint-disable-next-line import/no-extraneous-dependencies
      weak = require('weak-napi');
    } catch (err) {
      if (!err || err.code !== 'MODULE_NOT_FOUND') {
        throw err;
      }

      throw new Error('The leaking detection mechanism requires the "weak-napi" package to be installed and work. ' + 'Please install it as a dependency on your main project');
    }

    weak(value, function () {
      return _this._isReferenceBeingHeld = false;
    });
    this._isReferenceBeingHeld = true; // Ensure value is not leaked by the closure created by the "weak" callback.

    value = null;
  }

  _createClass(_default, [{
    key: "isLeaking",
    value: function isLeaking() {
      var i;
      return regeneratorRuntime.async(function isLeaking$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              this._runGarbageCollector(); // wait some ticks to allow GC to run properly, see https://github.com/nodejs/node/issues/34636#issuecomment-669366235


              i = 0;

            case 2:
              if (!(i < 10)) {
                _context.next = 8;
                break;
              }

              _context.next = 5;
              return regeneratorRuntime.awrap(tick());

            case 5:
              i++;
              _context.next = 2;
              break;

            case 8:
              return _context.abrupt("return", this._isReferenceBeingHeld);

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "_runGarbageCollector",
    value: function _runGarbageCollector() {
      var isGarbageCollectorHidden = !global.gc; // GC is usually hidden, so we have to expose it before running.

      (0, _v().setFlagsFromString)('--expose-gc');
      (0, _vm().runInNewContext)('gc')(); // The GC was not initially exposed, so let's hide it again.

      if (isGarbageCollectorHidden) {
        (0, _v().setFlagsFromString)('--no-expose-gc');
      }
    }
  }]);

  return _default;
}();

exports["default"] = _default;