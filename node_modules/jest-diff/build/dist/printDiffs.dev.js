'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.diffStringsRaw = exports.diffStringsUnified = exports.createPatchMark = exports.printDiffLines = exports.printAnnotation = exports.countChanges = exports.hasCommonDiff = exports.printCommonLine = exports.printInsertLine = exports.printDeleteLine = void 0;

var _cleanupSemantic = require('./cleanupSemantic');

var _diffLines = require('./diffLines');

var _diffStrings = _interopRequireDefault(require('./diffStrings'));

var _getAlignedDiffs = _interopRequireDefault(require('./getAlignedDiffs'));

var _joinAlignedDiffs = require('./joinAlignedDiffs');

var _normalizeDiffOptions = require('./normalizeDiffOptions');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var formatTrailingSpaces = function formatTrailingSpaces(line, trailingSpaceFormatter) {
  return line.replace(/\s+$/, function (match) {
    return trailingSpaceFormatter(match);
  });
};

var printDiffLine = function printDiffLine(line, isFirstOrLast, color, indicator, trailingSpaceFormatter, emptyFirstOrLastLinePlaceholder) {
  return line.length !== 0 ? color(indicator + ' ' + formatTrailingSpaces(line, trailingSpaceFormatter)) : indicator !== ' ' ? color(indicator) : isFirstOrLast && emptyFirstOrLastLinePlaceholder.length !== 0 ? color(indicator + ' ' + emptyFirstOrLastLinePlaceholder) : '';
};

var printDeleteLine = function printDeleteLine(line, isFirstOrLast, _ref) {
  var aColor = _ref.aColor,
      aIndicator = _ref.aIndicator,
      changeLineTrailingSpaceColor = _ref.changeLineTrailingSpaceColor,
      emptyFirstOrLastLinePlaceholder = _ref.emptyFirstOrLastLinePlaceholder;
  return printDiffLine(line, isFirstOrLast, aColor, aIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
};

exports.printDeleteLine = printDeleteLine;

var printInsertLine = function printInsertLine(line, isFirstOrLast, _ref2) {
  var bColor = _ref2.bColor,
      bIndicator = _ref2.bIndicator,
      changeLineTrailingSpaceColor = _ref2.changeLineTrailingSpaceColor,
      emptyFirstOrLastLinePlaceholder = _ref2.emptyFirstOrLastLinePlaceholder;
  return printDiffLine(line, isFirstOrLast, bColor, bIndicator, changeLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
};

exports.printInsertLine = printInsertLine;

var printCommonLine = function printCommonLine(line, isFirstOrLast, _ref3) {
  var commonColor = _ref3.commonColor,
      commonIndicator = _ref3.commonIndicator,
      commonLineTrailingSpaceColor = _ref3.commonLineTrailingSpaceColor,
      emptyFirstOrLastLinePlaceholder = _ref3.emptyFirstOrLastLinePlaceholder;
  return printDiffLine(line, isFirstOrLast, commonColor, commonIndicator, commonLineTrailingSpaceColor, emptyFirstOrLastLinePlaceholder);
};

exports.printCommonLine = printCommonLine;

var hasCommonDiff = function hasCommonDiff(diffs, isMultiline) {
  if (isMultiline) {
    // Important: Ignore common newline that was appended to multiline strings!
    var iLast = diffs.length - 1;
    return diffs.some(function (diff, i) {
      return diff[0] === _cleanupSemantic.DIFF_EQUAL && (i !== iLast || diff[1] !== '\n');
    });
  }

  return diffs.some(function (diff) {
    return diff[0] === _cleanupSemantic.DIFF_EQUAL;
  });
};

exports.hasCommonDiff = hasCommonDiff;

var countChanges = function countChanges(diffs) {
  var a = 0;
  var b = 0;
  diffs.forEach(function (diff) {
    switch (diff[0]) {
      case _cleanupSemantic.DIFF_DELETE:
        a += 1;
        break;

      case _cleanupSemantic.DIFF_INSERT:
        b += 1;
        break;
    }
  });
  return {
    a: a,
    b: b
  };
};

exports.countChanges = countChanges;

var printAnnotation = function printAnnotation(_ref4, changeCounts) {
  var aAnnotation = _ref4.aAnnotation,
      aColor = _ref4.aColor,
      aIndicator = _ref4.aIndicator,
      bAnnotation = _ref4.bAnnotation,
      bColor = _ref4.bColor,
      bIndicator = _ref4.bIndicator,
      includeChangeCounts = _ref4.includeChangeCounts,
      omitAnnotationLines = _ref4.omitAnnotationLines;

  if (omitAnnotationLines) {
    return '';
  }

  var aRest = '';
  var bRest = '';

  if (includeChangeCounts) {
    var aCount = String(changeCounts.a);
    var bCount = String(changeCounts.b); // Padding right aligns the ends of the annotations.

    var baAnnotationLengthDiff = bAnnotation.length - aAnnotation.length;
    var aAnnotationPadding = ' '.repeat(Math.max(0, baAnnotationLengthDiff));
    var bAnnotationPadding = ' '.repeat(Math.max(0, -baAnnotationLengthDiff)); // Padding left aligns the ends of the counts.

    var baCountLengthDiff = bCount.length - aCount.length;
    var aCountPadding = ' '.repeat(Math.max(0, baCountLengthDiff));
    var bCountPadding = ' '.repeat(Math.max(0, -baCountLengthDiff));
    aRest = aAnnotationPadding + '  ' + aIndicator + ' ' + aCountPadding + aCount;
    bRest = bAnnotationPadding + '  ' + bIndicator + ' ' + bCountPadding + bCount;
  }

  return aColor(aIndicator + ' ' + aAnnotation + aRest) + '\n' + bColor(bIndicator + ' ' + bAnnotation + bRest) + '\n\n';
};

exports.printAnnotation = printAnnotation;

var printDiffLines = function printDiffLines(diffs, options) {
  return printAnnotation(options, countChanges(diffs)) + (options.expand ? (0, _joinAlignedDiffs.joinAlignedDiffsExpand)(diffs, options) : (0, _joinAlignedDiffs.joinAlignedDiffsNoExpand)(diffs, options));
}; // In GNU diff format, indexes are one-based instead of zero-based.


exports.printDiffLines = printDiffLines;

var createPatchMark = function createPatchMark(aStart, aEnd, bStart, bEnd, _ref5) {
  var patchColor = _ref5.patchColor;
  return patchColor("@@ -".concat(aStart + 1, ",").concat(aEnd - aStart, " +").concat(bStart + 1, ",").concat(bEnd - bStart, " @@"));
}; // Compare two strings character-by-character.
// Format as comparison lines in which changed substrings have inverse colors.


exports.createPatchMark = createPatchMark;

var diffStringsUnified = function diffStringsUnified(a, b, options) {
  if (a !== b && a.length !== 0 && b.length !== 0) {
    var isMultiline = a.includes('\n') || b.includes('\n'); // getAlignedDiffs assumes that a newline was appended to the strings.

    var diffs = diffStringsRaw(isMultiline ? a + '\n' : a, isMultiline ? b + '\n' : b, true // cleanupSemantic
    );

    if (hasCommonDiff(diffs, isMultiline)) {
      var optionsNormalized = (0, _normalizeDiffOptions.normalizeDiffOptions)(options);
      var lines = (0, _getAlignedDiffs["default"])(diffs, optionsNormalized.changeColor);
      return printDiffLines(lines, optionsNormalized);
    }
  } // Fall back to line-by-line diff.


  return (0, _diffLines.diffLinesUnified)(a.split('\n'), b.split('\n'), options);
}; // Compare two strings character-by-character.
// Optionally clean up small common substrings, also known as chaff.


exports.diffStringsUnified = diffStringsUnified;

var diffStringsRaw = function diffStringsRaw(a, b, cleanup) {
  var diffs = (0, _diffStrings["default"])(a, b);

  if (cleanup) {
    (0, _cleanupSemantic.cleanupSemantic)(diffs); // impure function
  }

  return diffs;
};

exports.diffStringsRaw = diffStringsRaw;