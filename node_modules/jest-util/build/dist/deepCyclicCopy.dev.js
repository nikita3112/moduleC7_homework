'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports["default"] = deepCyclicCopy;
/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var EMPTY = new Set();

function deepCyclicCopy(value) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    blacklist: EMPTY,
    keepPrototype: false
  };
  var cycles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new WeakMap();

  if (_typeof(value) !== 'object' || value === null) {
    return value;
  } else if (cycles.has(value)) {
    return cycles.get(value);
  } else if (Array.isArray(value)) {
    return deepCyclicCopyArray(value, options, cycles);
  } else {
    return deepCyclicCopyObject(value, options, cycles);
  }
}

function deepCyclicCopyObject(object, options, cycles) {
  var newObject = options.keepPrototype ? Object.create(Object.getPrototypeOf(object)) : {};
  var descriptors = Object.getOwnPropertyDescriptors(object);
  cycles.set(object, newObject);
  Object.keys(descriptors).forEach(function (key) {
    if (options.blacklist && options.blacklist.has(key)) {
      delete descriptors[key];
      return;
    }

    var descriptor = descriptors[key];

    if (typeof descriptor.value !== 'undefined') {
      descriptor.value = deepCyclicCopy(descriptor.value, {
        blacklist: EMPTY,
        keepPrototype: options.keepPrototype
      }, cycles);
    }

    descriptor.configurable = true;
  });
  return Object.defineProperties(newObject, descriptors);
}

function deepCyclicCopyArray(array, options, cycles) {
  var newArray = options.keepPrototype ? new (Object.getPrototypeOf(array).constructor)(array.length) : [];
  var length = array.length;
  cycles.set(array, newArray);

  for (var i = 0; i < length; i++) {
    newArray[i] = deepCyclicCopy(array[i], {
      blacklist: EMPTY,
      keepPrototype: options.keepPrototype
    }, cycles);
  }

  return newArray;
}