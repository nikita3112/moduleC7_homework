"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var vm = require("vm");

var webIDLConversions = require("webidl-conversions");

var _require = require("cssstyle"),
    CSSStyleDeclaration = _require.CSSStyleDeclaration;

var _require2 = require("w3c-hr-time"),
    RawPerformance = _require2.Performance;

var notImplemented = require("./not-implemented");

var _require3 = require("../living/interfaces"),
    installInterfaces = _require3.installInterfaces;

var _require4 = require("../utils"),
    define = _require4.define,
    mixin = _require4.mixin;

var Element = require("../living/generated/Element");

var EventTarget = require("../living/generated/EventTarget");

var PageTransitionEvent = require("../living/generated/PageTransitionEvent");

var namedPropertiesWindow = require("../living/named-properties-window");

var postMessage = require("../living/post-message");

var DOMException = require("domexception/webidl2js-wrapper");

var _require5 = require("abab"),
    btoa = _require5.btoa,
    atob = _require5.atob;

var idlUtils = require("../living/generated/utils");

var WebSocketImpl = require("../living/websockets/WebSocket-impl").implementation;

var BarProp = require("../living/generated/BarProp");

var documents = require("../living/documents.js");

var External = require("../living/generated/External");

var Navigator = require("../living/generated/Navigator");

var Performance = require("../living/generated/Performance");

var Screen = require("../living/generated/Screen");

var Storage = require("../living/generated/Storage");

var Selection = require("../living/generated/Selection");

var reportException = require("../living/helpers/runtime-script-errors");

var _require6 = require("../living/helpers/events"),
    fireAnEvent = _require6.fireAnEvent;

var SessionHistory = require("../living/window/SessionHistory");

var _require7 = require("../living/helpers/style-rules.js"),
    forEachMatchingSheetRuleOfElement = _require7.forEachMatchingSheetRuleOfElement,
    getResolvedValue = _require7.getResolvedValue,
    propertiesWithResolvedValueImplemented = _require7.propertiesWithResolvedValueImplemented,
    SHADOW_DOM_PSEUDO_REGEXP = _require7.SHADOW_DOM_PSEUDO_REGEXP;

var CustomElementRegistry = require("../living/generated/CustomElementRegistry");

var jsGlobals = require("./js-globals.json");

var GlobalEventHandlersImpl = require("../living/nodes/GlobalEventHandlers-impl").implementation;

var WindowEventHandlersImpl = require("../living/nodes/WindowEventHandlers-impl").implementation;

exports.createWindow = function (options) {
  return new Window(options);
};

var jsGlobalEntriesToInstall = Object.entries(jsGlobals).filter(function (_ref) {
  var _ref2 = _slicedToArray(_ref, 1),
      name = _ref2[0];

  return name in global;
}); // https://html.spec.whatwg.org/#the-window-object

function setupWindow(windowInstance, _ref3) {
  var runScripts = _ref3.runScripts;

  if (runScripts === "outside-only" || runScripts === "dangerously") {
    contextifyWindow(windowInstance); // Without this, these globals will only appear to scripts running inside the context using vm.runScript; they will
    // not appear to scripts running from the outside, including to JSDOM implementation code.

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = jsGlobalEntriesToInstall[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var _step$value = _slicedToArray(_step.value, 2),
            globalName = _step$value[0],
            globalPropDesc = _step$value[1];

        var propDesc = _objectSpread({}, globalPropDesc, {
          value: vm.runInContext(globalName, windowInstance)
        });

        Object.defineProperty(windowInstance, globalName, propDesc);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  } else {
    // Without contextifying the window, none of the globals will exist. So, let's at least alias them from the Node.js
    // context. See https://github.com/jsdom/jsdom/issues/2727 for more background and discussion.
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = jsGlobalEntriesToInstall[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var _step2$value = _slicedToArray(_step2.value, 2),
            _globalName = _step2$value[0],
            _globalPropDesc = _step2$value[1];

        var _propDesc = _objectSpread({}, _globalPropDesc, {
          value: global[_globalName]
        });

        Object.defineProperty(windowInstance, _globalName, _propDesc);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
          _iterator2["return"]();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  }

  installInterfaces(windowInstance, ["Window"]);
  var EventTargetConstructor = windowInstance.EventTarget; // eslint-disable-next-line func-name-matching, func-style, no-shadow

  var windowConstructor = function Window() {
    throw new TypeError("Illegal constructor");
  };

  Object.setPrototypeOf(windowConstructor, EventTargetConstructor);
  Object.defineProperty(windowInstance, "Window", {
    configurable: true,
    writable: true,
    value: windowConstructor
  });
  var windowPrototype = Object.create(EventTargetConstructor.prototype);
  Object.defineProperties(windowPrototype, _defineProperty({
    constructor: {
      value: windowConstructor,
      writable: true,
      configurable: true
    }
  }, Symbol.toStringTag, {
    value: "Window",
    configurable: true
  }));
  windowConstructor.prototype = windowPrototype;
  Object.setPrototypeOf(windowInstance, windowPrototype);
  EventTarget.setup(windowInstance, windowInstance);
  mixin(windowInstance, WindowEventHandlersImpl.prototype);
  mixin(windowInstance, GlobalEventHandlersImpl.prototype);

  windowInstance._initGlobalEvents();

  windowInstance._globalObject = windowInstance;
} // NOTE: per https://heycam.github.io/webidl/#Global, all properties on the Window object must be own-properties.
// That is why we assign everything inside of the constructor, instead of using a shared prototype.
// You can verify this in e.g. Firefox or Internet Explorer, which do a good job with Web IDL compliance.


function Window(options) {
  var _this = this;

  setupWindow(this, {
    runScripts: options.runScripts
  });
  var rawPerformance = new RawPerformance();
  var windowInitialized = rawPerformance.now();
  var window = this; ///// PRIVATE DATA PROPERTIES

  this._resourceLoader = options.resourceLoader; // vm initialization is deferred until script processing is activated

  this._globalProxy = this;
  Object.defineProperty(idlUtils.implForWrapper(this), idlUtils.wrapperSymbol, {
    get: function get() {
      return _this._globalProxy;
    }
  }); // List options explicitly to be clear which are passed through

  this._document = documents.createWrapper(window, {
    parsingMode: options.parsingMode,
    contentType: options.contentType,
    encoding: options.encoding,
    cookieJar: options.cookieJar,
    url: options.url,
    lastModified: options.lastModified,
    referrer: options.referrer,
    concurrentNodeIterators: options.concurrentNodeIterators,
    parseOptions: options.parseOptions,
    defaultView: this._globalProxy,
    global: this
  }, {
    alwaysUseDocumentClass: true
  });

  if (vm.isContext(window)) {
    var documentImpl = idlUtils.implForWrapper(window._document);
    documentImpl._defaultView = window._globalProxy = vm.runInContext("this", window);
  }

  var documentOrigin = idlUtils.implForWrapper(this._document)._origin;

  this._origin = documentOrigin; // https://html.spec.whatwg.org/#session-history

  this._sessionHistory = new SessionHistory({
    document: idlUtils.implForWrapper(this._document),
    url: idlUtils.implForWrapper(this._document)._URL,
    stateObject: null
  }, this);
  this._virtualConsole = options.virtualConsole;
  this._runScripts = options.runScripts; // Set up the window as if it's a top level window.
  // If it's not, then references will be corrected by frame/iframe code.

  this._parent = this._top = this._globalProxy;
  this._frameElement = null; // This implements window.frames.length, since window.frames returns a
  // self reference to the window object.  This value is incremented in the
  // HTMLFrameElement implementation.

  this._length = 0;
  this._pretendToBeVisual = options.pretendToBeVisual;
  this._storageQuota = options.storageQuota; // Some properties (such as localStorage and sessionStorage) share data
  // between windows in the same origin. This object is intended
  // to contain such data.

  if (options.commonForOrigin && options.commonForOrigin[documentOrigin]) {
    this._commonForOrigin = options.commonForOrigin;
  } else {
    this._commonForOrigin = _defineProperty({}, documentOrigin, {
      localStorageArea: new Map(),
      sessionStorageArea: new Map(),
      windowsInSameOrigin: [this]
    });
  }

  this._currentOriginData = this._commonForOrigin[documentOrigin]; ///// WEB STORAGE

  this._localStorage = Storage.create(window, [], {
    associatedWindow: this,
    storageArea: this._currentOriginData.localStorageArea,
    type: "localStorage",
    url: this._document.documentURI,
    storageQuota: this._storageQuota
  });
  this._sessionStorage = Storage.create(window, [], {
    associatedWindow: this,
    storageArea: this._currentOriginData.sessionStorageArea,
    type: "sessionStorage",
    url: this._document.documentURI,
    storageQuota: this._storageQuota
  }); ///// SELECTION
  // https://w3c.github.io/selection-api/#dfn-selection

  this._selection = Selection.createImpl(window); // https://w3c.github.io/selection-api/#dom-window

  this.getSelection = function () {
    return window._selection;
  }; ///// GETTERS


  var locationbar = BarProp.create(window);
  var menubar = BarProp.create(window);
  var personalbar = BarProp.create(window);
  var scrollbars = BarProp.create(window);
  var statusbar = BarProp.create(window);
  var toolbar = BarProp.create(window);
  var external = External.create(window);
  var navigator = Navigator.create(window, [], {
    userAgent: this._resourceLoader._userAgent
  });
  var performance = Performance.create(window, [], {
    rawPerformance: rawPerformance
  });
  var screen = Screen.create(window);
  var customElementRegistry = CustomElementRegistry.create(window);
  define(this, {
    get length() {
      return window._length;
    },

    get window() {
      return window._globalProxy;
    },

    get frameElement() {
      return idlUtils.wrapperForImpl(window._frameElement);
    },

    get frames() {
      return window._globalProxy;
    },

    get self() {
      return window._globalProxy;
    },

    get parent() {
      return window._parent;
    },

    get top() {
      return window._top;
    },

    get document() {
      return window._document;
    },

    get external() {
      return external;
    },

    get location() {
      return idlUtils.wrapperForImpl(idlUtils.implForWrapper(window._document)._location);
    },

    get history() {
      return idlUtils.wrapperForImpl(idlUtils.implForWrapper(window._document)._history);
    },

    get navigator() {
      return navigator;
    },

    get locationbar() {
      return locationbar;
    },

    get menubar() {
      return menubar;
    },

    get personalbar() {
      return personalbar;
    },

    get scrollbars() {
      return scrollbars;
    },

    get statusbar() {
      return statusbar;
    },

    get toolbar() {
      return toolbar;
    },

    get performance() {
      return performance;
    },

    get screen() {
      return screen;
    },

    get origin() {
      return window._origin;
    },

    // The origin IDL attribute is defined with [Replaceable].
    set origin(value) {
      Object.defineProperty(this, "origin", {
        value: value,
        writable: true,
        enumerable: true,
        configurable: true
      });
    },

    get localStorage() {
      if (idlUtils.implForWrapper(this._document)._origin === "null") {
        throw DOMException.create(window, ["localStorage is not available for opaque origins", "SecurityError"]);
      }

      return this._localStorage;
    },

    get sessionStorage() {
      if (idlUtils.implForWrapper(this._document)._origin === "null") {
        throw DOMException.create(window, ["sessionStorage is not available for opaque origins", "SecurityError"]);
      }

      return this._sessionStorage;
    },

    get customElements() {
      return customElementRegistry;
    }

  });
  namedPropertiesWindow.initializeWindow(this, this._globalProxy); ///// METHODS
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
  // In the spec the list of active timers is a set of IDs. We make it a map of IDs to Node.js timer objects, so that
  // we can call Node.js-side clearTimeout() when clearing, and thus allow process shutdown faster.

  var listOfActiveTimers = new Map();
  var latestTimerId = 0;

  this.setTimeout = function (handler) {
    var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    if (typeof handler !== "function") {
      handler = webIDLConversions.DOMString(handler);
    }

    timeout = webIDLConversions["long"](timeout);

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    return timerInitializationSteps(handler, timeout, args, {
      methodContext: window,
      repeat: false
    });
  };

  this.setInterval = function (handler) {
    var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    if (typeof handler !== "function") {
      handler = webIDLConversions.DOMString(handler);
    }

    timeout = webIDLConversions["long"](timeout);

    for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
      args[_key2 - 2] = arguments[_key2];
    }

    return timerInitializationSteps(handler, timeout, args, {
      methodContext: window,
      repeat: true
    });
  };

  this.clearTimeout = function () {
    var handle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    handle = webIDLConversions["long"](handle);
    var nodejsTimer = listOfActiveTimers.get(handle);

    if (nodejsTimer) {
      clearTimeout(nodejsTimer);
      listOfActiveTimers["delete"](handle);
    }
  };

  this.clearInterval = function () {
    var handle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    handle = webIDLConversions["long"](handle);
    var nodejsTimer = listOfActiveTimers.get(handle);

    if (nodejsTimer) {
      // We use setTimeout() in timerInitializationSteps even for this.setInterval().
      clearTimeout(nodejsTimer);
      listOfActiveTimers["delete"](handle);
    }
  };

  function timerInitializationSteps(handler, timeout, args, _ref4) {
    var methodContext = _ref4.methodContext,
        repeat = _ref4.repeat,
        previousHandle = _ref4.previousHandle;

    // This appears to be unspecced, but matches browser behavior for close()ed windows.
    if (!methodContext._document) {
      return 0;
    } // TODO: implement timer nesting level behavior.


    var methodContextProxy = methodContext._globalProxy;
    var handle = previousHandle !== undefined ? previousHandle : ++latestTimerId;

    function task() {
      if (!listOfActiveTimers.has(handle)) {
        return;
      }

      try {
        if (typeof handler === "function") {
          handler.apply(methodContextProxy, args);
        } else if (window._runScripts === "dangerously") {
          vm.runInContext(handler, window, {
            filename: window.location.href,
            displayErrors: false
          });
        }
      } catch (e) {
        reportException(window, e, window.location.href);
      }

      if (listOfActiveTimers.has(handle)) {
        if (repeat) {
          timerInitializationSteps(handler, timeout, args, {
            methodContext: methodContext,
            repeat: true,
            previousHandle: handle
          });
        } else {
          listOfActiveTimers["delete"](handle);
        }
      }
    }

    if (timeout < 0) {
      timeout = 0;
    }

    var nodejsTimer = setTimeout(task, timeout);
    listOfActiveTimers.set(handle, nodejsTimer);
    return handle;
  } // https://html.spec.whatwg.org/multipage/imagebitmap-and-animations.html#animation-frames


  var animationFrameCallbackId = 0;
  var mapOfAnimationFrameCallbacks = new Map();
  var animationFrameNodejsInterval = null; // Unlike the spec, where an animation frame happens every 60 Hz regardless, we optimize so that if there are no
  // requestAnimationFrame() calls outstanding, we don't fire the timer. This helps us track that.

  var numberOfOngoingAnimationFrameCallbacks = 0;

  if (this._pretendToBeVisual) {
    var runAnimationFrameCallbacks = function runAnimationFrameCallbacks(now) {
      // Converting to an array is important to get a sync snapshot and thus match spec semantics.
      var callbackHandles = _toConsumableArray(mapOfAnimationFrameCallbacks.keys());

      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = callbackHandles[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var handle = _step3.value;

          // This has() can be false if a callback calls cancelAnimationFrame().
          if (mapOfAnimationFrameCallbacks.has(handle)) {
            var callback = mapOfAnimationFrameCallbacks.get(handle);
            removeAnimationFrameCallback(handle);

            try {
              callback(now);
            } catch (e) {
              reportException(window, e, window.location.href);
            }
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
            _iterator3["return"]();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    };

    var removeAnimationFrameCallback = function removeAnimationFrameCallback(handle) {
      if (mapOfAnimationFrameCallbacks.has(handle)) {
        --numberOfOngoingAnimationFrameCallbacks;

        if (numberOfOngoingAnimationFrameCallbacks === 0) {
          clearInterval(animationFrameNodejsInterval);
        }
      }

      mapOfAnimationFrameCallbacks["delete"](handle);
    };

    this.requestAnimationFrame = function (callback) {
      callback = webIDLConversions.Function(callback);
      var handle = ++animationFrameCallbackId;
      mapOfAnimationFrameCallbacks.set(handle, callback);
      ++numberOfOngoingAnimationFrameCallbacks;

      if (numberOfOngoingAnimationFrameCallbacks === 1) {
        animationFrameNodejsInterval = setInterval(function () {
          runAnimationFrameCallbacks(rawPerformance.now() - windowInitialized);
        }, 1000 / 60);
      }

      return handle;
    };

    this.cancelAnimationFrame = function (handle) {
      handle = webIDLConversions["unsigned long"](handle);
      removeAnimationFrameCallback(handle);
    };
  }

  function stopAllTimers() {
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      for (var _iterator4 = listOfActiveTimers.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        var nodejsTimer = _step4.value;
        clearTimeout(nodejsTimer);
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
          _iterator4["return"]();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }

    listOfActiveTimers.clear();
    clearInterval(animationFrameNodejsInterval);
  }

  function Option(text, value, defaultSelected, selected) {
    if (text === undefined) {
      text = "";
    }

    text = webIDLConversions.DOMString(text);

    if (value !== undefined) {
      value = webIDLConversions.DOMString(value);
    }

    defaultSelected = webIDLConversions["boolean"](defaultSelected);
    selected = webIDLConversions["boolean"](selected);

    var option = window._document.createElement("option");

    var impl = idlUtils.implForWrapper(option);

    if (text !== "") {
      impl.text = text;
    }

    if (value !== undefined) {
      impl.setAttributeNS(null, "value", value);
    }

    if (defaultSelected) {
      impl.setAttributeNS(null, "selected", "");
    }

    impl._selectedness = selected;
    return option;
  }

  Object.defineProperty(Option, "prototype", {
    value: this.HTMLOptionElement.prototype,
    configurable: false,
    enumerable: false,
    writable: false
  });
  Object.defineProperty(window, "Option", {
    value: Option,
    configurable: true,
    enumerable: false,
    writable: true
  });

  function Image() {
    var img = window._document.createElement("img");

    var impl = idlUtils.implForWrapper(img);

    if (arguments.length > 0) {
      impl.setAttributeNS(null, "width", String(arguments[0]));
    }

    if (arguments.length > 1) {
      impl.setAttributeNS(null, "height", String(arguments[1]));
    }

    return img;
  }

  Object.defineProperty(Image, "prototype", {
    value: this.HTMLImageElement.prototype,
    configurable: false,
    enumerable: false,
    writable: false
  });
  Object.defineProperty(window, "Image", {
    value: Image,
    configurable: true,
    enumerable: false,
    writable: true
  });

  function Audio(src) {
    var audio = window._document.createElement("audio");

    var impl = idlUtils.implForWrapper(audio);
    impl.setAttributeNS(null, "preload", "auto");

    if (src !== undefined) {
      impl.setAttributeNS(null, "src", String(src));
    }

    return audio;
  }

  Object.defineProperty(Audio, "prototype", {
    value: this.HTMLAudioElement.prototype,
    configurable: false,
    enumerable: false,
    writable: false
  });
  Object.defineProperty(window, "Audio", {
    value: Audio,
    configurable: true,
    enumerable: false,
    writable: true
  });
  this.postMessage = postMessage(window);

  this.atob = function (str) {
    var result = atob(str);

    if (result === null) {
      throw DOMException.create(window, ["The string to be decoded contains invalid characters.", "InvalidCharacterError"]);
    }

    return result;
  };

  this.btoa = function (str) {
    var result = btoa(str);

    if (result === null) {
      throw DOMException.create(window, ["The string to be encoded contains invalid characters.", "InvalidCharacterError"]);
    }

    return result;
  };

  this.stop = function () {
    var manager = idlUtils.implForWrapper(this._document)._requestManager;

    if (manager) {
      manager.close();
    }
  };

  this.close = function () {
    // Recursively close child frame windows, then ourselves (depth-first).
    for (var i = 0; i < this.length; ++i) {
      this[i].close();
    } // Clear out all listeners. Any in-flight or upcoming events should not get delivered.


    idlUtils.implForWrapper(this)._eventListeners = Object.create(null);

    if (this._document) {
      if (this._document.body) {
        this._document.body.innerHTML = "";
      }

      if (this._document.close) {
        // It's especially important to clear out the listeners here because document.close() causes a "load" event to
        // fire.
        idlUtils.implForWrapper(this._document)._eventListeners = Object.create(null);

        this._document.close();
      }

      var doc = idlUtils.implForWrapper(this._document);

      if (doc._requestManager) {
        doc._requestManager.close();
      }

      delete this._document;
    }

    stopAllTimers();
    WebSocketImpl.cleanUpWindow(this);
  };

  this.getComputedStyle = function (elt) {
    elt = Element.convert(elt);
    var pseudoElt = arguments[1];

    if (pseudoElt !== undefined && pseudoElt !== null) {
      pseudoElt = webIDLConversions.DOMString(pseudoElt);
    }

    if (pseudoElt !== undefined && pseudoElt !== null && pseudoElt !== "") {
      // TODO: Parse pseudoElt
      if (SHADOW_DOM_PSEUDO_REGEXP.test(pseudoElt)) {
        throw new TypeError("Tried to get the computed style of a Shadow DOM pseudo-element.");
      }

      notImplemented("window.computedStyle(elt, pseudoElt)", this);
    }

    var declaration = new CSSStyleDeclaration();
    var forEach = Array.prototype.forEach;
    var _elt = elt,
        style = _elt.style;
    forEachMatchingSheetRuleOfElement(elt, function (rule) {
      forEach.call(rule.style, function (property) {
        declaration.setProperty(property, rule.style.getPropertyValue(property), rule.style.getPropertyPriority(property));
      });
    }); // https://drafts.csswg.org/cssom/#dom-window-getcomputedstyle

    var declarations = Object.keys(propertiesWithResolvedValueImplemented);
    forEach.call(declarations, function (property) {
      declaration.setProperty(property, getResolvedValue(elt, property));
    });
    forEach.call(style, function (property) {
      declaration.setProperty(property, style.getPropertyValue(property), style.getPropertyPriority(property));
    });
    return declaration;
  };

  this.getSelection = function () {
    return window._document.getSelection();
  }; // The captureEvents() and releaseEvents() methods must do nothing


  this.captureEvents = function () {};

  this.releaseEvents = function () {}; ///// PUBLIC DATA PROPERTIES (TODO: should be getters)


  function wrapConsoleMethod(method) {
    return function () {
      var _window$_virtualConso;

      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      (_window$_virtualConso = window._virtualConsole).emit.apply(_window$_virtualConso, [method].concat(args));
    };
  }

  this.console = {
    assert: wrapConsoleMethod("assert"),
    clear: wrapConsoleMethod("clear"),
    count: wrapConsoleMethod("count"),
    countReset: wrapConsoleMethod("countReset"),
    debug: wrapConsoleMethod("debug"),
    dir: wrapConsoleMethod("dir"),
    dirxml: wrapConsoleMethod("dirxml"),
    error: wrapConsoleMethod("error"),
    group: wrapConsoleMethod("group"),
    groupCollapsed: wrapConsoleMethod("groupCollapsed"),
    groupEnd: wrapConsoleMethod("groupEnd"),
    info: wrapConsoleMethod("info"),
    log: wrapConsoleMethod("log"),
    table: wrapConsoleMethod("table"),
    time: wrapConsoleMethod("time"),
    timeLog: wrapConsoleMethod("timeLog"),
    timeEnd: wrapConsoleMethod("timeEnd"),
    trace: wrapConsoleMethod("trace"),
    warn: wrapConsoleMethod("warn")
  };

  function notImplementedMethod(name) {
    return function () {
      notImplemented(name, window);
    };
  }

  define(this, {
    name: "",
    status: "",
    devicePixelRatio: 1,
    innerWidth: 1024,
    innerHeight: 768,
    outerWidth: 1024,
    outerHeight: 768,
    pageXOffset: 0,
    pageYOffset: 0,
    screenX: 0,
    screenLeft: 0,
    screenY: 0,
    screenTop: 0,
    scrollX: 0,
    scrollY: 0,
    alert: notImplementedMethod("window.alert"),
    blur: notImplementedMethod("window.blur"),
    confirm: notImplementedMethod("window.confirm"),
    focus: notImplementedMethod("window.focus"),
    moveBy: notImplementedMethod("window.moveBy"),
    moveTo: notImplementedMethod("window.moveTo"),
    open: notImplementedMethod("window.open"),
    print: notImplementedMethod("window.print"),
    prompt: notImplementedMethod("window.prompt"),
    resizeBy: notImplementedMethod("window.resizeBy"),
    resizeTo: notImplementedMethod("window.resizeTo"),
    scroll: notImplementedMethod("window.scroll"),
    scrollBy: notImplementedMethod("window.scrollBy"),
    scrollTo: notImplementedMethod("window.scrollTo")
  }); ///// INITIALIZATION

  process.nextTick(function () {
    if (!window.document) {
      return; // window might've been closed already
    }

    if (window.document.readyState === "complete") {
      fireAnEvent("load", window, undefined, {}, window.document);
    } else {
      window.document.addEventListener("load", function () {
        fireAnEvent("load", window, undefined, {}, window.document);

        if (!idlUtils.implForWrapper(window._document)._pageShowingFlag) {
          idlUtils.implForWrapper(window._document)._pageShowingFlag = true;
          fireAnEvent("pageshow", window, PageTransitionEvent, {
            persisted: false
          }, window.document);
        }
      });
    }
  });
}

function contextifyWindow(window) {
  if (vm.isContext(window)) {
    return;
  }

  vm.createContext(window);
}