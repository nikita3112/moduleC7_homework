"use strict";
/**
 * Queue for all the resources to be download except async scripts.
 * Async scripts have their own queue AsyncResourceQueue.
 */

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

module.exports =
/*#__PURE__*/
function () {
  function ResourceQueue() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        paused = _ref.paused,
        asyncQueue = _ref.asyncQueue;

    _classCallCheck(this, ResourceQueue);

    this.paused = Boolean(paused);
    this._asyncQueue = asyncQueue;
  }

  _createClass(ResourceQueue, [{
    key: "getLastScript",
    value: function getLastScript() {
      var head = this.tail;

      while (head) {
        if (head.isScript) {
          return head;
        }

        head = head.prev;
      }

      return null;
    }
  }, {
    key: "_moreScripts",
    value: function _moreScripts() {
      var found = false;
      var head = this.tail;

      while (head && !found) {
        found = head.isScript;
        head = head.prev;
      }

      return found;
    }
  }, {
    key: "_notify",
    value: function _notify() {
      if (this._listener) {
        this._listener();
      }
    }
  }, {
    key: "setListener",
    value: function setListener(listener) {
      this._listener = listener;
    }
  }, {
    key: "push",
    value: function push(request, onLoad, onError, keepLast, element) {
      var isScript = element ? element.localName === "script" : false;

      if (!request) {
        if (isScript && !this._moreScripts()) {
          return onLoad();
        }

        request = new Promise(function (resolve) {
          return resolve();
        });
      }

      var q = this;
      var item = {
        isScript: isScript,
        err: null,
        element: element,
        fired: false,
        data: null,
        keepLast: keepLast,
        prev: q.tail,
        check: function check() {
          var _this = this;

          if (!q.paused && !this.prev && this.fired) {
            var promise;

            if (this.err && onError) {
              promise = onError(this.err);
            }

            if (!this.err && onLoad) {
              promise = onLoad(this.data);
            }

            Promise.resolve(promise).then(function () {
              if (_this.next) {
                _this.next.prev = null;

                _this.next.check();
              } else {
                // q.tail===this
                q.tail = null;

                q._notify();
              }

              _this.finished = true;

              if (q._asyncQueue) {
                q._asyncQueue.notifyItem(_this);
              }
            });
          }
        }
      };

      if (q.tail) {
        if (q.tail.keepLast) {
          // if the tail is the load event in document and we receive a new element to load
          // we should add this new request before the load event.
          if (q.tail.prev) {
            q.tail.prev.next = item;
          }

          item.prev = q.tail.prev;
          q.tail.prev = item;
          item.next = q.tail;
        } else {
          q.tail.next = item;
          q.tail = item;
        }
      } else {
        q.tail = item;
      }

      return request.then(function (data) {
        item.fired = 1;
        item.data = data;
        item.check();
      })["catch"](function (err) {
        item.fired = true;
        item.err = err;
        item.check();
      });
    }
  }, {
    key: "resume",
    value: function resume() {
      if (!this.paused) {
        return;
      }

      this.paused = false;
      var head = this.tail;

      while (head && head.prev) {
        head = head.prev;
      }

      if (head) {
        head.check();
      }
    }
  }]);

  return ResourceQueue;
}();