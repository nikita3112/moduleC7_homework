"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var fs = require("fs");

var _require = require("whatwg-url"),
    parseURL = _require.parseURL;

var dataURLFromRecord = require("data-urls").fromURLRecord;

var request = require("request-promise-native");

var wrapCookieJarForRequest = require("../../living/helpers/wrap-cookie-jar-for-request");

var packageVersion = require("../../../../package.json").version;

var IS_BROWSER = Object.prototype.toString.call(process) !== "[object process]";

module.exports =
/*#__PURE__*/
function () {
  function ResourceLoader() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$strictSSL = _ref.strictSSL,
        strictSSL = _ref$strictSSL === void 0 ? true : _ref$strictSSL,
        _ref$proxy = _ref.proxy,
        proxy = _ref$proxy === void 0 ? undefined : _ref$proxy,
        _ref$userAgent = _ref.userAgent,
        userAgent = _ref$userAgent === void 0 ? "Mozilla/5.0 (".concat(process.platform || "unknown OS", ") AppleWebKit/537.36 ") + "(KHTML, like Gecko) jsdom/".concat(packageVersion) : _ref$userAgent;

    _classCallCheck(this, ResourceLoader);

    this._strictSSL = strictSSL;
    this._proxy = proxy;
    this._userAgent = userAgent;
  }

  _createClass(ResourceLoader, [{
    key: "_readDataURL",
    value: function _readDataURL(urlRecord) {
      var dataURL = dataURLFromRecord(urlRecord);
      var timeoutId;
      var promise = new Promise(function (resolve) {
        timeoutId = setTimeout(resolve, 0, dataURL.body);
      });

      promise.abort = function () {
        if (timeoutId !== undefined) {
          clearTimeout(timeoutId);
        }
      };

      return promise;
    }
  }, {
    key: "_readFile",
    value: function _readFile(filePath) {
      var readableStream;
      var abort; // Native Promises doesn't have an "abort" method.

      /*
       * Creating a promise for two reason:
       *   1. fetch always return a promise.
       *   2. We need to add an abort handler.
      */

      var promise = new Promise(function (resolve, reject) {
        readableStream = fs.createReadStream(filePath);
        var data = Buffer.alloc(0);
        abort = reject;
        readableStream.on("error", reject);
        readableStream.on("data", function (chunk) {
          data = Buffer.concat([data, chunk]);
        });
        readableStream.on("end", function () {
          resolve(data);
        });
      });

      promise.abort = function () {
        readableStream.destroy();
        var error = new Error("request canceled by user");
        error.isAbortError = true;
        abort(error);
      };

      return promise;
    }
  }, {
    key: "_getRequestOptions",
    value: function _getRequestOptions(_ref2) {
      var cookieJar = _ref2.cookieJar,
          referrer = _ref2.referrer,
          _ref2$accept = _ref2.accept,
          accept = _ref2$accept === void 0 ? "*/*" : _ref2$accept;
      var requestOptions = {
        encoding: null,
        gzip: true,
        jar: wrapCookieJarForRequest(cookieJar),
        strictSSL: this._strictSSL,
        proxy: this._proxy,
        forever: true,
        headers: {
          "User-Agent": this._userAgent,
          "Accept-Language": "en",
          Accept: accept
        }
      };

      if (referrer && !IS_BROWSER) {
        requestOptions.headers.referer = referrer;
      }

      return requestOptions;
    }
  }, {
    key: "fetch",
    value: function fetch(urlString) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var url = parseURL(urlString);

      if (!url) {
        return Promise.reject(new Error("Tried to fetch invalid URL ".concat(urlString)));
      }

      switch (url.scheme) {
        case "data":
          {
            return this._readDataURL(url);
          }

        case "http":
        case "https":
          {
            var requestOptions = this._getRequestOptions(options);

            return request(urlString, requestOptions);
          }

        case "file":
          {
            // TODO: Improve the URL => file algorithm. See https://github.com/jsdom/jsdom/pull/2279#discussion_r199977987
            var filePath = urlString.replace(/^file:\/\//, "").replace(/^\/([a-z]):\//i, "$1:/").replace(/%20/g, " ");
            return this._readFile(filePath);
          }

        default:
          {
            return Promise.reject(new Error("Tried to fetch URL ".concat(urlString, " with invalid scheme ").concat(url.scheme)));
          }
      }
    }
  }]);

  return ResourceLoader;
}();