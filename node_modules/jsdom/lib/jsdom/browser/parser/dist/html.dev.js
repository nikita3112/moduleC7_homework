"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var parse5 = require("parse5");

var _require = require("../../living/helpers/create-element"),
    _createElement = _require.createElement;

var DocumentType = require("../../living/generated/DocumentType");

var DocumentFragment = require("../../living/generated/DocumentFragment");

var Text = require("../../living/generated/Text");

var Comment = require("../../living/generated/Comment");

var attributes = require("../../living/attributes");

var nodeTypes = require("../../living/node-type");

var serializationAdapter = require("../../living/domparsing/parse5-adapter-serialization");

var _require2 = require("../../living/helpers/custom-elements"),
    customElementReactionsStack = _require2.customElementReactionsStack,
    invokeCEReactions = _require2.invokeCEReactions,
    lookupCEDefinition = _require2.lookupCEDefinition; // Horrible monkey-patch to implement https://github.com/inikulin/parse5/issues/237 and
// https://github.com/inikulin/parse5/issues/285.


var OpenElementStack = require("parse5/lib/parser/open-element-stack");

var openElementStackOriginalPush = OpenElementStack.prototype.push;

OpenElementStack.prototype.push = function () {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  openElementStackOriginalPush.apply(this, args);
  this.treeAdapter._currentElement = this.current;
  var after = this.items[this.stackTop];

  if (after._pushedOnStackOfOpenElements) {
    after._pushedOnStackOfOpenElements();
  }
};

var openElementStackOriginalPop = OpenElementStack.prototype.pop;

OpenElementStack.prototype.pop = function () {
  var before = this.items[this.stackTop];

  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  openElementStackOriginalPop.apply(this, args);
  this.treeAdapter._currentElement = this.current;

  if (before._poppedOffStackOfOpenElements) {
    before._poppedOffStackOfOpenElements();
  }
};

var JSDOMParse5Adapter =
/*#__PURE__*/
function () {
  function JSDOMParse5Adapter(documentImpl) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, JSDOMParse5Adapter);

    this._documentImpl = documentImpl;
    this._globalObject = documentImpl._globalObject;
    this._fragment = options.fragment || false; // Since the createElement hook doesn't provide the parent element, we keep track of this using _currentElement:
    // https://github.com/inikulin/parse5/issues/285. See above horrible monkey-patch for how this is maintained.

    this._currentElement = undefined;
  }

  _createClass(JSDOMParse5Adapter, [{
    key: "_ownerDocument",
    value: function _ownerDocument() {
      var _currentElement = this._currentElement; // The _currentElement is undefined when parsing elements at the root of the document.

      if (_currentElement) {
        return _currentElement.localName === "template" ? _currentElement.content._ownerDocument : _currentElement._ownerDocument;
      }

      return this._documentImpl;
    }
  }, {
    key: "createDocument",
    value: function createDocument() {
      // parse5's model assumes that parse(html) will call into here to create the new Document, then return it. However,
      // jsdom's model assumes we can create a Window (and through that create an empty Document), do some other setup
      // stuff, and then parse, stuffing nodes into that Document as we go. So to adapt between these two models, we just
      // return the already-created Document when asked by parse5 to "create" a Document.
      return this._documentImpl;
    }
  }, {
    key: "createDocumentFragment",
    value: function createDocumentFragment() {
      var ownerDocument = this._ownerDocument();

      return DocumentFragment.createImpl(this._globalObject, [], {
        ownerDocument: ownerDocument
      });
    } // https://html.spec.whatwg.org/#create-an-element-for-the-token

  }, {
    key: "createElement",
    value: function createElement(localName, namespace, attrs) {
      var ownerDocument = this._ownerDocument();

      var isAttribute = attrs.find(function (attr) {
        return attr.name === "is";
      });
      var isValue = isAttribute ? isAttribute.value : null;
      var definition = lookupCEDefinition(ownerDocument, namespace, localName);
      var willExecuteScript = false;

      if (definition !== null && !this._fragment) {
        willExecuteScript = true;
      }

      if (willExecuteScript) {
        ownerDocument._throwOnDynamicMarkupInsertionCounter++;
        customElementReactionsStack.push([]);
      }

      var element = _createElement(ownerDocument, localName, namespace, null, isValue, willExecuteScript);

      this.adoptAttributes(element, attrs);

      if (willExecuteScript) {
        var queue = customElementReactionsStack.pop();
        invokeCEReactions(queue);
        ownerDocument._throwOnDynamicMarkupInsertionCounter--;
      }

      if ("_parserInserted" in element) {
        element._parserInserted = true;
      }

      return element;
    }
  }, {
    key: "createCommentNode",
    value: function createCommentNode(data) {
      var ownerDocument = this._ownerDocument();

      return Comment.createImpl(this._globalObject, [], {
        data: data,
        ownerDocument: ownerDocument
      });
    }
  }, {
    key: "appendChild",
    value: function appendChild(parentNode, newNode) {
      parentNode._append(newNode);
    }
  }, {
    key: "insertBefore",
    value: function insertBefore(parentNode, newNode, referenceNode) {
      parentNode._insert(newNode, referenceNode);
    }
  }, {
    key: "setTemplateContent",
    value: function setTemplateContent(templateElement, contentFragment) {
      // This code makes the glue between jsdom and parse5 HTMLTemplateElement parsing:
      //
      // * jsdom during the construction of the HTMLTemplateElement (for example when create via
      //   `document.createElement("template")`), creates a DocumentFragment and set it into _templateContents.
      // * parse5 when parsing a <template> tag creates an HTMLTemplateElement (`createElement` adapter hook) and also
      //   create a DocumentFragment (`createDocumentFragment` adapter hook).
      //
      // At this point we now have to replace the one created in jsdom with one created by parse5.
      var _templateElement$_tem = templateElement._templateContents,
          _ownerDocument = _templateElement$_tem._ownerDocument,
          _host = _templateElement$_tem._host;
      contentFragment._ownerDocument = _ownerDocument;
      contentFragment._host = _host;
      templateElement._templateContents = contentFragment;
    }
  }, {
    key: "setDocumentType",
    value: function setDocumentType(document, name, publicId, systemId) {
      var ownerDocument = this._ownerDocument();

      var documentType = DocumentType.createImpl(this._globalObject, [], {
        name: name,
        publicId: publicId,
        systemId: systemId,
        ownerDocument: ownerDocument
      });

      document._append(documentType);
    }
  }, {
    key: "setDocumentMode",
    value: function setDocumentMode(document, mode) {
      // TODO: the rest of jsdom ignores this
      document._mode = mode;
    }
  }, {
    key: "detachNode",
    value: function detachNode(node) {
      node.remove();
    }
  }, {
    key: "insertText",
    value: function insertText(parentNode, text) {
      var lastChild = parentNode.lastChild;

      if (lastChild && lastChild.nodeType === nodeTypes.TEXT_NODE) {
        lastChild.data += text;
      } else {
        var ownerDocument = this._ownerDocument();

        var textNode = Text.createImpl(this._globalObject, [], {
          data: text,
          ownerDocument: ownerDocument
        });

        parentNode._append(textNode);
      }
    }
  }, {
    key: "insertTextBefore",
    value: function insertTextBefore(parentNode, text, referenceNode) {
      var previousSibling = referenceNode.previousSibling;

      if (previousSibling && previousSibling.nodeType === nodeTypes.TEXT_NODE) {
        previousSibling.data += text;
      } else {
        var ownerDocument = this._ownerDocument();

        var textNode = Text.createImpl(this._globalObject, [], {
          data: text,
          ownerDocument: ownerDocument
        });

        parentNode._append(textNode, referenceNode);
      }
    }
  }, {
    key: "adoptAttributes",
    value: function adoptAttributes(element, attrs) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = attrs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var attr = _step.value;
          var prefix = attr.prefix === "" ? null : attr.prefix;
          attributes.setAttributeValue(element, attr.name, attr.value, prefix, attr.namespace);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);

  return JSDOMParse5Adapter;
}(); // Assign shared adapters with serializer.


Object.assign(JSDOMParse5Adapter.prototype, serializationAdapter);

function parseFragment(markup, contextElement) {
  var ownerDocument = contextElement.localName === "template" ? contextElement.content._ownerDocument : contextElement._ownerDocument;
  var config = Object.assign({}, ownerDocument._parseOptions, {
    treeAdapter: new JSDOMParse5Adapter(ownerDocument, {
      fragment: true
    })
  });
  return parse5.parseFragment(contextElement, markup, config);
}

function parseIntoDocument(markup, ownerDocument) {
  var config = Object.assign({}, ownerDocument._parseOptions, {
    treeAdapter: new JSDOMParse5Adapter(ownerDocument)
  });
  return parse5.parse(markup, config);
}

module.exports = {
  parseFragment: parseFragment,
  parseIntoDocument: parseIntoDocument
};