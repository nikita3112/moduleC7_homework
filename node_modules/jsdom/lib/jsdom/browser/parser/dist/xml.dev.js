"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = require("saxes"),
    SaxesParser = _require.SaxesParser;

var DOMException = require("domexception/webidl2js-wrapper");

var _require2 = require("../../living/helpers/create-element"),
    createElement = _require2.createElement;

var DocumentFragment = require("../../living/generated/DocumentFragment");

var DocumentType = require("../../living/generated/DocumentType");

var CDATASection = require("../../living/generated/CDATASection");

var Comment = require("../../living/generated/Comment");

var ProcessingInstruction = require("../../living/generated/ProcessingInstruction");

var Text = require("../../living/generated/Text");

var attributes = require("../../living/attributes");

var _require3 = require("../../living/helpers/namespaces"),
    HTML_NS = _require3.HTML_NS;

var HTML5_DOCTYPE = /<!doctype html>/i;
var PUBLIC_DOCTYPE = /<!doctype\s+([^\s]+)\s+public\s+"([^"]+)"\s+"([^"]+)"/i;
var SYSTEM_DOCTYPE = /<!doctype\s+([^\s]+)\s+system\s+"([^"]+)"/i;
var CUSTOM_NAME_DOCTYPE = /<!doctype\s+([^\s>]+)/i;

function parseDocType(globalObject, ownerDocument, html) {
  if (HTML5_DOCTYPE.test(html)) {
    return createDocumentType(globalObject, ownerDocument, "html", "", "");
  }

  var publicPieces = PUBLIC_DOCTYPE.exec(html);

  if (publicPieces) {
    return createDocumentType(globalObject, ownerDocument, publicPieces[1], publicPieces[2], publicPieces[3]);
  }

  var systemPieces = SYSTEM_DOCTYPE.exec(html);

  if (systemPieces) {
    return createDocumentType(globalObject, ownerDocument, systemPieces[1], "", systemPieces[2]);
  }

  var namePiece = CUSTOM_NAME_DOCTYPE.exec(html)[1] || "html";
  return createDocumentType(globalObject, ownerDocument, namePiece, "", "");
}

function createDocumentType(globalObject, ownerDocument, name, publicId, systemId) {
  return DocumentType.createImpl(globalObject, [], {
    ownerDocument: ownerDocument,
    name: name,
    publicId: publicId,
    systemId: systemId
  });
}

function isHTMLTemplateElement(element) {
  return element.tagName === "template" && element.namespaceURI === HTML_NS;
}

function createParser(rootNode, globalObject, saxesOptions) {
  var parser = new SaxesParser(_objectSpread({}, saxesOptions, {
    // Browsers always have namespace support.
    xmlns: true,
    // We force the parser to treat all documents (even documents declaring themselves to be XML 1.1 documents) as XML
    // 1.0 documents. See https://github.com/jsdom/jsdom/issues/2677 for a discussion of the stakes.
    defaultXMLVersion: "1.0",
    forceXMLVersion: true
  }));
  var openStack = [rootNode];

  function getOwnerDocument() {
    var currentElement = openStack[openStack.length - 1];
    return isHTMLTemplateElement(currentElement) ? currentElement._templateContents._ownerDocument : currentElement._ownerDocument;
  }

  function appendChild(child) {
    var parentElement = openStack[openStack.length - 1];

    if (isHTMLTemplateElement(parentElement)) {
      parentElement._templateContents._insert(child, null);
    } else {
      parentElement._insert(child, null);
    }
  }

  parser.on("text", saxesOptions.fragment ? // In a fragment, all text events produced by saxes must result in a text
  // node.
  function (data) {
    var ownerDocument = getOwnerDocument();
    appendChild(Text.createImpl(globalObject, [], {
      data: data,
      ownerDocument: ownerDocument
    }));
  } : // When parsing a whole document, we must ignore those text nodes that are
  // produced outside the root element. Saxes produces events for them,
  // but DOM trees do not record text outside the root element.
  function (data) {
    if (openStack.length > 1) {
      var ownerDocument = getOwnerDocument();
      appendChild(Text.createImpl(globalObject, [], {
        data: data,
        ownerDocument: ownerDocument
      }));
    }
  });
  parser.on("cdata", function (data) {
    var ownerDocument = getOwnerDocument();
    appendChild(CDATASection.createImpl(globalObject, [], {
      data: data,
      ownerDocument: ownerDocument
    }));
  });
  parser.on("opentag", function (tag) {
    var tagLocal = tag.local,
        tagAttributes = tag.attributes;
    var ownerDocument = getOwnerDocument();
    var tagNamespace = tag.uri === "" ? null : tag.uri;
    var tagPrefix = tag.prefix === "" ? null : tag.prefix;
    var isValue = tagAttributes.is === undefined ? null : tagAttributes.is.value;
    var elem = createElement(ownerDocument, tagLocal, tagNamespace, tagPrefix, isValue, true); // We mark a script element as "parser-inserted", which prevents it from
    // being immediately executed.

    if (tagLocal === "script" && tagNamespace === HTML_NS) {
      elem._parserInserted = true;
    }

    for (var _i = 0, _Object$keys = Object.keys(tagAttributes); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      var _tagAttributes$key = tagAttributes[key],
          prefix = _tagAttributes$key.prefix,
          local = _tagAttributes$key.local,
          uri = _tagAttributes$key.uri,
          value = _tagAttributes$key.value;
      attributes.setAttributeValue(elem, local, value, prefix === "" ? null : prefix, uri === "" ? null : uri);
    }

    appendChild(elem);
    openStack.push(elem);
  });
  parser.on("closetag", function () {
    var elem = openStack.pop(); // Once a script is populated, we can execute it.

    if (elem.localName === "script" && elem.namespaceURI === HTML_NS) {
      elem._eval();
    }
  });
  parser.on("comment", function (data) {
    var ownerDocument = getOwnerDocument();
    appendChild(Comment.createImpl(globalObject, [], {
      data: data,
      ownerDocument: ownerDocument
    }));
  });
  parser.on("processinginstruction", function (_ref) {
    var target = _ref.target,
        body = _ref.body;
    var ownerDocument = getOwnerDocument();
    appendChild(ProcessingInstruction.createImpl(globalObject, [], {
      target: target,
      data: body,
      ownerDocument: ownerDocument
    }));
  });
  parser.on("doctype", function (dt) {
    var ownerDocument = getOwnerDocument();
    appendChild(parseDocType(globalObject, ownerDocument, "<!doctype ".concat(dt, ">")));
    var entityMatcher = /<!ENTITY ([^ ]+) "([^"]+)">/g;
    var result;

    while (result = entityMatcher.exec(dt)) {
      var _result = result,
          _result2 = _slicedToArray(_result, 3),
          name = _result2[1],
          value = _result2[2];

      if (!(name in parser.ENTITIES)) {
        parser.ENTITIES[name] = value;
      }
    }
  });
  parser.on("error", function (err) {
    throw DOMException.create(globalObject, [err.message, "SyntaxError"]);
  });
  return parser;
}

function parseFragment(markup, contextElement) {
  var _globalObject = contextElement._globalObject,
      _ownerDocument = contextElement._ownerDocument;
  var fragment = DocumentFragment.createImpl(_globalObject, [], {
    ownerDocument: _ownerDocument
  }); // Only parseFragment needs resolvePrefix per the saxes documentation:
  // https://github.com/lddubeau/saxes#parsing-xml-fragments

  var parser = createParser(fragment, _globalObject, {
    fragment: true,
    resolvePrefix: function resolvePrefix(prefix) {
      // saxes wants undefined as the return value if the prefix is not defined, not null.
      return contextElement.lookupNamespaceURI(prefix) || undefined;
    }
  });
  parser.write(markup).close();
  return fragment;
}

function parseIntoDocument(markup, ownerDocument) {
  var _globalObject = ownerDocument._globalObject;
  var parser = createParser(ownerDocument, _globalObject, {
    fileName: ownerDocument.location && ownerDocument.location.href
  });
  parser.write(markup).close();
  return ownerDocument;
}

module.exports = {
  parseFragment: parseFragment,
  parseIntoDocument: parseIntoDocument
};