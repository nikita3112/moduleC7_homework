"use strict";

var path = require("path");

var whatwgURL = require("whatwg-url");

var _require = require("./living/helpers/internal-constants"),
    domSymbolTree = _require.domSymbolTree;

var SYMBOL_TREE_POSITION = require("symbol-tree").TreePosition;

exports.toFileUrl = function (fileName) {
  // Beyond just the `path.resolve`, this is mostly for the benefit of Windows,
  // where we need to convert "\" to "/" and add an extra "/" prefix before the
  // drive letter.
  var pathname = path.resolve(process.cwd(), fileName).replace(/\\/g, "/");

  if (pathname[0] !== "/") {
    pathname = "/" + pathname;
  } // path might contain spaces, so convert those to %20


  return "file://" + encodeURI(pathname);
};
/**
 * Define a set of properties on an object, by copying the property descriptors
 * from the original object.
 *
 * - `object` {Object} the target object
 * - `properties` {Object} the source from which to copy property descriptors
 */


exports.define = function define(object, properties) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = Object.getOwnPropertyNames(properties)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var name = _step.value;
      var propDesc = Object.getOwnPropertyDescriptor(properties, name);
      Object.defineProperty(object, name, propDesc);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};
/**
 * Define a list of constants on a constructor and its .prototype
 *
 * - `Constructor` {Function} the constructor to define the constants on
 * - `propertyMap` {Object}  key/value map of properties to define
 */


exports.addConstants = function addConstants(Constructor, propertyMap) {
  for (var property in propertyMap) {
    var value = propertyMap[property];
    addConstant(Constructor, property, value);
    addConstant(Constructor.prototype, property, value);
  }
};

function addConstant(object, property, value) {
  Object.defineProperty(object, property, {
    configurable: false,
    enumerable: true,
    writable: false,
    value: value
  });
}

exports.mixin = function (target, source) {
  var keys = Reflect.ownKeys(source);

  for (var i = 0; i < keys.length; ++i) {
    if (keys[i] in target) {
      continue;
    }

    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));
  }
};

var memoizeQueryTypeCounter = 0;
/**
 * Returns a version of a method that memoizes specific types of calls on the object
 *
 * - `fn` {Function} the method to be memozied
 */

exports.memoizeQuery = function memoizeQuery(fn) {
  // Only memoize query functions with arity <= 2
  if (fn.length > 2) {
    return fn;
  }

  var type = memoizeQueryTypeCounter++;
  return function () {
    if (!this._memoizedQueries) {
      return fn.apply(this, arguments);
    }

    if (!this._memoizedQueries[type]) {
      this._memoizedQueries[type] = Object.create(null);
    }

    var key;

    if (arguments.length === 1 && typeof arguments[0] === "string") {
      key = arguments[0];
    } else if (arguments.length === 2 && typeof arguments[0] === "string" && typeof arguments[1] === "string") {
      key = arguments[0] + "::" + arguments[1];
    } else {
      return fn.apply(this, arguments);
    }

    if (!(key in this._memoizedQueries[type])) {
      this._memoizedQueries[type][key] = fn.apply(this, arguments);
    }

    return this._memoizedQueries[type][key];
  };
};

function isValidAbsoluteURL(str) {
  return whatwgURL.parseURL(str) !== null;
}

exports.isValidTargetOrigin = function (str) {
  return str === "*" || str === "/" || isValidAbsoluteURL(str);
};

exports.simultaneousIterators =
/*#__PURE__*/
regeneratorRuntime.mark(function _callee(first, second) {
  var firstResult, secondResult;
  return regeneratorRuntime.wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          firstResult = first.next();
          secondResult = second.next();

          if (!(firstResult.done && secondResult.done)) {
            _context.next = 4;
            break;
          }

          return _context.abrupt("return");

        case 4:
          _context.next = 6;
          return [firstResult.done ? null : firstResult.value, secondResult.done ? null : secondResult.value];

        case 6:
          _context.next = 0;
          break;

        case 8:
        case "end":
          return _context.stop();
      }
    }
  }, _callee);
});

exports.treeOrderSorter = function (a, b) {
  var compare = domSymbolTree.compareTreePosition(a, b);

  if (compare & SYMBOL_TREE_POSITION.PRECEDING) {
    // b is preceding a
    return 1;
  }

  if (compare & SYMBOL_TREE_POSITION.FOLLOWING) {
    return -1;
  } // disconnected or equal:


  return 0;
};
/* eslint-disable global-require */


exports.Canvas = null;
var canvasInstalled = false;

try {
  require.resolve("canvas");

  canvasInstalled = true;
} catch (e) {// canvas is not installed
}

if (canvasInstalled) {
  var Canvas = require("canvas");

  if (typeof Canvas.createCanvas === "function") {
    // In browserify, the require will succeed but return an empty object
    exports.Canvas = Canvas;
  }
}