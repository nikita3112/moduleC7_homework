"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require("../helpers/internal-constants"),
    domSymbolTree = _require.domSymbolTree;

var _require2 = require("./helpers"),
    filter = _require2.filter,
    FILTER_ACCEPT = _require2.FILTER_ACCEPT;

exports.implementation =
/*#__PURE__*/
function () {
  function NodeIteratorImpl(globalObject, args, privateData) {
    _classCallCheck(this, NodeIteratorImpl);

    this._active = false;
    this.root = privateData.root;
    this.whatToShow = privateData.whatToShow;
    this.filter = privateData.filter;
    this._referenceNode = this.root;
    this._pointerBeforeReferenceNode = true; // This is used to deactive the NodeIterator if there are too many working in a Document at the same time.
    // Without weak references, a JS implementation of NodeIterator will leak, since we can't know when to clean it up.
    // This ensures we force a clean up of those beyond some maximum (specified by the Document).

    this._working = true;
    this._workingNodeIteratorsMax = privateData.workingNodeIteratorsMax;
    this._globalObject = globalObject;
  }

  _createClass(NodeIteratorImpl, [{
    key: "nextNode",
    value: function nextNode() {
      this._throwIfNotWorking();

      return this._traverse("next");
    }
  }, {
    key: "previousNode",
    value: function previousNode() {
      this._throwIfNotWorking();

      return this._traverse("previous");
    }
  }, {
    key: "detach",
    value: function detach() {} // Intentionally do nothing, per spec.
    // Called by Documents.

  }, {
    key: "_preRemovingSteps",
    value: function _preRemovingSteps(toBeRemovedNode) {
      // Second clause is https://github.com/whatwg/dom/issues/496
      if (!toBeRemovedNode.contains(this._referenceNode) || toBeRemovedNode === this.root) {
        return;
      }

      if (this._pointerBeforeReferenceNode) {
        var next = null;
        var candidateForNext = domSymbolTree.following(toBeRemovedNode, {
          skipChildren: true
        });

        while (candidateForNext !== null) {
          if (this.root.contains(candidateForNext)) {
            next = candidateForNext;
            break;
          }

          candidateForNext = domSymbolTree.following(candidateForNext, {
            skipChildren: true
          });
        }

        if (next !== null) {
          this._referenceNode = next;
          return;
        }

        this._pointerBeforeReferenceNode = false;
      }

      var previousSibling = toBeRemovedNode.previousSibling;
      this._referenceNode = previousSibling === null ? toBeRemovedNode.parentNode : domSymbolTree.lastInclusiveDescendant(toBeRemovedNode.previousSibling);
    } // Only called by getters and methods that are affected by the pre-removing steps

  }, {
    key: "_throwIfNotWorking",
    value: function _throwIfNotWorking() {
      if (!this._working) {
        throw Error("This NodeIterator is no longer working. More than ".concat(this._workingNodeIteratorsMax, " iterators are ") + "being used concurrently. You can increase the 'concurrentNodeIterators' option to make this error go away.");
      }
    }
  }, {
    key: "_traverse",
    value: function _traverse(direction) {
      var node = this._referenceNode;
      var beforeNode = this._pointerBeforeReferenceNode;

      while (true) {
        if (direction === "next") {
          if (!beforeNode) {
            node = domSymbolTree.following(node, {
              root: this.root
            });

            if (!node) {
              return null;
            }
          }

          beforeNode = false;
        } else if (direction === "previous") {
          if (beforeNode) {
            node = domSymbolTree.preceding(node, {
              root: this.root
            });

            if (!node) {
              return null;
            }
          }

          beforeNode = true;
        }

        var result = filter(this, node);

        if (result === FILTER_ACCEPT) {
          break;
        }
      }

      this._referenceNode = node;
      this._pointerBeforeReferenceNode = beforeNode;
      return node;
    }
  }, {
    key: "referenceNode",
    get: function get() {
      this._throwIfNotWorking();

      return this._referenceNode;
    }
  }, {
    key: "pointerBeforeReferenceNode",
    get: function get() {
      this._throwIfNotWorking();

      return this._pointerBeforeReferenceNode;
    }
  }]);

  return NodeIteratorImpl;
}();