"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DOMException = require("domexception/webidl2js-wrapper");

var _require = require("./helpers"),
    filter = _require.filter,
    FILTER_ACCEPT = _require.FILTER_ACCEPT,
    FILTER_REJECT = _require.FILTER_REJECT,
    FILTER_SKIP = _require.FILTER_SKIP;

var FIRST = false;
var LAST = true;
var NEXT = false;
var PREVIOUS = true;

exports.implementation =
/*#__PURE__*/
function () {
  function TreeWalkerImpl(globalObject, args, privateData) {
    _classCallCheck(this, TreeWalkerImpl);

    this._active = false;
    this.root = privateData.root;
    this.currentNode = this.root;
    this.whatToShow = privateData.whatToShow;
    this.filter = privateData.filter;
    this._globalObject = globalObject;
  }

  _createClass(TreeWalkerImpl, [{
    key: "parentNode",
    value: function parentNode() {
      var node = this._currentNode;

      while (node !== null && node !== this.root) {
        node = node.parentNode;

        if (node !== null && filter(this, node) === FILTER_ACCEPT) {
          return this._currentNode = node;
        }
      }

      return null;
    }
  }, {
    key: "firstChild",
    value: function firstChild() {
      return this._traverseChildren(FIRST);
    }
  }, {
    key: "lastChild",
    value: function lastChild() {
      return this._traverseChildren(LAST);
    }
  }, {
    key: "previousSibling",
    value: function previousSibling() {
      return this._traverseSiblings(PREVIOUS);
    }
  }, {
    key: "nextSibling",
    value: function nextSibling() {
      return this._traverseSiblings(NEXT);
    }
  }, {
    key: "previousNode",
    value: function previousNode() {
      var node = this._currentNode;

      while (node !== this.root) {
        var sibling = node.previousSibling;

        while (sibling !== null) {
          node = sibling;
          var result = filter(this, node);

          while (result !== FILTER_REJECT && node.hasChildNodes()) {
            node = node.lastChild;
            result = filter(this, node);
          }

          if (result === FILTER_ACCEPT) {
            return this._currentNode = node;
          }

          sibling = node.previousSibling;
        }

        if (node === this.root || node.parentNode === null) {
          return null;
        }

        node = node.parentNode;

        if (filter(this, node) === FILTER_ACCEPT) {
          return this._currentNode = node;
        }
      }

      return null;
    }
  }, {
    key: "nextNode",
    value: function nextNode() {
      var node = this._currentNode;
      var result = FILTER_ACCEPT;

      for (;;) {
        while (result !== FILTER_REJECT && node.hasChildNodes()) {
          node = node.firstChild;
          result = filter(this, node);

          if (result === FILTER_ACCEPT) {
            return this._currentNode = node;
          }
        }

        do {
          if (node === this.root) {
            return null;
          }

          var sibling = node.nextSibling;

          if (sibling !== null) {
            node = sibling;
            break;
          }

          node = node.parentNode;
        } while (node !== null);

        if (node === null) {
          return null;
        }

        result = filter(this, node);

        if (result === FILTER_ACCEPT) {
          return this._currentNode = node;
        }
      }
    }
  }, {
    key: "_traverseChildren",
    value: function _traverseChildren(type) {
      var node = this._currentNode;
      node = type === FIRST ? node.firstChild : node.lastChild;

      if (node === null) {
        return null;
      }

      main: for (;;) {
        var result = filter(this, node);

        if (result === FILTER_ACCEPT) {
          return this._currentNode = node;
        }

        if (result === FILTER_SKIP) {
          var child = type === FIRST ? node.firstChild : node.lastChild;

          if (child !== null) {
            node = child;
            continue;
          }
        }

        for (;;) {
          var sibling = type === FIRST ? node.nextSibling : node.previousSibling;

          if (sibling !== null) {
            node = sibling;
            continue main;
          }

          var parent = node.parentNode;

          if (parent === null || parent === this.root || parent === this._currentNode) {
            return null;
          }

          node = parent;
        }
      }
    }
  }, {
    key: "_traverseSiblings",
    value: function _traverseSiblings(type) {
      var node = this._currentNode;

      if (node === this.root) {
        return null;
      }

      for (;;) {
        var sibling = type === NEXT ? node.nextSibling : node.previousSibling;

        while (sibling !== null) {
          node = sibling;
          var result = filter(this, node);

          if (result === FILTER_ACCEPT) {
            return this._currentNode = node;
          }

          sibling = type === NEXT ? node.firstChild : node.lastChild;

          if (result === FILTER_REJECT || sibling === null) {
            sibling = type === NEXT ? node.nextSibling : node.previousSibling;
          }
        }

        node = node.parentNode;

        if (node === null || node === this.root) {
          return null;
        }

        if (filter(this, node) === FILTER_ACCEPT) {
          return null;
        }
      }
    }
  }, {
    key: "currentNode",
    get: function get() {
      return this._currentNode;
    },
    set: function set(node) {
      if (node === null) {
        throw DOMException.create(this._globalObject, ["Cannot set currentNode to null", "NotSupportedError"]);
      }

      this._currentNode = node;
    }
  }]);

  return TreeWalkerImpl;
}();