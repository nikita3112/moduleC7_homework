"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Blob = require("../generated/Blob");

var _require = require("../generated/utils"),
    isArrayBuffer = _require.isArrayBuffer;

function convertLineEndingsToNative(s) {
  // jsdom always pretends to be *nix, for consistency.
  // See also https://github.com/jsdom/jsdom/issues/2396.
  return s.replace(/\r\n|\r|\n/g, "\n");
}

exports.implementation =
/*#__PURE__*/
function () {
  function BlobImpl(globalObject, args) {
    _classCallCheck(this, BlobImpl);

    var parts = args[0];
    var properties = args[1];
    var buffers = [];

    if (parts !== undefined) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var part = _step.value;
          var buffer = void 0;

          if (isArrayBuffer(part)) {
            buffer = Buffer.from(part);
          } else if (ArrayBuffer.isView(part)) {
            buffer = Buffer.from(part.buffer, part.byteOffset, part.byteLength);
          } else if (Blob.isImpl(part)) {
            buffer = part._buffer;
          } else {
            var s = part;

            if (properties.endings === "native") {
              s = convertLineEndingsToNative(part);
            }

            buffer = Buffer.from(s);
          }

          buffers.push(buffer);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    this._buffer = Buffer.concat(buffers);
    this._globalObject = globalObject;
    this.type = properties.type;

    if (/[^\u0020-\u007E]/.test(this.type)) {
      this.type = "";
    } else {
      this.type = this.type.toLowerCase();
    }
  }

  _createClass(BlobImpl, [{
    key: "slice",
    value: function slice(start, end, contentType) {
      var size = this.size;
      var relativeStart;
      var relativeEnd;
      var relativeContentType;

      if (start === undefined) {
        relativeStart = 0;
      } else if (start < 0) {
        relativeStart = Math.max(size + start, 0);
      } else {
        relativeStart = Math.min(start, size);
      }

      if (end === undefined) {
        relativeEnd = size;
      } else if (end < 0) {
        relativeEnd = Math.max(size + end, 0);
      } else {
        relativeEnd = Math.min(end, size);
      }

      if (contentType === undefined) {
        relativeContentType = "";
      } else {
        // sanitization (lower case and invalid char check) is done in the
        // constructor
        relativeContentType = contentType;
      }

      var span = Math.max(relativeEnd - relativeStart, 0);
      var buffer = this._buffer;
      var slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
      var blob = Blob.createImpl(this._globalObject, [[], {
        type: relativeContentType
      }], {});
      blob._buffer = slicedBuffer;
      return blob;
    }
  }, {
    key: "size",
    get: function get() {
      return this._buffer.length;
    }
  }]);

  return BlobImpl;
}();