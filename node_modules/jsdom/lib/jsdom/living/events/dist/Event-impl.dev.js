"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var idlUtils = require("../generated/utils");

var EventInit = require("../generated/EventInit");

var EventImpl =
/*#__PURE__*/
function () {
  function EventImpl(globalObject, args, privateData) {
    _classCallCheck(this, EventImpl);

    var _args = _slicedToArray(args, 2),
        type = _args[0],
        _args$ = _args[1],
        eventInitDict = _args$ === void 0 ? this.constructor.defaultInit : _args$;

    this.type = type;
    this.bubbles = false;
    this.cancelable = false;

    for (var key in eventInitDict) {
      if (key in this.constructor.defaultInit) {
        this[key] = eventInitDict[key];
      }
    }

    for (var _key in this.constructor.defaultInit) {
      if (!(_key in this)) {
        this[_key] = this.constructor.defaultInit[_key];
      }
    }

    this.target = null;
    this.currentTarget = null;
    this.eventPhase = 0;
    this._globalObject = globalObject;
    this._initializedFlag = true;
    this._stopPropagationFlag = false;
    this._stopImmediatePropagationFlag = false;
    this._canceledFlag = false;
    this._inPassiveListenerFlag = false;
    this._dispatchFlag = false;
    this._path = [];
    this.isTrusted = privateData.isTrusted || false;
    this.timeStamp = Date.now();
  } // https://dom.spec.whatwg.org/#set-the-canceled-flag


  _createClass(EventImpl, [{
    key: "_setTheCanceledFlag",
    value: function _setTheCanceledFlag() {
      if (this.cancelable && !this._inPassiveListenerFlag) {
        this._canceledFlag = true;
      }
    }
  }, {
    key: "stopPropagation",
    value: function stopPropagation() {
      this._stopPropagationFlag = true;
    }
  }, {
    key: "stopImmediatePropagation",
    value: function stopImmediatePropagation() {
      this._stopPropagationFlag = true;
      this._stopImmediatePropagationFlag = true;
    }
  }, {
    key: "preventDefault",
    value: function preventDefault() {
      this._setTheCanceledFlag();
    } // https://dom.spec.whatwg.org/#dom-event-composedpath
    // Current implementation is based of https://whatpr.org/dom/699.html#dom-event-composedpath
    // due to a bug in composed path implementation https://github.com/whatwg/dom/issues/684

  }, {
    key: "composedPath",
    value: function composedPath() {
      var composedPath = [];
      var currentTarget = this.currentTarget,
          path = this._path;

      if (path.length === 0) {
        return composedPath;
      }

      composedPath.push(currentTarget);
      var currentTargetIndex = 0;
      var currentTargetHiddenSubtreeLevel = 0;

      for (var index = path.length - 1; index >= 0; index--) {
        var _path$index = path[index],
            item = _path$index.item,
            rootOfClosedTree = _path$index.rootOfClosedTree,
            slotInClosedTree = _path$index.slotInClosedTree;

        if (rootOfClosedTree) {
          currentTargetHiddenSubtreeLevel++;
        }

        if (item === idlUtils.implForWrapper(currentTarget)) {
          currentTargetIndex = index;
          break;
        }

        if (slotInClosedTree) {
          currentTargetHiddenSubtreeLevel--;
        }
      }

      var currentHiddenLevel = currentTargetHiddenSubtreeLevel;
      var maxHiddenLevel = currentTargetHiddenSubtreeLevel;

      for (var i = currentTargetIndex - 1; i >= 0; i--) {
        var _path$i = path[i],
            _item = _path$i.item,
            _rootOfClosedTree = _path$i.rootOfClosedTree,
            _slotInClosedTree = _path$i.slotInClosedTree;

        if (_rootOfClosedTree) {
          currentHiddenLevel++;
        }

        if (currentHiddenLevel <= maxHiddenLevel) {
          composedPath.unshift(idlUtils.wrapperForImpl(_item));
        }

        if (_slotInClosedTree) {
          currentHiddenLevel--;

          if (currentHiddenLevel < maxHiddenLevel) {
            maxHiddenLevel = currentHiddenLevel;
          }
        }
      }

      currentHiddenLevel = currentTargetHiddenSubtreeLevel;
      maxHiddenLevel = currentTargetHiddenSubtreeLevel;

      for (var _index = currentTargetIndex + 1; _index < path.length; _index++) {
        var _path$_index = path[_index],
            _item2 = _path$_index.item,
            _rootOfClosedTree2 = _path$_index.rootOfClosedTree,
            _slotInClosedTree2 = _path$_index.slotInClosedTree;

        if (_slotInClosedTree2) {
          currentHiddenLevel++;
        }

        if (currentHiddenLevel <= maxHiddenLevel) {
          composedPath.push(idlUtils.wrapperForImpl(_item2));
        }

        if (_rootOfClosedTree2) {
          currentHiddenLevel--;

          if (currentHiddenLevel < maxHiddenLevel) {
            maxHiddenLevel = currentHiddenLevel;
          }
        }
      }

      return composedPath;
    }
  }, {
    key: "_initialize",
    value: function _initialize(type, bubbles, cancelable) {
      this.type = type;
      this._initializedFlag = true;
      this._stopPropagationFlag = false;
      this._stopImmediatePropagationFlag = false;
      this._canceledFlag = false;
      this.isTrusted = false;
      this.target = null;
      this.bubbles = bubbles;
      this.cancelable = cancelable;
    }
  }, {
    key: "initEvent",
    value: function initEvent(type, bubbles, cancelable) {
      if (this._dispatchFlag) {
        return;
      }

      this._initialize(type, bubbles, cancelable);
    }
  }, {
    key: "srcElement",
    get: function get() {
      return this.target;
    }
  }, {
    key: "returnValue",
    get: function get() {
      return !this._canceledFlag;
    },
    set: function set(v) {
      if (v === false) {
        this._setTheCanceledFlag();
      }
    }
  }, {
    key: "defaultPrevented",
    get: function get() {
      return this._canceledFlag;
    }
  }, {
    key: "cancelBubble",
    get: function get() {
      return this._stopPropagationFlag;
    },
    set: function set(v) {
      if (v) {
        this._stopPropagationFlag = true;
      }
    }
  }]);

  return EventImpl;
}();

EventImpl.defaultInit = EventInit.convert(undefined);
module.exports = {
  implementation: EventImpl
};