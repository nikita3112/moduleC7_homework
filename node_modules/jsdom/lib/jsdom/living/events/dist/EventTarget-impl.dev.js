"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DOMException = require("domexception/webidl2js-wrapper");

var reportException = require("../helpers/runtime-script-errors");

var idlUtils = require("../generated/utils");

var _require = require("../helpers/node"),
    nodeRoot = _require.nodeRoot;

var _require2 = require("../helpers/shadow-dom"),
    isNode = _require2.isNode,
    isShadowRoot = _require2.isShadowRoot,
    isSlotable = _require2.isSlotable,
    getEventTargetParent = _require2.getEventTargetParent,
    isShadowInclusiveAncestor = _require2.isShadowInclusiveAncestor,
    retarget = _require2.retarget;

var MouseEvent = require("../generated/MouseEvent");

var EVENT_PHASE = {
  NONE: 0,
  CAPTURING_PHASE: 1,
  AT_TARGET: 2,
  BUBBLING_PHASE: 3
};

var EventTargetImpl =
/*#__PURE__*/
function () {
  function EventTargetImpl(globalObject) {
    _classCallCheck(this, EventTargetImpl);

    this._globalObject = globalObject;
    this._eventListeners = Object.create(null);
  }

  _createClass(EventTargetImpl, [{
    key: "addEventListener",
    value: function addEventListener(type, callback, options) {
      options = normalizeEventHandlerOptions(options, ["capture", "once", "passive"]);

      if (callback === null) {
        return;
      }

      if (!this._eventListeners[type]) {
        this._eventListeners[type] = [];
      }

      for (var i = 0; i < this._eventListeners[type].length; ++i) {
        var listener = this._eventListeners[type][i];

        if (listener.callback.objectReference === callback.objectReference && listener.options.capture === options.capture) {
          return;
        }
      }

      this._eventListeners[type].push({
        callback: callback,
        options: options
      });
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, callback, options) {
      options = normalizeEventHandlerOptions(options, ["capture"]);

      if (callback === null) {
        // Optimization, not in the spec.
        return;
      }

      if (!this._eventListeners[type]) {
        return;
      }

      for (var i = 0; i < this._eventListeners[type].length; ++i) {
        var listener = this._eventListeners[type][i];

        if (listener.callback.objectReference === callback.objectReference && listener.options.capture === options.capture) {
          this._eventListeners[type].splice(i, 1);

          break;
        }
      }
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(eventImpl) {
      if (eventImpl._dispatchFlag || !eventImpl._initializedFlag) {
        throw DOMException.create(this._globalObject, ["Tried to dispatch an uninitialized event", "InvalidStateError"]);
      }

      if (eventImpl.eventPhase !== EVENT_PHASE.NONE) {
        throw DOMException.create(this._globalObject, ["Tried to dispatch a dispatching event", "InvalidStateError"]);
      }

      eventImpl.isTrusted = false;
      return this._dispatch(eventImpl);
    } // https://dom.spec.whatwg.org/#get-the-parent

  }, {
    key: "_getTheParent",
    value: function _getTheParent() {
      return null;
    } // https://dom.spec.whatwg.org/#concept-event-dispatch
    // legacyOutputDidListenersThrowFlag optional parameter is not necessary here since it is only used by indexDB.

  }, {
    key: "_dispatch",
    value: function _dispatch(eventImpl, targetOverride
    /* , legacyOutputDidListenersThrowFlag */
    ) {
      var targetImpl = this;
      var clearTargets = false;
      var activationTarget = null;
      eventImpl._dispatchFlag = true;
      targetOverride = targetOverride || targetImpl;
      var relatedTarget = retarget(eventImpl.relatedTarget, targetImpl);

      if (targetImpl !== relatedTarget || targetImpl === eventImpl.relatedTarget) {
        var touchTargets = [];
        appendToEventPath(eventImpl, targetImpl, targetOverride, relatedTarget, touchTargets, false);
        var isActivationEvent = MouseEvent.isImpl(eventImpl) && eventImpl.type === "click";

        if (isActivationEvent && targetImpl._hasActivationBehavior) {
          activationTarget = targetImpl;
        }

        var slotInClosedTree = false;
        var slotable = isSlotable(targetImpl) && targetImpl._assignedSlot ? targetImpl : null;
        var parent = getEventTargetParent(targetImpl, eventImpl); // Populate event path
        // https://dom.spec.whatwg.org/#event-path

        while (parent !== null) {
          if (slotable !== null) {
            if (parent.localName !== "slot") {
              throw new Error("JSDOM Internal Error: Expected parent to be a Slot");
            }

            slotable = null;
            var parentRoot = nodeRoot(parent);

            if (isShadowRoot(parentRoot) && parentRoot.mode === "closed") {
              slotInClosedTree = true;
            }
          }

          if (isSlotable(parent) && parent._assignedSlot) {
            slotable = parent;
          }

          relatedTarget = retarget(eventImpl.relatedTarget, parent);

          if (isNode(parent) && isShadowInclusiveAncestor(nodeRoot(targetImpl), parent) || idlUtils.wrapperForImpl(parent).constructor.name === "Window") {
            if (isActivationEvent && eventImpl.bubbles && activationTarget === null && parent._hasActivationBehavior) {
              activationTarget = parent;
            }

            appendToEventPath(eventImpl, parent, null, relatedTarget, touchTargets, slotInClosedTree);
          } else if (parent === relatedTarget) {
            parent = null;
          } else {
            targetImpl = parent;

            if (isActivationEvent && activationTarget === null && targetImpl._hasActivationBehavior) {
              activationTarget = targetImpl;
            }

            appendToEventPath(eventImpl, parent, targetImpl, relatedTarget, touchTargets, slotInClosedTree);
          }

          if (parent !== null) {
            parent = getEventTargetParent(parent, eventImpl);
          }

          slotInClosedTree = false;
        }

        var clearTargetsStructIndex = -1;

        for (var i = eventImpl._path.length - 1; i >= 0 && clearTargetsStructIndex === -1; i--) {
          if (eventImpl._path[i].target !== null) {
            clearTargetsStructIndex = i;
          }
        }

        var clearTargetsStruct = eventImpl._path[clearTargetsStructIndex];
        clearTargets = isNode(clearTargetsStruct.target) && isShadowRoot(nodeRoot(clearTargetsStruct.target)) || isNode(clearTargetsStruct.relatedTarget) && isShadowRoot(nodeRoot(clearTargetsStruct.relatedTarget));

        if (activationTarget !== null && activationTarget._legacyPreActivationBehavior) {
          activationTarget._legacyPreActivationBehavior();
        }

        for (var _i = eventImpl._path.length - 1; _i >= 0; --_i) {
          var struct = eventImpl._path[_i];

          if (struct.target !== null) {
            eventImpl.eventPhase = EVENT_PHASE.AT_TARGET;
          } else {
            eventImpl.eventPhase = EVENT_PHASE.CAPTURING_PHASE;
          }

          invokeEventListeners(struct, eventImpl, "capturing");
        }

        for (var _i2 = 0; _i2 < eventImpl._path.length; _i2++) {
          var _struct = eventImpl._path[_i2];

          if (_struct.target !== null) {
            eventImpl.eventPhase = EVENT_PHASE.AT_TARGET;
          } else {
            if (!eventImpl.bubbles) {
              continue;
            }

            eventImpl.eventPhase = EVENT_PHASE.BUBBLING_PHASE;
          }

          invokeEventListeners(_struct, eventImpl, "bubbling");
        }
      }

      eventImpl.eventPhase = EVENT_PHASE.NONE;
      eventImpl.currentTarget = null;
      eventImpl._path = [];
      eventImpl._dispatchFlag = false;
      eventImpl._stopPropagationFlag = false;
      eventImpl._stopImmediatePropagationFlag = false;

      if (clearTargets) {
        eventImpl.target = null;
        eventImpl.relatedTarget = null;
      }

      if (activationTarget !== null) {
        if (!eventImpl._canceledFlag) {
          activationTarget._activationBehavior(eventImpl);
        } else if (activationTarget._legacyCanceledActivationBehavior) {
          activationTarget._legacyCanceledActivationBehavior();
        }
      }

      return !eventImpl._canceledFlag;
    }
  }]);

  return EventTargetImpl;
}();

module.exports = {
  implementation: EventTargetImpl
}; // https://dom.spec.whatwg.org/#concept-event-listener-invoke

function invokeEventListeners(struct, eventImpl, phase) {
  var structIndex = eventImpl._path.indexOf(struct);

  for (var i = structIndex; i >= 0; i--) {
    var t = eventImpl._path[i];

    if (t.target) {
      eventImpl.target = t.target;
      break;
    }
  }

  eventImpl.relatedTarget = idlUtils.wrapperForImpl(struct.relatedTarget);

  if (eventImpl._stopPropagationFlag) {
    return;
  }

  eventImpl.currentTarget = idlUtils.wrapperForImpl(struct.item);
  var listeners = struct.item._eventListeners;
  innerInvokeEventListeners(eventImpl, listeners, phase, struct);
} // https://dom.spec.whatwg.org/#concept-event-listener-inner-invoke


function innerInvokeEventListeners(eventImpl, listeners, phase) {
  var found = false;
  var type = eventImpl.type,
      target = eventImpl.target;
  var wrapper = idlUtils.wrapperForImpl(target);

  if (!listeners || !listeners[type]) {
    return found;
  } // Copy event listeners before iterating since the list can be modified during the iteration.


  var handlers = listeners[type].slice();

  for (var i = 0; i < handlers.length; i++) {
    var listener = handlers[i];
    var _listener$options = listener.options,
        capture = _listener$options.capture,
        once = _listener$options.once,
        passive = _listener$options.passive; // Check if the event listener has been removed since the listeners has been cloned.

    if (!listeners[type].includes(listener)) {
      continue;
    }

    found = true;

    if (phase === "capturing" && !capture || phase === "bubbling" && capture) {
      continue;
    }

    if (once) {
      listeners[type].splice(listeners[type].indexOf(listener), 1);
    }

    if (passive) {
      eventImpl._inPassiveListenerFlag = true;
    }

    try {
      listener.callback.call(eventImpl.currentTarget, eventImpl);
    } catch (e) {
      var window = null;

      if (wrapper && wrapper._document) {
        // Triggered by Window
        window = wrapper;
      } else if (target._ownerDocument) {
        // Triggered by most webidl2js'ed instances
        window = target._ownerDocument._defaultView;
      } else if (wrapper._ownerDocument) {
        // Currently triggered by some non-webidl2js things
        window = wrapper._ownerDocument._defaultView;
      }

      if (window) {
        reportException(window, e);
      } // Errors in window-less documents just get swallowed... can you think of anything better?

    }

    eventImpl._inPassiveListenerFlag = false;

    if (eventImpl._stopImmediatePropagationFlag) {
      return found;
    }
  }

  return found;
}
/**
 * Normalize the event listeners options argument in order to get always a valid options object
 * @param   {Object} options         - user defined options
 * @param   {Array} defaultBoolKeys  - boolean properties that should belong to the options object
 * @returns {Object} object containing at least the "defaultBoolKeys"
 */


function normalizeEventHandlerOptions(options, defaultBoolKeys) {
  var returnValue = {}; // no need to go further here

  if (typeof options === "boolean" || options === null || typeof options === "undefined") {
    returnValue.capture = Boolean(options);
    return returnValue;
  } // non objects options so we typecast its value as "capture" value


  if (_typeof(options) !== "object") {
    returnValue.capture = Boolean(options); // at this point we don't need to loop the "capture" key anymore

    defaultBoolKeys = defaultBoolKeys.filter(function (k) {
      return k !== "capture";
    });
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = defaultBoolKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var key = _step.value;
      returnValue[key] = Boolean(options[key]);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return returnValue;
} // https://dom.spec.whatwg.org/#concept-event-path-append


function appendToEventPath(eventImpl, target, targetOverride, relatedTarget, touchTargets, slotInClosedTree) {
  var itemInShadowTree = isNode(target) && isShadowRoot(nodeRoot(target));
  var rootOfClosedTree = isShadowRoot(target) && target.mode === "closed";

  eventImpl._path.push({
    item: target,
    itemInShadowTree: itemInShadowTree,
    target: targetOverride,
    relatedTarget: relatedTarget,
    touchTargets: touchTargets,
    rootOfClosedTree: rootOfClosedTree,
    slotInClosedTree: slotInClosedTree
  });
}