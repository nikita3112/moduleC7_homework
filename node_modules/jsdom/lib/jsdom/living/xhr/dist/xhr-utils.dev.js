"use strict";

var fs = require("fs");

var request = require("request");

var _require = require("events"),
    EventEmitter = _require.EventEmitter;

var _require2 = require("whatwg-url"),
    URL = _require2.URL;

var parseDataURL = require("data-urls");

var DOMException = require("domexception/webidl2js-wrapper");

var ProgressEvent = require("../generated/ProgressEvent");

var wrapCookieJarForRequest = require("../helpers/wrap-cookie-jar-for-request");

var _require3 = require("../helpers/events"),
    fireAnEvent = _require3.fireAnEvent;

var headerListSeparatorRegexp = /,[ \t]*/;
var simpleMethods = new Set(["GET", "HEAD", "POST"]);
var simpleHeaders = new Set(["accept", "accept-language", "content-language", "content-type"]);
var preflightHeaders = new Set(["access-control-expose-headers", "access-control-allow-headers", "access-control-allow-credentials", "access-control-allow-origin"]);
var READY_STATES = exports.READY_STATES = Object.freeze({
  UNSENT: 0,
  OPENED: 1,
  HEADERS_RECEIVED: 2,
  LOADING: 3,
  DONE: 4
});

function getRequestHeader(requestHeaders, header) {
  var lcHeader = header.toLowerCase();
  var keys = Object.keys(requestHeaders);
  var n = keys.length;

  while (n--) {
    var key = keys[n];

    if (key.toLowerCase() === lcHeader) {
      return requestHeaders[key];
    }
  }

  return null;
}

function updateRequestHeader(requestHeaders, header, newValue) {
  var lcHeader = header.toLowerCase();
  var keys = Object.keys(requestHeaders);
  var n = keys.length;

  while (n--) {
    var key = keys[n];

    if (key.toLowerCase() === lcHeader) {
      requestHeaders[key] = newValue;
    }
  }
}

function dispatchError(xhr) {
  var errMessage = xhr.properties.error;
  requestErrorSteps(xhr, "error", DOMException.create(xhr._globalObject, [errMessage, "NetworkError"]));

  if (xhr._ownerDocument) {
    var error = new Error(errMessage);
    error.type = "XMLHttpRequest"; // TODO this should become "resource loading" when XHR goes through resource loader

    xhr._ownerDocument._defaultView._virtualConsole.emit("jsdomError", error);
  }
}

function validCORSHeaders(xhr, response, flag, properties, origin) {
  var acaoStr = response.headers["access-control-allow-origin"];
  var acao = acaoStr ? acaoStr.trim() : null;

  if (acao !== "*" && acao !== origin) {
    properties.error = "Cross origin " + origin + " forbidden";
    dispatchError(xhr);
    return false;
  }

  var acacStr = response.headers["access-control-allow-credentials"];
  var acac = acacStr ? acacStr.trim() : null;

  if (flag.withCredentials && acac !== "true") {
    properties.error = "Credentials forbidden";
    dispatchError(xhr);
    return false;
  }

  return true;
}

function validCORSPreflightHeaders(xhr, response, flag, properties) {
  if (!validCORSHeaders(xhr, response, flag, properties, properties.origin)) {
    return false;
  }

  var acahStr = response.headers["access-control-allow-headers"];
  var acah = new Set(acahStr ? acahStr.trim().toLowerCase().split(headerListSeparatorRegexp) : []);
  var forbiddenHeaders = Object.keys(flag.requestHeaders).filter(function (header) {
    var lcHeader = header.toLowerCase();
    return !simpleHeaders.has(lcHeader) && !acah.has(lcHeader);
  });

  if (forbiddenHeaders.length > 0) {
    properties.error = "Headers " + forbiddenHeaders + " forbidden";
    dispatchError(xhr);
    return false;
  }

  return true;
}

function requestErrorSteps(xhr, event, exception) {
  var flag = xhr.flag,
      properties = xhr.properties,
      upload = xhr.upload;
  xhr.readyState = READY_STATES.DONE;
  properties.send = false;
  setResponseToNetworkError(xhr);

  if (flag.synchronous) {
    throw exception;
  }

  fireAnEvent("readystatechange", xhr);

  if (!properties.uploadComplete) {
    properties.uploadComplete = true;

    if (properties.uploadListener) {
      fireAnEvent(event, upload, ProgressEvent, {
        loaded: 0,
        total: 0,
        lengthComputable: false
      });
      fireAnEvent("loadend", upload, ProgressEvent, {
        loaded: 0,
        total: 0,
        lengthComputable: false
      });
    }
  }

  fireAnEvent(event, xhr, ProgressEvent, {
    loaded: 0,
    total: 0,
    lengthComputable: false
  });
  fireAnEvent("loadend", xhr, ProgressEvent, {
    loaded: 0,
    total: 0,
    lengthComputable: false
  });
}

function setResponseToNetworkError(xhr) {
  var properties = xhr.properties;
  properties.responseCache = properties.responseTextCache = properties.responseXMLCache = null;
  properties.responseHeaders = {};
  xhr.status = 0;
  xhr.statusText = "";
} // return a "request" client object or an event emitter matching the same behaviour for unsupported protocols
// the callback should be called with a "request" response object or an event emitter matching the same behaviour too


function createClient(xhr) {
  var flag = xhr.flag,
      properties = xhr.properties;
  var urlObj = new URL(flag.uri);
  var uri = urlObj.href;
  var ucMethod = flag.method.toUpperCase();
  var requestManager = flag.requestManager;

  if (urlObj.protocol === "file:") {
    var response = new EventEmitter();
    response.statusCode = 200;
    response.rawHeaders = [];
    response.headers = {};
    response.request = {
      uri: urlObj
    };
    var filePath = urlObj.pathname.replace(/^file:\/\//, "").replace(/^\/([a-z]):\//i, "$1:/").replace(/%20/g, " ");

    var _client = new EventEmitter();

    var readableStream = fs.createReadStream(filePath, {
      encoding: null
    });
    readableStream.on("data", function (chunk) {
      response.emit("data", chunk);

      _client.emit("data", chunk);
    });
    readableStream.on("end", function () {
      response.emit("end");

      _client.emit("end");
    });
    readableStream.on("error", function (err) {
      _client.emit("error", err);
    });

    _client.abort = function () {
      readableStream.destroy();

      _client.emit("abort");
    };

    if (requestManager) {
      var req = {
        abort: function abort() {
          properties.abortError = true;
          xhr.abort();
        }
      };
      requestManager.add(req);
      var rmReq = requestManager.remove.bind(requestManager, req);

      _client.on("abort", rmReq);

      _client.on("error", rmReq);

      _client.on("end", rmReq);
    }

    process.nextTick(function () {
      return _client.emit("response", response);
    });
    return _client;
  }

  if (urlObj.protocol === "data:") {
    var _response = new EventEmitter();

    _response.request = {
      uri: urlObj
    };

    var _client2 = new EventEmitter();

    var buffer;

    try {
      var parsed = parseDataURL(uri);
      var contentType = parsed.mimeType.toString();
      buffer = parsed.body;
      _response.statusCode = 200;
      _response.rawHeaders = ["Content-Type", contentType];
      _response.headers = {
        "content-type": contentType
      };
    } catch (err) {
      process.nextTick(function () {
        return _client2.emit("error", err);
      });
      return _client2;
    }

    _client2.abort = function () {// do nothing
    };

    process.nextTick(function () {
      _client2.emit("response", _response);

      process.nextTick(function () {
        _response.emit("data", buffer);

        _client2.emit("data", buffer);

        _response.emit("end");

        _client2.emit("end");
      });
    });
    return _client2;
  }

  var requestHeaders = {};

  for (var header in flag.requestHeaders) {
    requestHeaders[header] = flag.requestHeaders[header];
  }

  if (getRequestHeader(flag.requestHeaders, "referer") === null) {
    requestHeaders.Referer = flag.referrer;
  }

  if (getRequestHeader(flag.requestHeaders, "user-agent") === null) {
    requestHeaders["User-Agent"] = flag.userAgent;
  }

  if (getRequestHeader(flag.requestHeaders, "accept-language") === null) {
    requestHeaders["Accept-Language"] = "en";
  }

  if (getRequestHeader(flag.requestHeaders, "accept") === null) {
    requestHeaders.Accept = "*/*";
  }

  var crossOrigin = flag.origin !== urlObj.origin;

  if (crossOrigin) {
    requestHeaders.Origin = flag.origin;
  }

  var options = {
    uri: uri,
    method: flag.method,
    headers: requestHeaders,
    gzip: true,
    maxRedirects: 21,
    followAllRedirects: true,
    encoding: null,
    strictSSL: flag.strictSSL,
    proxy: flag.proxy,
    forever: true
  };

  if (flag.auth) {
    options.auth = {
      user: flag.auth.user || "",
      pass: flag.auth.pass || "",
      sendImmediately: false
    };
  }

  if (flag.cookieJar && (!crossOrigin || flag.withCredentials)) {
    options.jar = wrapCookieJarForRequest(flag.cookieJar);
  }

  var body = flag.body;
  var hasBody = body !== undefined && body !== null && body !== "" && !(ucMethod === "HEAD" || ucMethod === "GET");

  if (hasBody && !flag.formData) {
    options.body = body;
  }

  if (hasBody && getRequestHeader(flag.requestHeaders, "content-type") === null) {
    requestHeaders["Content-Type"] = "text/plain;charset=UTF-8";
  }

  function doRequest() {
    try {
      var _client3 = request(options);

      if (hasBody && flag.formData) {
        var form = _client3.form();

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = body[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var entry = _step.value;
            form.append(entry.name, entry.value, entry.options);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      return _client3;
    } catch (e) {
      var _client4 = new EventEmitter();

      process.nextTick(function () {
        return _client4.emit("error", e);
      });
      return _client4;
    }
  }

  var client;
  var nonSimpleHeaders = Object.keys(flag.requestHeaders).filter(function (header) {
    return !simpleHeaders.has(header.toLowerCase());
  });

  if (crossOrigin && (!simpleMethods.has(ucMethod) || nonSimpleHeaders.length > 0 || properties.uploadListener)) {
    client = new EventEmitter();
    var preflightRequestHeaders = [];

    for (var _header in requestHeaders) {
      // the only existing request headers the cors spec allows on the preflight request are Origin and Referrer
      var lcHeader = _header.toLowerCase();

      if (lcHeader === "origin" || lcHeader === "referrer") {
        preflightRequestHeaders[_header] = requestHeaders[_header];
      }
    }

    preflightRequestHeaders["Access-Control-Request-Method"] = flag.method;

    if (nonSimpleHeaders.length > 0) {
      preflightRequestHeaders["Access-Control-Request-Headers"] = nonSimpleHeaders.join(", ");
    }

    preflightRequestHeaders["User-Agent"] = flag.userAgent;
    flag.preflight = true;
    var preflightOptions = {
      uri: uri,
      method: "OPTIONS",
      headers: preflightRequestHeaders,
      followRedirect: false,
      encoding: null,
      pool: flag.pool,
      strictSSL: flag.strictSSL,
      proxy: flag.proxy,
      forever: true
    };
    var preflightClient = request(preflightOptions);
    preflightClient.on("response", function (resp) {
      // don't send the real request if the preflight request returned an error
      if (resp.statusCode < 200 || resp.statusCode > 299) {
        client.emit("error", new Error("Response for preflight has invalid HTTP status code " + resp.statusCode));
        return;
      } // don't send the real request if we aren't allowed to use the headers


      if (!validCORSPreflightHeaders(xhr, resp, flag, properties)) {
        setResponseToNetworkError(xhr);
        return;
      }

      var realClient = doRequest();
      realClient.on("response", function (res) {
        return client.emit("response", res);
      });
      realClient.on("data", function (chunk) {
        return client.emit("data", chunk);
      });
      realClient.on("end", function () {
        return client.emit("end");
      });
      realClient.on("abort", function () {
        return client.emit("abort");
      });
      realClient.on("request", function (req) {
        client.headers = realClient.headers;
        client.emit("request", req);
      });
      realClient.on("redirect", function () {
        client.response = realClient.response;
        client.emit("redirect");
      });
      realClient.on("error", function (err) {
        return client.emit("error", err);
      });

      client.abort = function () {
        realClient.abort();
      };
    });
    preflightClient.on("error", function (err) {
      return client.emit("error", err);
    });

    client.abort = function () {
      preflightClient.abort();
    };
  } else {
    client = doRequest();
  }

  if (requestManager) {
    var _req = {
      abort: function abort() {
        properties.abortError = true;
        xhr.abort();
      }
    };
    requestManager.add(_req);

    var _rmReq = requestManager.remove.bind(requestManager, _req);

    client.on("abort", _rmReq);
    client.on("error", _rmReq);
    client.on("end", _rmReq);
  }

  return client;
}

exports.headerListSeparatorRegexp = headerListSeparatorRegexp;
exports.simpleHeaders = simpleHeaders;
exports.preflightHeaders = preflightHeaders;
exports.getRequestHeader = getRequestHeader;
exports.updateRequestHeader = updateRequestHeader;
exports.dispatchError = dispatchError;
exports.validCORSHeaders = validCORSHeaders;
exports.requestErrorSteps = requestErrorSteps;
exports.setResponseToNetworkError = setResponseToNetworkError;
exports.createClient = createClient;