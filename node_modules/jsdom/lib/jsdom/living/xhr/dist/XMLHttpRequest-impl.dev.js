"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var HTTP_STATUS_CODES = require("http").STATUS_CODES;

var _require = require("child_process"),
    spawnSync = _require.spawnSync;

var _require2 = require("whatwg-url"),
    URL = _require2.URL;

var whatwgEncoding = require("whatwg-encoding");

var tough = require("tough-cookie");

var MIMEType = require("whatwg-mimetype");

var xhrUtils = require("./xhr-utils");

var DOMException = require("domexception/webidl2js-wrapper");

var _require3 = require("../helpers/document-base-url"),
    documentBaseURLSerialized = _require3.documentBaseURLSerialized;

var _require4 = require("../helpers/strings"),
    asciiCaseInsensitiveMatch = _require4.asciiCaseInsensitiveMatch;

var idlUtils = require("../generated/utils");

var Document = require("../generated/Document");

var Blob = require("../generated/Blob");

var FormData = require("../generated/FormData");

var XMLHttpRequestEventTargetImpl = require("./XMLHttpRequestEventTarget-impl").implementation;

var XMLHttpRequestUpload = require("../generated/XMLHttpRequestUpload");

var ProgressEvent = require("../generated/ProgressEvent");

var _require5 = require("../generated/utils"),
    isArrayBuffer = _require5.isArrayBuffer;

var _require6 = require("../../browser/parser"),
    parseIntoDocument = _require6.parseIntoDocument;

var _require7 = require("../domparsing/serialization"),
    fragmentSerialization = _require7.fragmentSerialization;

var _require8 = require("../helpers/create-event-accessor"),
    setupForSimpleEventAccessors = _require8.setupForSimpleEventAccessors;

var _require9 = require("../helpers/json"),
    parseJSONFromBytes = _require9.parseJSONFromBytes;

var _require10 = require("../helpers/events"),
    fireAnEvent = _require10.fireAnEvent;

var _require11 = require("../helpers/binary-data"),
    copyToArrayBufferInNewRealm = _require11.copyToArrayBufferInNewRealm;

var READY_STATES = xhrUtils.READY_STATES;
var syncWorkerFile = require.resolve ? require.resolve("./xhr-sync-worker.js") : null;
var tokenRegexp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
var fieldValueRegexp = /^[ \t]*(?:[\x21-\x7E\x80-\xFF](?:[ \t][\x21-\x7E\x80-\xFF])?)*[ \t]*$/;
var forbiddenRequestHeaders = new Set(["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"]);
var forbiddenResponseHeaders = new Set(["set-cookie", "set-cookie2"]);
var uniqueResponseHeaders = new Set(["content-type", "content-length", "user-agent", "referer", "host", "authorization", "proxy-authorization", "if-modified-since", "if-unmodified-since", "from", "location", "max-forwards"]);
var corsSafeResponseHeaders = new Set(["cache-control", "content-language", "content-type", "expires", "last-modified", "pragma"]);
var allowedRequestMethods = new Set(["OPTIONS", "GET", "HEAD", "POST", "PUT", "DELETE"]);
var forbiddenRequestMethods = new Set(["TRACK", "TRACE", "CONNECT"]);

var XMLHttpRequestImpl =
/*#__PURE__*/
function (_XMLHttpRequestEventT) {
  _inherits(XMLHttpRequestImpl, _XMLHttpRequestEventT);

  function XMLHttpRequestImpl(window) {
    var _this;

    _classCallCheck(this, XMLHttpRequestImpl);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(XMLHttpRequestImpl).call(this, window)); // Avoid running `_ownerDocument` getter multiple times in the constructor:

    var _assertThisInitialize = _assertThisInitialized(_this),
        _ownerDocument = _assertThisInitialize._ownerDocument;

    _this.upload = XMLHttpRequestUpload.createImpl(window);
    _this.readyState = READY_STATES.UNSENT;
    _this.responseURL = "";
    _this.status = 0;
    _this.statusText = "";
    _this.flag = {
      synchronous: false,
      withCredentials: false,
      mimeType: null,
      auth: null,
      method: undefined,
      responseType: "",
      requestHeaders: {},
      referrer: _ownerDocument.URL,
      uri: "",
      timeout: 0,
      body: undefined,
      formData: false,
      preflight: false,
      requestManager: _ownerDocument._requestManager,
      strictSSL: window._resourceLoader._strictSSL,
      proxy: window._resourceLoader._proxy,
      cookieJar: _ownerDocument._cookieJar,
      encoding: _ownerDocument._encoding,
      origin: window._origin,
      userAgent: window.navigator.userAgent
    };
    _this.properties = {
      beforeSend: false,
      send: false,
      client: null,
      timeoutStart: 0,
      timeoutId: 0,
      timeoutFn: null,
      responseBuffer: null,
      responseCache: null,
      responseTextCache: null,
      responseXMLCache: null,
      responseHeaders: {},
      filteredResponseHeaders: [],
      error: "",
      uploadComplete: false,
      uploadListener: false,
      // Signifies that we're calling abort() from xhr-utils.js because of a window shutdown.
      // In that case the termination reason is "fatal", not "end-user abort".
      abortError: false,
      cookieJar: _ownerDocument._cookieJar,
      bufferStepSize: 1 * 1024 * 1024,
      // pre-allocate buffer increase step size. init value is 1MB
      totalReceivedChunkSize: 0
    };
    return _this;
  }

  _createClass(XMLHttpRequestImpl, [{
    key: "abort",
    value: function abort() {
      var properties = this.properties; // Terminate the request

      clearTimeout(properties.timeoutId);
      properties.timeoutFn = null;
      properties.timeoutStart = 0;
      var client = properties.client;

      if (client) {
        client.abort();
        properties.client = null;
      }

      if (properties.abortError) {
        // Special case that ideally shouldn't be going through the public API at all.
        // Run the https://xhr.spec.whatwg.org/#handle-errors "fatal" steps.
        this.readyState = READY_STATES.DONE;
        properties.send = false;
        xhrUtils.setResponseToNetworkError(this);
        return;
      }

      if (this.readyState === READY_STATES.OPENED && properties.send || this.readyState === READY_STATES.HEADERS_RECEIVED || this.readyState === READY_STATES.LOADING) {
        xhrUtils.requestErrorSteps(this, "abort");
      }

      if (this.readyState === READY_STATES.DONE) {
        this.readyState = READY_STATES.UNSENT;
        xhrUtils.setResponseToNetworkError(this);
      }
    }
  }, {
    key: "getAllResponseHeaders",
    value: function getAllResponseHeaders() {
      var properties = this.properties,
          readyState = this.readyState;

      if (readyState === READY_STATES.UNSENT || readyState === READY_STATES.OPENED) {
        return "";
      }

      return Object.keys(properties.responseHeaders).filter(function (key) {
        return properties.filteredResponseHeaders.indexOf(key) === -1;
      }).map(function (key) {
        return [key.toLowerCase(), properties.responseHeaders[key]].join(": ");
      }).join("\r\n");
    }
  }, {
    key: "getResponseHeader",
    value: function getResponseHeader(header) {
      var properties = this.properties,
          readyState = this.readyState;

      if (readyState === READY_STATES.UNSENT || readyState === READY_STATES.OPENED) {
        return null;
      }

      var lcHeader = header.toLowerCase();

      if (properties.filteredResponseHeaders.find(function (filtered) {
        return lcHeader === filtered.toLowerCase();
      })) {
        return null;
      }

      return _getResponseHeader(this, lcHeader);
    }
  }, {
    key: "open",
    value: function open(method, uri, asynchronous, user, password) {
      var flag = this.flag,
          properties = this.properties,
          _ownerDocument = this._ownerDocument;

      if (!_ownerDocument) {
        throw DOMException.create(this._globalObject, ["The object is in an invalid state.", "InvalidStateError"]);
      }

      if (!tokenRegexp.test(method)) {
        throw DOMException.create(this._globalObject, ["The string did not match the expected pattern.", "SyntaxError"]);
      }

      var upperCaseMethod = method.toUpperCase();

      if (forbiddenRequestMethods.has(upperCaseMethod)) {
        throw DOMException.create(this._globalObject, ["The operation is insecure.", "SecurityError"]);
      }

      var client = properties.client;

      if (client && typeof client.abort === "function") {
        client.abort();
      }

      if (allowedRequestMethods.has(upperCaseMethod)) {
        method = upperCaseMethod;
      }

      if (typeof asynchronous !== "undefined") {
        flag.synchronous = !asynchronous;
      } else {
        flag.synchronous = false;
      }

      if (flag.responseType && flag.synchronous) {
        throw DOMException.create(this._globalObject, ["The object does not support the operation or argument.", "InvalidAccessError"]);
      }

      if (flag.synchronous && flag.timeout) {
        throw DOMException.create(this._globalObject, ["The object does not support the operation or argument.", "InvalidAccessError"]);
      }

      flag.method = method;
      var urlObj;

      try {
        urlObj = new URL(uri, documentBaseURLSerialized(_ownerDocument));
      } catch (e) {
        throw DOMException.create(this._globalObject, ["The string did not match the expected pattern.", "SyntaxError"]);
      }

      if (user || password && !urlObj.username) {
        flag.auth = {
          user: user,
          pass: password
        };
        urlObj.username = "";
        urlObj.password = "";
      }

      flag.uri = urlObj.href;
      flag.requestHeaders = {};
      flag.preflight = false;
      properties.send = false;
      properties.uploadListener = false;
      properties.abortError = false;
      this.responseURL = "";
      readyStateChange(this, READY_STATES.OPENED);
    }
  }, {
    key: "overrideMimeType",
    value: function overrideMimeType(mime) {
      var readyState = this.readyState;

      if (readyState === READY_STATES.LOADING || readyState === READY_STATES.DONE) {
        throw DOMException.create(this._globalObject, ["The object is in an invalid state.", "InvalidStateError"]);
      }

      this.flag.overrideMIMEType = "application/octet-stream"; // Waiting for better spec: https://github.com/whatwg/xhr/issues/157

      var parsed = MIMEType.parse(mime);

      if (parsed) {
        this.flag.overrideMIMEType = parsed.essence;
        var charset = parsed.parameters.get("charset");

        if (charset) {
          this.flag.overrideCharset = whatwgEncoding.labelToName(charset);
        }
      }
    } // TODO: Add support for URLSearchParams and ReadableStream

  }, {
    key: "send",
    value: function send(body) {
      var _this2 = this;

      var flag = this.flag,
          properties = this.properties,
          upload = this.upload,
          _ownerDocument = this._ownerDocument; // Not per spec, but per tests: https://github.com/whatwg/xhr/issues/65

      if (!_ownerDocument) {
        throw DOMException.create(this._globalObject, ["The object is in an invalid state.", "InvalidStateError"]);
      }

      if (this.readyState !== READY_STATES.OPENED || properties.send) {
        throw DOMException.create(this._globalObject, ["The object is in an invalid state.", "InvalidStateError"]);
      }

      properties.beforeSend = true;

      try {
        if (flag.method === "GET" || flag.method === "HEAD") {
          body = null;
        }

        if (body !== null) {
          var encoding = null;
          var mimeType = null;

          if (Document.isImpl(body)) {
            encoding = "UTF-8";
            mimeType = (body._parsingMode === "html" ? "text/html" : "application/xml") + ";charset=UTF-8";
            flag.body = fragmentSerialization(body, {
              requireWellFormed: false
            });
          } else {
            if (typeof body === "string") {
              encoding = "UTF-8";
            }

            var _extractBody = extractBody(body),
                buffer = _extractBody.buffer,
                formData = _extractBody.formData,
                contentType = _extractBody.contentType;

            mimeType = contentType;
            flag.body = buffer || formData;
            flag.formData = Boolean(formData);
          }

          var existingContentType = xhrUtils.getRequestHeader(flag.requestHeaders, "content-type");

          if (mimeType !== null && existingContentType === null) {
            flag.requestHeaders["Content-Type"] = mimeType;
          } else if (existingContentType !== null && encoding !== null) {
            // Waiting for better spec: https://github.com/whatwg/xhr/issues/188. This seems like a good guess at what
            // the spec will be, in the meantime.
            var parsed = MIMEType.parse(existingContentType);

            if (parsed) {
              var charset = parsed.parameters.get("charset");

              if (charset && !asciiCaseInsensitiveMatch(charset, encoding) && encoding !== null) {
                parsed.parameters.set("charset", encoding);
                xhrUtils.updateRequestHeader(flag.requestHeaders, "content-type", parsed.toString());
              }
            }
          }
        }
      } finally {
        if (properties.beforeSend) {
          properties.beforeSend = false;
        } else {
          throw DOMException.create(this._globalObject, ["The object is in an invalid state.", "InvalidStateError"]);
        }
      }

      if (Object.keys(upload._eventListeners).length > 0) {
        properties.uploadListener = true;
      } // request doesn't like zero-length bodies


      if (flag.body && flag.body.byteLength === 0) {
        flag.body = null;
      }

      if (flag.synchronous) {
        var flagStr = JSON.stringify(flag, function (k, v) {
          if (this === flag && k === "requestManager") {
            return null;
          }

          if (this === flag && k === "pool" && v) {
            return {
              maxSockets: v.maxSockets
            };
          }

          return v;
        });
        var res = spawnSync(process.execPath, [syncWorkerFile], {
          input: flagStr,
          maxBuffer: Infinity
        });

        if (res.status !== 0) {
          throw new Error(res.stderr.toString());
        }

        if (res.error) {
          if (typeof res.error === "string") {
            res.error = new Error(res.error);
          }

          throw res.error;
        }

        var response = JSON.parse(res.stdout.toString());
        var resProp = response.properties;

        if (resProp.responseBuffer && resProp.responseBuffer.data) {
          resProp.responseBuffer = Buffer.from(resProp.responseBuffer.data);
        }

        if (resProp.cookieJar) {
          resProp.cookieJar = tough.CookieJar.deserializeSync(resProp.cookieJar, _ownerDocument._cookieJar.store);
        }

        this.readyState = READY_STATES.LOADING;
        this.status = response.status;
        this.statusText = response.statusText;
        this.responseURL = response.responseURL;
        Object.assign(this.properties, response.properties);

        if (resProp.error) {
          xhrUtils.dispatchError(this);
          throw DOMException.create(this._globalObject, [resProp.error, "NetworkError"]);
        } else {
          var responseBuffer = properties.responseBuffer;
          var contentLength = _getResponseHeader(this, "content-length") || "0";
          var bufferLength = parseInt(contentLength) || responseBuffer.length;
          var progressObj = {
            lengthComputable: false
          };

          if (bufferLength !== 0) {
            progressObj.total = bufferLength;
            progressObj.loaded = bufferLength;
            progressObj.lengthComputable = true;
          }

          fireAnEvent("progress", this, ProgressEvent, progressObj);
          readyStateChange(this, READY_STATES.DONE);
          fireAnEvent("load", this, ProgressEvent, progressObj);
          fireAnEvent("loadend", this, ProgressEvent, progressObj);
        }
      } else {
        properties.send = true;
        fireAnEvent("loadstart", this, ProgressEvent);
        var client = xhrUtils.createClient(this);
        properties.client = client; // For new client, reset totalReceivedChunkSize and bufferStepSize

        properties.totalReceivedChunkSize = 0;
        properties.bufferStepSize = 1 * 1024 * 1024;
        properties.origin = flag.origin;
        client.on("error", function (err) {
          client.removeAllListeners();
          properties.error = err;
          xhrUtils.dispatchError(_this2);
        });
        client.on("response", function (res) {
          return receiveResponse(_this2, res);
        });
        client.on("redirect", function () {
          var response = client.response;
          var destUrlObj = new URL(response.request.headers.Referer);
          var urlObj = new URL(response.request.uri.href);

          if (destUrlObj.origin !== urlObj.origin && destUrlObj.origin !== flag.origin) {
            properties.origin = "null";
          }

          response.request.headers.Origin = properties.origin;

          if (flag.origin !== destUrlObj.origin && destUrlObj.protocol !== "data:") {
            if (!xhrUtils.validCORSHeaders(_this2, response, flag, properties, flag.origin)) {
              return;
            }

            if (urlObj.username || urlObj.password) {
              properties.error = "Userinfo forbidden in cors redirect";
              xhrUtils.dispatchError(_this2);
            }
          }
        });

        if (body !== null && body !== "") {
          properties.uploadComplete = false;
          setDispatchProgressEvents(this);
        } else {
          properties.uploadComplete = true;
        }

        if (this.timeout > 0) {
          properties.timeoutStart = new Date().getTime();

          properties.timeoutFn = function () {
            client.abort();

            if (!(_this2.readyState === READY_STATES.UNSENT || _this2.readyState === READY_STATES.OPENED && !properties.send || _this2.readyState === READY_STATES.DONE)) {
              properties.send = false;
              var stateChanged = false;

              if (!properties.uploadComplete) {
                fireAnEvent("progress", upload, ProgressEvent);
                readyStateChange(_this2, READY_STATES.DONE);
                fireAnEvent("timeout", upload, ProgressEvent);
                fireAnEvent("loadend", upload, ProgressEvent);
                stateChanged = true;
              }

              fireAnEvent("progress", _this2, ProgressEvent);

              if (!stateChanged) {
                readyStateChange(_this2, READY_STATES.DONE);
              }

              fireAnEvent("timeout", _this2, ProgressEvent);
              fireAnEvent("loadend", _this2, ProgressEvent);
            }

            _this2.readyState = READY_STATES.UNSENT;
          };

          properties.timeoutId = setTimeout(properties.timeoutFn, this.timeout);
        }
      }
    }
  }, {
    key: "setRequestHeader",
    value: function setRequestHeader(header, value) {
      var flag = this.flag,
          properties = this.properties;

      if (this.readyState !== READY_STATES.OPENED || properties.send) {
        throw DOMException.create(this._globalObject, ["The object is in an invalid state.", "InvalidStateError"]);
      }

      value = normalizeHeaderValue(value);

      if (!tokenRegexp.test(header) || !fieldValueRegexp.test(value)) {
        throw DOMException.create(this._globalObject, ["The string did not match the expected pattern.", "SyntaxError"]);
      }

      var lcHeader = header.toLowerCase();

      if (forbiddenRequestHeaders.has(lcHeader) || lcHeader.startsWith("sec-") || lcHeader.startsWith("proxy-")) {
        return;
      }

      var keys = Object.keys(flag.requestHeaders);
      var n = keys.length;

      while (n--) {
        var key = keys[n];

        if (key.toLowerCase() === lcHeader) {
          flag.requestHeaders[key] += ", " + value;
          return;
        }
      }

      flag.requestHeaders[header] = value;
    }
  }, {
    key: "responseType",
    get: function get() {
      return this.flag.responseType;
    },
    set: function set(responseType) {
      var flag = this.flag;

      if (this.readyState === READY_STATES.LOADING || this.readyState === READY_STATES.DONE) {
        throw DOMException.create(this._globalObject, ["The object is in an invalid state.", "InvalidStateError"]);
      }

      if (this.readyState === READY_STATES.OPENED && flag.synchronous) {
        throw DOMException.create(this._globalObject, ["The object does not support the operation or argument.", "InvalidAccessError"]);
      }

      flag.responseType = responseType;
    }
  }, {
    key: "response",
    get: function get() {
      var properties = this.properties;

      if (properties.responseCache) {
        // Needed because of: https://github.com/jsdom/webidl2js/issues/149
        return idlUtils.tryWrapperForImpl(properties.responseCache);
      }

      var res;
      var responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;

      switch (this.responseType) {
        case "":
        case "text":
          {
            res = this.responseText;
            break;
          }

        case "arraybuffer":
          {
            if (!responseBuffer) {
              return null;
            }

            res = copyToArrayBufferInNewRealm(responseBuffer, this._globalObject);
            break;
          }

        case "blob":
          {
            if (!responseBuffer) {
              return null;
            }

            var contentType = finalMIMEType(this);
            res = Blob.createImpl(this._globalObject, [[new Uint8Array(responseBuffer)], {
              type: contentType || ""
            }]);
            break;
          }

        case "document":
          {
            res = this.responseXML;
            break;
          }

        case "json":
          {
            if (this.readyState !== READY_STATES.DONE || !responseBuffer) {
              res = null;
            }

            try {
              res = parseJSONFromBytes(responseBuffer);
            } catch (e) {
              res = null;
            }

            break;
          }
      }

      properties.responseCache = res; // Needed because of: https://github.com/jsdom/webidl2js/issues/149

      return idlUtils.tryWrapperForImpl(res);
    }
  }, {
    key: "responseText",
    get: function get() {
      var properties = this.properties;

      if (this.responseType !== "" && this.responseType !== "text") {
        throw DOMException.create(this._globalObject, ["The object is in an invalid state.", "InvalidStateError"]);
      }

      if (this.readyState !== READY_STATES.LOADING && this.readyState !== READY_STATES.DONE) {
        return "";
      }

      if (properties.responseTextCache) {
        return properties.responseTextCache;
      }

      var responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;

      if (!responseBuffer) {
        return "";
      }

      var fallbackEncoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || "UTF-8";
      var res = whatwgEncoding.decode(responseBuffer, fallbackEncoding);
      properties.responseTextCache = res;
      return res;
    }
  }, {
    key: "responseXML",
    get: function get() {
      var flag = this.flag,
          properties = this.properties;

      if (this.responseType !== "" && this.responseType !== "document") {
        throw DOMException.create(this._globalObject, ["The object is in an invalid state.", "InvalidStateError"]);
      }

      if (this.readyState !== READY_STATES.DONE) {
        return null;
      }

      if (properties.responseXMLCache) {
        return properties.responseXMLCache;
      }

      var responseBuffer = properties.responseBuffer ? properties.responseBuffer.slice(0, properties.totalReceivedChunkSize) : null;

      if (!responseBuffer) {
        return null;
      }

      var contentType = finalMIMEType(this);
      var isHTML = false;
      var isXML = false;
      var parsed = MIMEType.parse(contentType);

      if (parsed) {
        isHTML = parsed.isHTML();
        isXML = parsed.isXML();

        if (!isXML && !isHTML) {
          return null;
        }
      }

      if (this.responseType === "" && isHTML) {
        return null;
      }

      var encoding = finalCharset(this) || whatwgEncoding.getBOMEncoding(responseBuffer) || "UTF-8";
      var resText = whatwgEncoding.decode(responseBuffer, encoding);

      if (!resText) {
        return null;
      }

      var res = Document.createImpl(this._globalObject, [], {
        options: {
          url: flag.uri,
          lastModified: new Date(_getResponseHeader(this, "last-modified")),
          parsingMode: isHTML ? "html" : "xml",
          cookieJar: {
            setCookieSync: function setCookieSync() {
              return undefined;
            },
            getCookieStringSync: function getCookieStringSync() {
              return "";
            }
          },
          encoding: encoding,
          parseOptions: this._ownerDocument._parseOptions
        }
      });

      try {
        parseIntoDocument(resText, res);
      } catch (e) {
        properties.responseXMLCache = null;
        return null;
      }

      res.close();
      properties.responseXMLCache = res;
      return res;
    }
  }, {
    key: "timeout",
    get: function get() {
      return this.flag.timeout;
    },
    set: function set(val) {
      var flag = this.flag,
          properties = this.properties;

      if (flag.synchronous) {
        throw DOMException.create(this._globalObject, ["The object does not support the operation or argument.", "InvalidAccessError"]);
      }

      flag.timeout = val;
      clearTimeout(properties.timeoutId);

      if (val > 0 && properties.timeoutFn) {
        properties.timeoutId = setTimeout(properties.timeoutFn, Math.max(0, val - (new Date().getTime() - properties.timeoutStart)));
      } else {
        properties.timeoutFn = null;
        properties.timeoutStart = 0;
      }
    }
  }, {
    key: "withCredentials",
    get: function get() {
      return this.flag.withCredentials;
    },
    set: function set(val) {
      var flag = this.flag,
          properties = this.properties;

      if (!(this.readyState === READY_STATES.UNSENT || this.readyState === READY_STATES.OPENED)) {
        throw DOMException.create(this._globalObject, ["The object is in an invalid state.", "InvalidStateError"]);
      }

      if (properties.send) {
        throw DOMException.create(this._globalObject, ["The object is in an invalid state.", "InvalidStateError"]);
      }

      flag.withCredentials = val;
    }
  }]);

  return XMLHttpRequestImpl;
}(XMLHttpRequestEventTargetImpl);

setupForSimpleEventAccessors(XMLHttpRequestImpl.prototype, ["readystatechange"]);

function readyStateChange(xhr, readyState) {
  if (xhr.readyState === readyState) {
    return;
  }

  xhr.readyState = readyState;
  fireAnEvent("readystatechange", xhr);
}

function receiveResponse(xhr, response) {
  var flag = xhr.flag,
      properties = xhr.properties;
  var statusCode = response.statusCode;
  var byteOffset = 0;
  var headers = {};
  var filteredResponseHeaders = [];
  var headerMap = {};
  var rawHeaders = response.rawHeaders;
  var n = Number(rawHeaders.length);

  for (var i = 0; i < n; i += 2) {
    var k = rawHeaders[i];
    var kl = k.toLowerCase();
    var v = rawHeaders[i + 1];

    if (uniqueResponseHeaders.has(kl)) {
      if (headerMap[kl] !== undefined) {
        delete headers[headerMap[kl]];
      }

      headers[k] = v;
    } else if (headerMap[kl] !== undefined) {
      headers[headerMap[kl]] += ", " + v;
    } else {
      headers[k] = v;
    }

    headerMap[kl] = k;
  }

  var destUrlObj = new URL(response.request.uri.href);

  if (properties.origin !== destUrlObj.origin && destUrlObj.protocol !== "data:") {
    if (!xhrUtils.validCORSHeaders(xhr, response, flag, properties, properties.origin)) {
      return;
    }

    var acehStr = response.headers["access-control-expose-headers"];
    var aceh = new Set(acehStr ? acehStr.trim().toLowerCase().split(xhrUtils.headerListSeparatorRegexp) : []);

    for (var header in headers) {
      var lcHeader = header.toLowerCase();

      if (!corsSafeResponseHeaders.has(lcHeader) && !aceh.has(lcHeader)) {
        filteredResponseHeaders.push(header);
      }
    }
  }

  for (var _header in headers) {
    var _lcHeader = _header.toLowerCase();

    if (forbiddenResponseHeaders.has(_lcHeader)) {
      filteredResponseHeaders.push(_header);
    }
  }

  xhr.responseURL = destUrlObj.href;
  xhr.status = statusCode;
  xhr.statusText = response.statusMessage || HTTP_STATUS_CODES[statusCode] || "";
  properties.responseHeaders = headers;
  properties.filteredResponseHeaders = filteredResponseHeaders;
  var contentLength = _getResponseHeader(xhr, "content-length") || "0";
  var bufferLength = parseInt(contentLength) || 0;
  var progressObj = {
    lengthComputable: false
  };
  var lastProgressReported;

  if (bufferLength !== 0) {
    progressObj.total = bufferLength;
    progressObj.loaded = 0;
    progressObj.lengthComputable = true;
  } // pre-allocate buffer.


  properties.responseBuffer = Buffer.alloc(properties.bufferStepSize);
  properties.responseCache = null;
  properties.responseTextCache = null;
  properties.responseXMLCache = null;
  readyStateChange(xhr, READY_STATES.HEADERS_RECEIVED);

  if (!properties.client) {
    // The request was aborted in reaction to the readystatechange event.
    return;
  } // Can't use the client since the client gets the post-ungzipping bytes (which can be greater than the
  // Content-Length).


  response.on("data", function (chunk) {
    byteOffset += chunk.length;
    progressObj.loaded = byteOffset;
  });
  properties.client.on("data", function (chunk) {
    properties.totalReceivedChunkSize += chunk.length;

    if (properties.totalReceivedChunkSize >= properties.bufferStepSize) {
      properties.bufferStepSize *= 2;

      while (properties.totalReceivedChunkSize >= properties.bufferStepSize) {
        properties.bufferStepSize *= 2;
      }

      var tmpBuf = Buffer.alloc(properties.bufferStepSize);
      properties.responseBuffer.copy(tmpBuf, 0, 0, properties.responseBuffer.length);
      properties.responseBuffer = tmpBuf;
    }

    chunk.copy(properties.responseBuffer, properties.totalReceivedChunkSize - chunk.length, 0, chunk.length);
    properties.responseCache = null;
    properties.responseTextCache = null;
    properties.responseXMLCache = null;

    if (xhr.readyState === READY_STATES.HEADERS_RECEIVED) {
      xhr.readyState = READY_STATES.LOADING;
    }

    fireAnEvent("readystatechange", xhr);

    if (progressObj.total !== progressObj.loaded || properties.totalReceivedChunkSize === byteOffset) {
      if (lastProgressReported !== progressObj.loaded) {
        // This is a necessary check in the gzip case where we can be getting new data from the client, as it
        // un-gzips, but no new data has been gotten from the response, so we should not fire a progress event.
        lastProgressReported = progressObj.loaded;
        fireAnEvent("progress", xhr, ProgressEvent, progressObj);
      }
    }
  });
  properties.client.on("end", function () {
    clearTimeout(properties.timeoutId);
    properties.timeoutFn = null;
    properties.timeoutStart = 0;
    properties.client = null;
    fireAnEvent("progress", xhr, ProgressEvent, progressObj);
    readyStateChange(xhr, READY_STATES.DONE);
    fireAnEvent("load", xhr, ProgressEvent, progressObj);
    fireAnEvent("loadend", xhr, ProgressEvent, progressObj);
  });
}

function setDispatchProgressEvents(xhr) {
  var properties = xhr.properties,
      upload = xhr.upload;
  var client = properties.client;
  var total = 0;
  var lengthComputable = false;
  var length = client.headers && parseInt(xhrUtils.getRequestHeader(client.headers, "content-length"));

  if (length) {
    total = length;
    lengthComputable = true;
  }

  var initProgress = {
    lengthComputable: lengthComputable,
    total: total,
    loaded: 0
  };

  if (properties.uploadListener) {
    fireAnEvent("loadstart", upload, ProgressEvent, initProgress);
  }

  client.on("request", function (req) {
    req.on("response", function () {
      properties.uploadComplete = true;

      if (!properties.uploadListener) {
        return;
      }

      var progress = {
        lengthComputable: lengthComputable,
        total: total,
        loaded: total
      };
      fireAnEvent("progress", upload, ProgressEvent, progress);
      fireAnEvent("load", upload, ProgressEvent, progress);
      fireAnEvent("loadend", upload, ProgressEvent, progress);
    });
  });
}

function finalMIMEType(xhr) {
  var flag = xhr.flag;
  return flag.overrideMIMEType || _getResponseHeader(xhr, "content-type");
}

function finalCharset(xhr) {
  var flag = xhr.flag;

  if (flag.overrideCharset) {
    return flag.overrideCharset;
  }

  var parsedContentType = MIMEType.parse(_getResponseHeader(xhr, "content-type"));

  if (parsedContentType) {
    return whatwgEncoding.labelToName(parsedContentType.parameters.get("charset"));
  }

  return null;
}

function _getResponseHeader(xhr, lcHeader) {
  var properties = xhr.properties;
  var keys = Object.keys(properties.responseHeaders);
  var n = keys.length;

  while (n--) {
    var key = keys[n];

    if (key.toLowerCase() === lcHeader) {
      return properties.responseHeaders[key];
    }
  }

  return null;
}

function normalizeHeaderValue(value) {
  return value.replace(/^[\x09\x0A\x0D\x20]+/, "").replace(/[\x09\x0A\x0D\x20]+$/, "");
}

function extractBody(bodyInit) {
  // https://fetch.spec.whatwg.org/#concept-bodyinit-extract
  // except we represent the body as a Node.js Buffer instead,
  // or a special case for FormData since we want request to handle that. Probably it would be
  // cleaner (and allow a future without request) if we did the form encoding ourself.
  if (Blob.isImpl(bodyInit)) {
    return {
      buffer: bodyInit._buffer,
      contentType: bodyInit.type === "" ? null : bodyInit.type
    };
  } else if (isArrayBuffer(bodyInit)) {
    return {
      buffer: Buffer.from(bodyInit),
      contentType: null
    };
  } else if (ArrayBuffer.isView(bodyInit)) {
    return {
      buffer: Buffer.from(bodyInit.buffer, bodyInit.byteOffset, bodyInit.byteLength),
      contentType: null
    };
  } else if (FormData.isImpl(bodyInit)) {
    var formData = [];
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = bodyInit._entries[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var entry = _step.value;
        var val = void 0;

        if (Blob.isImpl(entry.value)) {
          var blob = entry.value;
          val = {
            name: entry.name,
            value: blob._buffer,
            options: {
              filename: blob.name,
              contentType: blob.type,
              knownLength: blob.size
            }
          };
        } else {
          val = entry;
        }

        formData.push(val);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator["return"] != null) {
          _iterator["return"]();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return {
      formData: formData
    };
  } // Must be a string


  return {
    buffer: Buffer.from(bodyInit, "utf-8"),
    contentType: "text/plain;charset=UTF-8"
  };
}

exports.implementation = XMLHttpRequestImpl;