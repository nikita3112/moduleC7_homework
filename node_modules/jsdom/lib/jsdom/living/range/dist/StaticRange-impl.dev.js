"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var DOMException = require("domexception/webidl2js-wrapper");

var NODE_TYPE = require("../node-type");

var AbstractRangeImpl = require("./AbstractRange-impl").implementation; // https://dom.spec.whatwg.org/#staticrange


var StaticRangeImpl =
/*#__PURE__*/
function (_AbstractRangeImpl) {
  _inherits(StaticRangeImpl, _AbstractRangeImpl);

  // https://dom.spec.whatwg.org/#dom-staticrange-staticrange
  function StaticRangeImpl(globalObject, args) {
    _classCallCheck(this, StaticRangeImpl);

    var _args$ = args[0],
        startContainer = _args$.startContainer,
        startOffset = _args$.startOffset,
        endContainer = _args$.endContainer,
        endOffset = _args$.endOffset;

    if (startContainer.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE || startContainer.nodeType === NODE_TYPE.ATTRIBUTE_NODE || endContainer.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE || endContainer.nodeType === NODE_TYPE.ATTRIBUTE_NODE) {
      throw DOMException.create(globalObject, ["The supplied node is incorrect.", "InvalidNodeTypeError"]);
    }

    return _possibleConstructorReturn(this, _getPrototypeOf(StaticRangeImpl).call(this, globalObject, [], {
      start: {
        node: startContainer,
        offset: startOffset
      },
      end: {
        node: endContainer,
        offset: endOffset
      }
    }));
  }

  return StaticRangeImpl;
}(AbstractRangeImpl);

module.exports = {
  implementation: StaticRangeImpl
};