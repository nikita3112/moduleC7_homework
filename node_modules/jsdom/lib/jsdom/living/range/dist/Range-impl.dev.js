"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var DOMException = require("domexception/webidl2js-wrapper");

var _require = require("../node"),
    clone = _require.clone;

var NODE_TYPE = require("../node-type");

var _require2 = require("../../browser/parser/index"),
    parseFragment = _require2.parseFragment;

var _require3 = require("../helpers/namespaces"),
    HTML_NS = _require3.HTML_NS;

var _require4 = require("../helpers/internal-constants"),
    domSymbolTree = _require4.domSymbolTree;

var _require5 = require("./boundary-point"),
    compareBoundaryPointsPosition = _require5.compareBoundaryPointsPosition;

var _require6 = require("../helpers/node"),
    nodeRoot = _require6.nodeRoot,
    nodeLength = _require6.nodeLength,
    isInclusiveAncestor = _require6.isInclusiveAncestor;

var _require7 = require("../helpers/create-element"),
    createElement = _require7.createElement;

var AbstractRangeImpl = require("./AbstractRange-impl").implementation;

var Range = require("../generated/Range");

var DocumentFragment = require("../generated/DocumentFragment");

var _require8 = require("../generated/utils"),
    implForWrapper = _require8.implForWrapper;

var RANGE_COMPARISON_TYPE = {
  START_TO_START: 0,
  START_TO_END: 1,
  END_TO_END: 2,
  END_TO_START: 3
};

var RangeImpl =
/*#__PURE__*/
function (_AbstractRangeImpl) {
  _inherits(RangeImpl, _AbstractRangeImpl);

  function RangeImpl(globalObject, args, privateData) {
    var _this;

    _classCallCheck(this, RangeImpl);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(RangeImpl).call(this, globalObject, args, privateData));
    var defaultBoundaryPoint = {
      node: implForWrapper(globalObject._document),
      offset: 0
    };
    var _privateData$start = privateData.start,
        start = _privateData$start === void 0 ? defaultBoundaryPoint : _privateData$start,
        _privateData$end = privateData.end,
        end = _privateData$end === void 0 ? defaultBoundaryPoint : _privateData$end;

    _this._setLiveRangeStart(start.node, start.offset);

    _this._setLiveRangeEnd(end.node, end.offset);

    return _this;
  } // https://dom.spec.whatwg.org/#dom-range-commonancestorcontainer


  _createClass(RangeImpl, [{
    key: "setStart",
    // https://dom.spec.whatwg.org/#dom-range-setstart
    value: function setStart(node, offset) {
      setBoundaryPointStart(this, node, offset);
    } // https://dom.spec.whatwg.org/#dom-range-setend

  }, {
    key: "setEnd",
    value: function setEnd(node, offset) {
      setBoundaryPointEnd(this, node, offset);
    } // https://dom.spec.whatwg.org/#dom-range-setstartbefore

  }, {
    key: "setStartBefore",
    value: function setStartBefore(node) {
      var parent = domSymbolTree.parent(node);

      if (!parent) {
        throw DOMException.create(this._globalObject, ["The given Node has no parent.", "InvalidNodeTypeError"]);
      }

      setBoundaryPointStart(this, parent, domSymbolTree.index(node));
    } // https://dom.spec.whatwg.org/#dom-range-setstartafter

  }, {
    key: "setStartAfter",
    value: function setStartAfter(node) {
      var parent = domSymbolTree.parent(node);

      if (!parent) {
        throw DOMException.create(this._globalObject, ["The given Node has no parent.", "InvalidNodeTypeError"]);
      }

      setBoundaryPointStart(this, parent, domSymbolTree.index(node) + 1);
    } // https://dom.spec.whatwg.org/#dom-range-setendbefore

  }, {
    key: "setEndBefore",
    value: function setEndBefore(node) {
      var parent = domSymbolTree.parent(node);

      if (!parent) {
        throw DOMException.create(this._globalObject, ["The given Node has no parent.", "InvalidNodeTypeError"]);
      }

      setBoundaryPointEnd(this, parent, domSymbolTree.index(node));
    } // https://dom.spec.whatwg.org/#dom-range-setendafter

  }, {
    key: "setEndAfter",
    value: function setEndAfter(node) {
      var parent = domSymbolTree.parent(node);

      if (!parent) {
        throw DOMException.create(this._globalObject, ["The given Node has no parent.", "InvalidNodeTypeError"]);
      }

      setBoundaryPointEnd(this, parent, domSymbolTree.index(node) + 1);
    } // https://dom.spec.whatwg.org/#dom-range-collapse

  }, {
    key: "collapse",
    value: function collapse(toStart) {
      if (toStart) {
        this._setLiveRangeEnd(this._start.node, this._start.offset);
      } else {
        this._setLiveRangeStart(this._end.node, this._end.offset);
      }
    } // https://dom.spec.whatwg.org/#dom-range-selectnode

  }, {
    key: "selectNode",
    value: function selectNode(node) {
      selectNodeWithinRange(node, this);
    } // https://dom.spec.whatwg.org/#dom-range-selectnodecontents

  }, {
    key: "selectNodeContents",
    value: function selectNodeContents(node) {
      if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {
        throw DOMException.create(this._globalObject, ["DocumentType Node can't be used as boundary point.", "InvalidNodeTypeError"]);
      }

      var length = nodeLength(node);

      this._setLiveRangeStart(node, 0);

      this._setLiveRangeEnd(node, length);
    } // https://dom.spec.whatwg.org/#dom-range-compareboundarypoints

  }, {
    key: "compareBoundaryPoints",
    value: function compareBoundaryPoints(how, sourceRange) {
      if (how !== RANGE_COMPARISON_TYPE.START_TO_START && how !== RANGE_COMPARISON_TYPE.START_TO_END && how !== RANGE_COMPARISON_TYPE.END_TO_END && how !== RANGE_COMPARISON_TYPE.END_TO_START) {
        var message = "The comparison method provided must be one of 'START_TO_START', 'START_TO_END', 'END_TO_END', " + "or 'END_TO_START'.";
        throw DOMException.create(this._globalObject, [message, "NotSupportedError"]);
      }

      if (this._root !== sourceRange._root) {
        throw DOMException.create(this._globalObject, ["The two Ranges are not in the same tree.", "WrongDocumentError"]);
      }

      var thisPoint;
      var otherPoint;

      if (how === RANGE_COMPARISON_TYPE.START_TO_START) {
        thisPoint = this._start;
        otherPoint = sourceRange._start;
      } else if (how === RANGE_COMPARISON_TYPE.START_TO_END) {
        thisPoint = this._end;
        otherPoint = sourceRange._start;
      } else if (how === RANGE_COMPARISON_TYPE.END_TO_END) {
        thisPoint = this._end;
        otherPoint = sourceRange._end;
      } else {
        thisPoint = this._start;
        otherPoint = sourceRange._end;
      }

      return compareBoundaryPointsPosition(thisPoint, otherPoint);
    } // https://dom.spec.whatwg.org/#dom-range-deletecontents

  }, {
    key: "deleteContents",
    value: function deleteContents() {
      if (this.collapsed) {
        return;
      }

      var originalStart = this._start,
          originalEnd = this._end;

      if (originalStart.node === originalEnd.node && (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE)) {
        originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, "");
        return;
      }

      var nodesToRemove = [];
      var currentNode = this._start.node;
      var endNode = nextNodeDescendant(this._end.node);

      while (currentNode && currentNode !== endNode) {
        if (isContained(currentNode, this) && !isContained(domSymbolTree.parent(currentNode), this)) {
          nodesToRemove.push(currentNode);
        }

        currentNode = domSymbolTree.following(currentNode);
      }

      var newNode;
      var newOffset;

      if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {
        newNode = originalStart.node;
        newOffset = originalStart.offset;
      } else {
        var referenceNode = originalStart.node;

        while (referenceNode && !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)) {
          referenceNode = domSymbolTree.parent(referenceNode);
        }

        newNode = domSymbolTree.parent(referenceNode);
        newOffset = domSymbolTree.index(referenceNode) + 1;
      }

      if (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE) {
        originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, "");
      }

      for (var _i = 0, _nodesToRemove = nodesToRemove; _i < _nodesToRemove.length; _i++) {
        var node = _nodesToRemove[_i];
        var parent = domSymbolTree.parent(node);
        parent.removeChild(node);
      }

      if (originalEnd.node.nodeType === NODE_TYPE.TEXT_NODE || originalEnd.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalEnd.node.nodeType === NODE_TYPE.COMMENT_NODE) {
        originalEnd.node.replaceData(0, originalEnd.offset, "");
      }

      this._setLiveRangeStart(newNode, newOffset);

      this._setLiveRangeEnd(newNode, newOffset);
    } // https://dom.spec.whatwg.org/#dom-range-extractcontents

  }, {
    key: "extractContents",
    value: function extractContents() {
      return extractRange(this);
    } // https://dom.spec.whatwg.org/#dom-range-clonecontents

  }, {
    key: "cloneContents",
    value: function cloneContents() {
      return cloneRange(this);
    } // https://dom.spec.whatwg.org/#dom-range-insertnode

  }, {
    key: "insertNode",
    value: function insertNode(node) {
      insertNodeInRange(node, this);
    } // https://dom.spec.whatwg.org/#dom-range-surroundcontents

  }, {
    key: "surroundContents",
    value: function surroundContents(newParent) {
      var node = this.commonAncestorContainer;
      var endNode = nextNodeDescendant(node);

      while (node !== endNode) {
        if (node.nodeType !== NODE_TYPE.TEXT_NODE && isPartiallyContained(node, this)) {
          throw DOMException.create(this._globalObject, ["The Range has partially contains a non-Text node.", "InvalidStateError"]);
        }

        node = domSymbolTree.following(node);
      }

      if (newParent.nodeType === NODE_TYPE.DOCUMENT_NODE || newParent.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE || newParent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {
        throw DOMException.create(this._globalObject, ["Invalid element type.", "InvalidNodeTypeError"]);
      }

      var fragment = extractRange(this);

      while (domSymbolTree.firstChild(newParent)) {
        newParent.removeChild(domSymbolTree.firstChild(newParent));
      }

      insertNodeInRange(newParent, this);
      newParent.appendChild(fragment);
      selectNodeWithinRange(newParent, this);
    } // https://dom.spec.whatwg.org/#dom-range-clonerange

  }, {
    key: "cloneRange",
    value: function cloneRange() {
      var _start = this._start,
          _end = this._end,
          _globalObject = this._globalObject;
      return Range.createImpl(_globalObject, [], {
        start: {
          node: _start.node,
          offset: _start.offset
        },
        end: {
          node: _end.node,
          offset: _end.offset
        }
      });
    } // https://dom.spec.whatwg.org/#dom-range-detach

  }, {
    key: "detach",
    value: function detach() {} // Do nothing by spec!
    // https://dom.spec.whatwg.org/#dom-range-ispointinrange

  }, {
    key: "isPointInRange",
    value: function isPointInRange(node, offset) {
      if (nodeRoot(node) !== this._root) {
        return false;
      }

      validateSetBoundaryPoint(node, offset);
      var bp = {
        node: node,
        offset: offset
      };

      if (compareBoundaryPointsPosition(bp, this._start) === -1 || compareBoundaryPointsPosition(bp, this._end) === 1) {
        return false;
      }

      return true;
    } // https://dom.spec.whatwg.org/#dom-range-comparepoint

  }, {
    key: "comparePoint",
    value: function comparePoint(node, offset) {
      if (nodeRoot(node) !== this._root) {
        throw DOMException.create(this._globalObject, ["The given Node and the Range are not in the same tree.", "WrongDocumentError"]);
      }

      validateSetBoundaryPoint(node, offset);
      var bp = {
        node: node,
        offset: offset
      };

      if (compareBoundaryPointsPosition(bp, this._start) === -1) {
        return -1;
      } else if (compareBoundaryPointsPosition(bp, this._end) === 1) {
        return 1;
      }

      return 0;
    } // https://dom.spec.whatwg.org/#dom-range-intersectsnode

  }, {
    key: "intersectsNode",
    value: function intersectsNode(node) {
      if (nodeRoot(node) !== this._root) {
        return false;
      }

      var parent = domSymbolTree.parent(node);

      if (!parent) {
        return true;
      }

      var offset = domSymbolTree.index(node);
      return compareBoundaryPointsPosition({
        node: parent,
        offset: offset
      }, this._end) === -1 && compareBoundaryPointsPosition({
        node: parent,
        offset: offset + 1
      }, this._start) === 1;
    } // https://dom.spec.whatwg.org/#dom-range-stringifier

  }, {
    key: "toString",
    value: function toString() {
      var s = "";
      var _start = this._start,
          _end = this._end;

      if (_start.node === _end.node && _start.node.nodeType === NODE_TYPE.TEXT_NODE) {
        return _start.node.data.slice(_start.offset, _end.offset);
      }

      if (_start.node.nodeType === NODE_TYPE.TEXT_NODE) {
        s += _start.node.data.slice(_start.offset);
      }

      var currentNode = _start.node;
      var endNode = nextNodeDescendant(_end.node);

      while (currentNode && currentNode !== endNode) {
        if (currentNode.nodeType === NODE_TYPE.TEXT_NODE && isContained(currentNode, this)) {
          s += currentNode.data;
        }

        currentNode = domSymbolTree.following(currentNode);
      }

      if (_end.node.nodeType === NODE_TYPE.TEXT_NODE) {
        s += _end.node.data.slice(0, _end.offset);
      }

      return s;
    } // https://w3c.github.io/DOM-Parsing/#dom-range-createcontextualfragment

  }, {
    key: "createContextualFragment",
    value: function createContextualFragment(fragment) {
      var node = this._start.node;
      var element;

      switch (node.nodeType) {
        case NODE_TYPE.DOCUMENT_NODE:
        case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:
          element = null;
          break;

        case NODE_TYPE.ELEMENT_NODE:
          element = node;
          break;

        case NODE_TYPE.TEXT_NODE:
        case NODE_TYPE.COMMENT_NODE:
          element = node.parentElement;
          break;

        default:
          throw new Error("Internal error: Invalid range start node");
      }

      if (element === null || element._ownerDocument._parsingMode === "html" && element._localName === "html" && element._namespaceURI === HTML_NS) {
        element = createElement(node._ownerDocument, "body", HTML_NS);
      }

      return parseFragment(fragment, element);
    } // https://dom.spec.whatwg.org/#concept-range-root

  }, {
    key: "_setLiveRangeStart",
    value: function _setLiveRangeStart(node, offset) {
      if (this._start && this._start.node !== node) {
        this._start.node._referencedRanges["delete"](this);
      }

      if (!node._referencedRanges.has(this)) {
        node._referencedRanges.add(this);
      }

      this._start = {
        node: node,
        offset: offset
      };
    }
  }, {
    key: "_setLiveRangeEnd",
    value: function _setLiveRangeEnd(node, offset) {
      if (this._end && this._end.node !== node) {
        this._end.node._referencedRanges["delete"](this);
      }

      if (!node._referencedRanges.has(this)) {
        node._referencedRanges.add(this);
      }

      this._end = {
        node: node,
        offset: offset
      };
    }
  }, {
    key: "commonAncestorContainer",
    get: function get() {
      var _start = this._start,
          _end = this._end;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = domSymbolTree.ancestorsIterator(_start.node)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var container = _step.value;

          if (isInclusiveAncestor(container, _end.node)) {
            return container;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return null;
    }
  }, {
    key: "_root",
    get: function get() {
      return nodeRoot(this._start.node);
    }
  }]);

  return RangeImpl;
}(AbstractRangeImpl);

function nextNodeDescendant(node) {
  while (node && !domSymbolTree.nextSibling(node)) {
    node = domSymbolTree.parent(node);
  }

  if (!node) {
    return null;
  }

  return domSymbolTree.nextSibling(node);
} // https://dom.spec.whatwg.org/#concept-range-bp-set


function validateSetBoundaryPoint(node, offset) {
  if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {
    throw DOMException.create(node._globalObject, ["DocumentType Node can't be used as boundary point.", "InvalidNodeTypeError"]);
  }

  if (offset > nodeLength(node)) {
    throw DOMException.create(node._globalObject, ["Offset out of bound.", "IndexSizeError"]);
  }
}

function setBoundaryPointStart(range, node, offset) {
  validateSetBoundaryPoint(node, offset);
  var bp = {
    node: node,
    offset: offset
  };

  if (nodeRoot(node) !== range._root || compareBoundaryPointsPosition(bp, range._end) === 1) {
    range._setLiveRangeEnd(node, offset);
  }

  range._setLiveRangeStart(node, offset);
}

function setBoundaryPointEnd(range, node, offset) {
  validateSetBoundaryPoint(node, offset);
  var bp = {
    node: node,
    offset: offset
  };

  if (nodeRoot(node) !== range._root || compareBoundaryPointsPosition(bp, range._start) === -1) {
    range._setLiveRangeStart(node, offset);
  }

  range._setLiveRangeEnd(node, offset);
} // https://dom.spec.whatwg.org/#concept-range-select


function selectNodeWithinRange(node, range) {
  var parent = domSymbolTree.parent(node);

  if (!parent) {
    throw DOMException.create(node._globalObject, ["The given Node has no parent.", "InvalidNodeTypeError"]);
  }

  var index = domSymbolTree.index(node);

  range._setLiveRangeStart(parent, index);

  range._setLiveRangeEnd(parent, index + 1);
} // https://dom.spec.whatwg.org/#contained


function isContained(node, range) {
  var _start = range._start,
      _end = range._end;
  return compareBoundaryPointsPosition({
    node: node,
    offset: 0
  }, _start) === 1 && compareBoundaryPointsPosition({
    node: node,
    offset: nodeLength(node)
  }, _end) === -1;
} // https://dom.spec.whatwg.org/#partially-contained


function isPartiallyContained(node, range) {
  var _start = range._start,
      _end = range._end;
  return isInclusiveAncestor(node, _start.node) && !isInclusiveAncestor(node, _end.node) || !isInclusiveAncestor(node, _start.node) && isInclusiveAncestor(node, _end.node);
} // https://dom.spec.whatwg.org/#concept-range-insert


function insertNodeInRange(node, range) {
  var _range$_start = range._start,
      startNode = _range$_start.node,
      startOffset = _range$_start.offset;

  if (startNode.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || startNode.nodeType === NODE_TYPE.COMMENT_NODE || startNode.nodeType === NODE_TYPE.TEXT_NODE && !domSymbolTree.parent(startNode) || node === startNode) {
    throw DOMException.create(node._globalObject, ["Invalid start node.", "HierarchyRequestError"]);
  }

  var referenceNode = startNode.nodeType === NODE_TYPE.TEXT_NODE ? startNode : domSymbolTree.childrenToArray(startNode)[startOffset] || null;
  var parent = !referenceNode ? startNode : domSymbolTree.parent(referenceNode);

  parent._preInsertValidity(node, referenceNode);

  if (startNode.nodeType === NODE_TYPE.TEXT_NODE) {
    referenceNode = startNode.splitText(startOffset);
  }

  if (node === referenceNode) {
    referenceNode = domSymbolTree.nextSibling(referenceNode);
  }

  var nodeParent = domSymbolTree.parent(node);

  if (nodeParent) {
    nodeParent.removeChild(node);
  }

  var newOffset = !referenceNode ? nodeLength(parent) : domSymbolTree.index(referenceNode);
  newOffset += node.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE ? nodeLength(node) : 1;
  parent.insertBefore(node, referenceNode);

  if (range.collapsed) {
    range._setLiveRangeEnd(parent, newOffset);
  }
} // https://dom.spec.whatwg.org/#concept-range-clone


function cloneRange(range) {
  var originalStart = range._start,
      originalEnd = range._end,
      _globalObject = range._globalObject;
  var fragment = DocumentFragment.createImpl(_globalObject, [], {
    ownerDocument: originalStart.node._ownerDocument
  });

  if (range.collapsed) {
    return fragment;
  }

  if (originalStart.node === originalEnd.node && (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE)) {
    var cloned = clone(originalStart.node);
    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);
    fragment.appendChild(cloned);
    return fragment;
  }

  var commonAncestor = originalStart.node;

  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {
    commonAncestor = domSymbolTree.parent(commonAncestor);
  }

  var firstPartialContainedChild = null;

  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {
    var candidate = domSymbolTree.firstChild(commonAncestor);

    while (!firstPartialContainedChild) {
      if (isPartiallyContained(candidate, range)) {
        firstPartialContainedChild = candidate;
      }

      candidate = domSymbolTree.nextSibling(candidate);
    }
  }

  var lastPartiallyContainedChild = null;

  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {
    var _candidate = domSymbolTree.lastChild(commonAncestor);

    while (!lastPartiallyContainedChild) {
      if (isPartiallyContained(_candidate, range)) {
        lastPartiallyContainedChild = _candidate;
      }

      _candidate = domSymbolTree.previousSibling(_candidate);
    }
  }

  var containedChildren = domSymbolTree.childrenToArray(commonAncestor).filter(function (node) {
    return isContained(node, range);
  });
  var hasDoctypeChildren = containedChildren.some(function (node) {
    return node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE;
  });

  if (hasDoctypeChildren) {
    throw DOMException.create(range._globalObject, ["Invalid document type element.", "HierarchyRequestError"]);
  }

  if (firstPartialContainedChild !== null && (firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {
    var _cloned = clone(originalStart.node);

    _cloned._data = _cloned.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);
    fragment.appendChild(_cloned);
  } else if (firstPartialContainedChild !== null) {
    var _cloned2 = clone(firstPartialContainedChild);

    fragment.appendChild(_cloned2);
    var subrange = Range.createImpl(_globalObject, [], {
      start: {
        node: originalStart.node,
        offset: originalStart.offset
      },
      end: {
        node: firstPartialContainedChild,
        offset: nodeLength(firstPartialContainedChild)
      }
    });
    var subfragment = cloneRange(subrange);

    _cloned2.appendChild(subfragment);
  }

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = containedChildren[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var containedChild = _step2.value;

      var _cloned5 = clone(containedChild, undefined, true);

      fragment.appendChild(_cloned5);
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  if (lastPartiallyContainedChild !== null && (lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {
    var _cloned3 = clone(originalEnd.node);

    _cloned3._data = _cloned3.substringData(0, originalEnd.offset);
    fragment.appendChild(_cloned3);
  } else if (lastPartiallyContainedChild !== null) {
    var _cloned4 = clone(lastPartiallyContainedChild);

    fragment.appendChild(_cloned4);

    var _subrange = Range.createImpl(_globalObject, [], {
      start: {
        node: lastPartiallyContainedChild,
        offset: 0
      },
      end: {
        node: originalEnd.node,
        offset: originalEnd.offset
      }
    });

    var _subfragment = cloneRange(_subrange);

    _cloned4.appendChild(_subfragment);
  }

  return fragment;
} // https://dom.spec.whatwg.org/#concept-range-extract


function extractRange(range) {
  var originalStart = range._start,
      originalEnd = range._end,
      _globalObject = range._globalObject;
  var fragment = DocumentFragment.createImpl(_globalObject, [], {
    ownerDocument: originalStart.node._ownerDocument
  });

  if (range.collapsed) {
    return fragment;
  }

  if (originalStart.node === originalEnd.node && (originalStart.node.nodeType === NODE_TYPE.TEXT_NODE || originalStart.node.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || originalStart.node.nodeType === NODE_TYPE.COMMENT_NODE)) {
    var cloned = clone(originalStart.node);
    cloned._data = cloned.substringData(originalStart.offset, originalEnd.offset - originalStart.offset);
    fragment.appendChild(cloned);
    originalStart.node.replaceData(originalStart.offset, originalEnd.offset - originalStart.offset, "");
    return fragment;
  }

  var commonAncestor = originalStart.node;

  while (!isInclusiveAncestor(commonAncestor, originalEnd.node)) {
    commonAncestor = domSymbolTree.parent(commonAncestor);
  }

  var firstPartialContainedChild = null;

  if (!isInclusiveAncestor(originalStart.node, originalEnd.node)) {
    var candidate = domSymbolTree.firstChild(commonAncestor);

    while (!firstPartialContainedChild) {
      if (isPartiallyContained(candidate, range)) {
        firstPartialContainedChild = candidate;
      }

      candidate = domSymbolTree.nextSibling(candidate);
    }
  }

  var lastPartiallyContainedChild = null;

  if (!isInclusiveAncestor(originalEnd.node, originalStart.node)) {
    var _candidate2 = domSymbolTree.lastChild(commonAncestor);

    while (!lastPartiallyContainedChild) {
      if (isPartiallyContained(_candidate2, range)) {
        lastPartiallyContainedChild = _candidate2;
      }

      _candidate2 = domSymbolTree.previousSibling(_candidate2);
    }
  }

  var containedChildren = domSymbolTree.childrenToArray(commonAncestor).filter(function (node) {
    return isContained(node, range);
  });
  var hasDoctypeChildren = containedChildren.some(function (node) {
    return node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE;
  });

  if (hasDoctypeChildren) {
    throw DOMException.create(range._globalObject, ["Invalid document type element.", "HierarchyRequestError"]);
  }

  var newNode;
  var newOffset;

  if (isInclusiveAncestor(originalStart.node, originalEnd.node)) {
    newNode = originalStart.node;
    newOffset = originalStart.offset;
  } else {
    var referenceNode = originalStart.node;

    while (referenceNode && !isInclusiveAncestor(domSymbolTree.parent(referenceNode), originalEnd.node)) {
      referenceNode = domSymbolTree.parent(referenceNode);
    }

    newNode = domSymbolTree.parent(referenceNode);
    newOffset = domSymbolTree.index(referenceNode) + 1;
  }

  if (firstPartialContainedChild !== null && (firstPartialContainedChild.nodeType === NODE_TYPE.TEXT_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || firstPartialContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {
    var _cloned6 = clone(originalStart.node);

    _cloned6._data = _cloned6.substringData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset);
    fragment.appendChild(_cloned6);
    originalStart.node.replaceData(originalStart.offset, nodeLength(originalStart.node) - originalStart.offset, "");
  } else if (firstPartialContainedChild !== null) {
    var _cloned7 = clone(firstPartialContainedChild);

    fragment.appendChild(_cloned7);
    var subrange = Range.createImpl(_globalObject, [], {
      start: {
        node: originalStart.node,
        offset: originalStart.offset
      },
      end: {
        node: firstPartialContainedChild,
        offset: nodeLength(firstPartialContainedChild)
      }
    });
    var subfragment = extractRange(subrange);

    _cloned7.appendChild(subfragment);
  }

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = containedChildren[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var containedChild = _step3.value;
      fragment.appendChild(containedChild);
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  if (lastPartiallyContainedChild !== null && (lastPartiallyContainedChild.nodeType === NODE_TYPE.TEXT_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.PROCESSING_INSTRUCTION_NODE || lastPartiallyContainedChild.nodeType === NODE_TYPE.COMMENT_NODE)) {
    var _cloned8 = clone(originalEnd.node);

    _cloned8._data = _cloned8.substringData(0, originalEnd.offset);
    fragment.appendChild(_cloned8);
    originalEnd.node.replaceData(0, originalEnd.offset, "");
  } else if (lastPartiallyContainedChild !== null) {
    var _cloned9 = clone(lastPartiallyContainedChild);

    fragment.appendChild(_cloned9);

    var _subrange2 = Range.createImpl(_globalObject, [], {
      start: {
        node: lastPartiallyContainedChild,
        offset: 0
      },
      end: {
        node: originalEnd.node,
        offset: originalEnd.offset
      }
    });

    var _subfragment2 = extractRange(_subrange2);

    _cloned9.appendChild(_subfragment2);
  }

  range._setLiveRangeStart(newNode, newOffset);

  range._setLiveRangeEnd(newNode, newOffset);

  return fragment;
}

module.exports = {
  implementation: RangeImpl,
  setBoundaryPointStart: setBoundaryPointStart,
  setBoundaryPointEnd: setBoundaryPointEnd
};