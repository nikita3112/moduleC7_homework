"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var whatwgURL = require("whatwg-url");

var HashChangeEvent = require("../generated/HashChangeEvent.js");

var PopStateEvent = require("../generated/PopStateEvent.js");

var notImplemented = require("../../browser/not-implemented.js");

var idlUtils = require("../generated/utils.js");

var _require = require("../helpers/events"),
    fireAnEvent = _require.fireAnEvent; // https://html.spec.whatwg.org/#session-history


var SessionHistory =
/*#__PURE__*/
function () {
  function SessionHistory(initialEntry, window) {
    _classCallCheck(this, SessionHistory);

    this._window = window;
    this._windowImpl = idlUtils.implForWrapper(window);
    this._historyTraversalQueue = new Set();
    this._entries = [initialEntry];
    this._currentIndex = 0;
  }

  _createClass(SessionHistory, [{
    key: "_queueHistoryTraversalTask",
    value: function _queueHistoryTraversalTask(fn) {
      var _this = this;

      var timeoutId = this._window.setTimeout(function () {
        _this._historyTraversalQueue["delete"](timeoutId);

        fn();
      }, 0);

      this._historyTraversalQueue.add(timeoutId);
    }
  }, {
    key: "clearHistoryTraversalTasks",
    value: function clearHistoryTraversalTasks() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._historyTraversalQueue[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var timeoutId = _step.value;

          this._window.clearTimeout(timeoutId);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this._historyTraversalQueue.clear();
    }
  }, {
    key: "removeAllEntriesAfterCurrentEntry",
    // https://html.spec.whatwg.org/#dom-history-pushstate
    value: function removeAllEntriesAfterCurrentEntry() {
      this._entries.splice(this._currentIndex + 1, Infinity);
    } // https://html.spec.whatwg.org/#traverse-the-history-by-a-delta

  }, {
    key: "traverseByDelta",
    value: function traverseByDelta(delta) {
      var _this2 = this;

      this._queueHistoryTraversalTask(function () {
        var newIndex = _this2._currentIndex + delta;

        if (newIndex < 0 || newIndex >= _this2.length) {
          return;
        }

        var specifiedEntry = _this2._entries[newIndex]; // Not implemented: unload a document guard
        // Not clear that this should be queued. html/browsers/history/the-history-interface/004.html can be fixed
        // by removing the queue, but doing so breaks some tests in history.js that also pass in browsers.

        _this2._queueHistoryTraversalTask(function () {
          // If there is an ongoing attempt to navigate specified browsing context that has not yet matured,
          // then cancel that attempt to navigate the browsing context.
          // Doing this seems to break tests involving navigating via push/pop state and via fragments. I think this
          // is because these navigations should already count as having "matured" because the document is not changing.
          // this.clearHistoryTraversalTasks();
          if (specifiedEntry.document !== _this2.currentEntry.document) {
            // TODO: unload the active document with the recycle parameter set to false
            notImplemented("Traversing history in a way that would change the window", _this2._window);
          }

          _this2.traverseHistory(specifiedEntry);
        });
      });
    } // https://html.spec.whatwg.org/#traverse-the-history

  }, {
    key: "traverseHistory",
    value: function traverseHistory(specifiedEntry) {
      var _this3 = this;

      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (!specifiedEntry.document) {
        // If entry no longer holds a Document object, then navigate the browsing context to entry's URL
        // to perform an entry update of entry, and abort these steps
        notImplemented("Traversing the history to an entry that no longer holds a Document object", this._window);
      } // Not spec compliant, just minimal. Lots of missing steps.


      var nonBlockingEvents = Boolean(flags.nonBlockingEvents);
      var document = idlUtils.implForWrapper(this._window._document);
      var currentEntry = this.currentEntry; // If the current entry's title was not set by the pushState() or replaceState() methods, then set its title
      // to the value returned by the document.title IDL attribute.

      if (currentEntry.title === undefined) {
        currentEntry.title = document.title;
      }

      if (specifiedEntry.document !== currentEntry.document) {
        // If entry has a different Document object than the current entry, then...
        notImplemented("Traversing the history to an entry with a different Document", this._window);
      }

      document._URL = specifiedEntry.url;
      var hashChanged = specifiedEntry.url.fragment !== currentEntry.url.fragment && specifiedEntry.document === currentEntry.document;
      var oldURL;
      var newURL;

      if (hashChanged) {
        oldURL = currentEntry.url;
        newURL = specifiedEntry.url;
      }

      if (flags.replacement) {
        // If the traversal was initiated with replacement enabled, remove the entry immediately before the
        // specified entry in the session history.
        this._entries.splice(this._entries.indexOf(specifiedEntry) - 1, 1);
      }

      this.updateCurrentEntry(specifiedEntry);
      var state = specifiedEntry.stateObject; // TODO structured clone
      // arguably it's a bit odd that the state and latestEntry do not belong to the SessionHistory
      // but the spec gives them to "History" and "Document" respecively.

      document._history._state = state;
      var stateChanged = specifiedEntry.document._latestEntry !== specifiedEntry;
      specifiedEntry.document._latestEntry = specifiedEntry;

      var fireEvents = function fireEvents() {
        return _this3._fireEvents(stateChanged, hashChanged, state, oldURL, newURL);
      };

      if (nonBlockingEvents) {
        this._window.setTimeout(fireEvents, 0);
      } else {
        fireEvents();
      }
    }
  }, {
    key: "_fireEvents",
    value: function _fireEvents(stateChanged, hashChanged, state, oldURL, newURL) {
      if (stateChanged) {
        fireAnEvent("popstate", this._windowImpl, PopStateEvent, {
          state: state
        });
      }

      if (hashChanged) {
        fireAnEvent("hashchange", this._windowImpl, HashChangeEvent, {
          oldURL: whatwgURL.serializeURL(oldURL),
          newURL: whatwgURL.serializeURL(newURL)
        });
      }
    }
  }, {
    key: "addEntryAfterCurrentEntry",
    value: function addEntryAfterCurrentEntry(entry) {
      this._entries.splice(this._currentIndex + 1, 0, entry);
    }
  }, {
    key: "updateCurrentEntry",
    value: function updateCurrentEntry(entry) {
      this._currentIndex = this._entries.indexOf(entry);
    }
  }, {
    key: "length",
    get: function get() {
      return this._entries.length;
    }
  }, {
    key: "currentEntry",
    get: function get() {
      return this._entries[this._currentIndex];
    }
  }]);

  return SessionHistory;
}();

module.exports = SessionHistory;