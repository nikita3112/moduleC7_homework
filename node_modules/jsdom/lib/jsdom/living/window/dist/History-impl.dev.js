"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DOMException = require("domexception/webidl2js-wrapper");

var _require = require("../helpers/document-base-url.js"),
    documentBaseURLSerialized = _require.documentBaseURLSerialized,
    parseURLToResultingURLRecord = _require.parseURLToResultingURLRecord; // https://html.spec.whatwg.org/#history-3


exports.implementation =
/*#__PURE__*/
function () {
  function HistoryImpl(globalObject, args, privateData) {
    _classCallCheck(this, HistoryImpl);

    this._window = privateData.window;
    this._document = privateData.document;
    this._actAsIfLocationReloadCalled = privateData.actAsIfLocationReloadCalled;
    this._state = null;
    this._globalObject = globalObject;
  }

  _createClass(HistoryImpl, [{
    key: "_guardAgainstInactiveDocuments",
    value: function _guardAgainstInactiveDocuments() {
      if (!this._window) {
        throw DOMException.create(this._globalObject, ["History object is associated with a document that is not fully active.", "SecurityError"]);
      }
    }
  }, {
    key: "go",
    value: function go(delta) {
      this._guardAgainstInactiveDocuments();

      if (delta === 0) {
        // When the go(delta) method is invoked, if delta is zero, the user agent must act as
        // if the location.reload() method was called instead.
        this._actAsIfLocationReloadCalled();
      } else {
        // Otherwise, the user agent must traverse the history by a delta whose value is delta
        this._window._sessionHistory.traverseByDelta(delta);
      }
    }
  }, {
    key: "back",
    value: function back() {
      this.go(-1);
    }
  }, {
    key: "forward",
    value: function forward() {
      this.go(+1);
    }
  }, {
    key: "pushState",
    value: function pushState(data, title, url) {
      this._sharedPushAndReplaceState(data, title, url, "pushState");
    }
  }, {
    key: "replaceState",
    value: function replaceState(data, title, url) {
      this._sharedPushAndReplaceState(data, title, url, "replaceState");
    } // https://html.spec.whatwg.org/#dom-history-pushstate

  }, {
    key: "_sharedPushAndReplaceState",
    value: function _sharedPushAndReplaceState(data, title, url, methodName) {
      this._guardAgainstInactiveDocuments(); // TODO structured clone data


      var newURL;

      if (url !== null) {
        // Not implemented: use of entry settings object's API base URL. Instead we just use the document base URL. The
        // difference matters in the case of cross-frame calls.
        newURL = parseURLToResultingURLRecord(url, this._document);

        if (newURL === null) {
          throw DOMException.create(this._globalObject, ["Could not parse url argument \"".concat(url, "\" to ").concat(methodName, " against base URL ") + "\"".concat(documentBaseURLSerialized(this._document), "\"."), "SecurityError"]);
        }

        if (newURL.scheme !== this._document._URL.scheme || newURL.username !== this._document._URL.username || newURL.password !== this._document._URL.password || newURL.host !== this._document._URL.host || newURL.port !== this._document._URL.port || newURL.cannotBeABaseURL !== this._document._URL.cannotBeABaseURL) {
          throw DOMException.create(this._globalObject, ["".concat(methodName, " cannot update history to a URL which differs in components other than in ") + "path, query, or fragment.", "SecurityError"]);
        } // Not implemented: origin check (seems to only apply to documents with weird origins, e.g. sandboxed ones)

      } else {
        newURL = this._window._sessionHistory.currentEntry.url;
      }

      if (methodName === "pushState") {
        this._window._sessionHistory.removeAllEntriesAfterCurrentEntry();

        this._window._sessionHistory.clearHistoryTraversalTasks();

        var newEntry = {
          document: this._document,
          stateObject: data,
          title: title,
          url: newURL
        };

        this._window._sessionHistory.addEntryAfterCurrentEntry(newEntry);

        this._window._sessionHistory.updateCurrentEntry(newEntry);
      } else {
        var currentEntry = this._window._sessionHistory.currentEntry;
        currentEntry.stateObject = data;
        currentEntry.title = title;
        currentEntry.url = newURL;
      } // TODO: If the current entry in the session history represents a non-GET request
      // (e.g. it was the result of a POST submission) then update it to instead represent
      // a GET request.


      this._document._URL = newURL; // arguably it's a bit odd that the state and latestEntry do not belong to the SessionHistory
      // but the spec gives them to "History" and "Document" respecively.

      this._state = data; // TODO clone again!! O_o

      this._document._latestEntry = this._window._sessionHistory.currentEntry;
    }
  }, {
    key: "length",
    get: function get() {
      this._guardAgainstInactiveDocuments();

      return this._window._sessionHistory.length;
    }
  }, {
    key: "state",
    get: function get() {
      this._guardAgainstInactiveDocuments();

      return this._state;
    }
  }]);

  return HistoryImpl;
}();