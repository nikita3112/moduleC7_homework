"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var _require = require("./strings"),
    isValidFloatingPointNumber = _require.isValidFloatingPointNumber,
    isValidSimpleColor = _require.isValidSimpleColor,
    parseFloatingPointNumber = _require.parseFloatingPointNumber,
    stripLeadingAndTrailingASCIIWhitespace = _require.stripLeadingAndTrailingASCIIWhitespace,
    stripNewlines = _require.stripNewlines,
    splitOnCommas = _require.splitOnCommas;

var _require2 = require("./dates-and-times"),
    isValidDateString = _require2.isValidDateString,
    isValidMonthString = _require2.isValidMonthString,
    isValidTimeString = _require2.isValidTimeString,
    isValidWeekString = _require2.isValidWeekString,
    parseLocalDateAndTimeString = _require2.parseLocalDateAndTimeString,
    serializeNormalizedDateAndTime = _require2.serializeNormalizedDateAndTime;

var whatwgURL = require("whatwg-url");

var NodeList = require("../generated/NodeList");

var _require3 = require("./internal-constants"),
    domSymbolTree = _require3.domSymbolTree;

var _require4 = require("./traversal"),
    closest = _require4.closest,
    firstChildWithLocalName = _require4.firstChildWithLocalName;

var NODE_TYPE = require("../node-type");

var _require5 = require("./namespaces"),
    HTML_NS = _require5.HTML_NS; // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#concept-fe-disabled


exports.isDisabled = function (formControl) {
  if (formControl.localName === "button" || formControl.localName === "input" || formControl.localName === "select" || formControl.localName === "textarea") {
    if (formControl.hasAttributeNS(null, "disabled")) {
      return true;
    }
  }

  var e = formControl.parentNode;

  while (e) {
    if (e.localName === "fieldset" && e.hasAttributeNS(null, "disabled")) {
      var firstLegendElementChild = firstChildWithLocalName(e, "legend");

      if (!firstLegendElementChild || !firstLegendElementChild.contains(formControl)) {
        return true;
      }
    }

    e = e.parentNode;
  }

  return false;
}; // https://html.spec.whatwg.org/multipage/forms.html#category-listed


var listedElements = new Set(["button", "fieldset", "input", "object", "output", "select", "textarea"]);

exports.isListed = function (formControl) {
  return listedElements.has(formControl._localName) && formControl.namespaceURI === HTML_NS;
}; // https://html.spec.whatwg.org/multipage/forms.html#category-submit


var submittableElements = new Set(["button", "input", "object", "select", "textarea"]);

exports.isSubmittable = function (formControl) {
  return submittableElements.has(formControl._localName) && formControl.namespaceURI === HTML_NS;
}; // https://html.spec.whatwg.org/multipage/forms.html#concept-submit-button


var submitButtonInputTypes = new Set(["submit", "image"]);

exports.isSubmitButton = function (formControl) {
  return (formControl._localName === "input" && submitButtonInputTypes.has(formControl.type) || formControl._localName === "button" && formControl.type === "submit") && formControl.namespaceURI === HTML_NS;
}; // https://html.spec.whatwg.org/multipage/forms.html#concept-button


var buttonInputTypes = new Set([].concat(_toConsumableArray(submitButtonInputTypes), ["reset", "button"]));

exports.isButton = function (formControl) {
  return (formControl._localName === "input" && buttonInputTypes.has(formControl.type) || formControl._localName === "button") && formControl.namespaceURI === HTML_NS;
};

exports.normalizeToCRLF = function (string) {
  return string.replace(/\r([^\n])/g, "\r\n$1").replace(/\r$/, "\r\n").replace(/([^\r])\n/g, "$1\r\n").replace(/^\n/, "\r\n");
}; // https://html.spec.whatwg.org/multipage/dom.html#interactive-content-2


exports.isInteractiveContent = function (node) {
  if (node.nodeType !== NODE_TYPE.ELEMENT_NODE) {
    return false;
  }

  if (node.namespaceURI !== HTML_NS) {
    return false;
  }

  if (node.hasAttributeNS(null, "tabindex")) {
    return true;
  }

  switch (node.localName) {
    case "a":
      return node.hasAttributeNS(null, "href");

    case "audio":
    case "video":
      return node.hasAttributeNS(null, "controls");

    case "img":
    case "object":
      return node.hasAttributeNS(null, "usemap");

    case "input":
      return node.type !== "hidden";

    case "button":
    case "details":
    case "embed":
    case "iframe":
    case "label":
    case "select":
    case "textarea":
      return true;
  }

  return false;
}; // https://html.spec.whatwg.org/multipage/forms.html#category-label


exports.isLabelable = function (node) {
  if (node.nodeType !== NODE_TYPE.ELEMENT_NODE) {
    return false;
  }

  if (node.namespaceURI !== HTML_NS) {
    return false;
  }

  switch (node.localName) {
    case "button":
    case "meter":
    case "output":
    case "progress":
    case "select":
    case "textarea":
      return true;

    case "input":
      return node.type !== "hidden";
  }

  return false;
};

exports.getLabelsForLabelable = function (labelable) {
  if (!exports.isLabelable(labelable)) {
    return null;
  }

  if (!labelable._labels) {
    var root = labelable.getRootNode({});
    labelable._labels = NodeList.create(root._globalObject, [], {
      element: root,
      query: function query() {
        var nodes = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = domSymbolTree.treeIterator(root)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var descendant = _step.value;

            if (descendant.control === labelable) {
              nodes.push(descendant);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return nodes;
      }
    });
  }

  return labelable._labels;
}; // https://html.spec.whatwg.org/multipage/forms.html#valid-e-mail-address


exports.isValidEmailAddress = function (emailAddress) {
  var multiple = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var emailAddressRegExp = new RegExp("^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9]" + "(?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}" + "[a-zA-Z0-9])?)*$"); // A valid e-mail address list is a set of comma-separated tokens, where each token is itself
  // a valid e - mail address.To obtain the list of tokens from a valid e - mail address list,
  // an implementation must split the string on commas.

  if (multiple) {
    return splitOnCommas(emailAddress).every(function (value) {
      return emailAddressRegExp.test(value);
    });
  }

  return emailAddressRegExp.test(emailAddress);
};

exports.isValidAbsoluteURL = function (url) {
  return whatwgURL.parseURL(url) !== null;
};

exports.sanitizeValueByType = function (input, val) {
  switch (input.type.toLowerCase()) {
    case "password":
    case "search":
    case "tel":
    case "text":
      val = stripNewlines(val);
      break;

    case "color":
      // https://html.spec.whatwg.org/multipage/forms.html#color-state-(type=color):value-sanitization-algorithm
      val = isValidSimpleColor(val) ? val.toLowerCase() : "#000000";
      break;

    case "date":
      // https://html.spec.whatwg.org/multipage/input.html#date-state-(type=date):value-sanitization-algorithm
      if (!isValidDateString(val)) {
        val = "";
      }

      break;

    case "datetime-local":
      {
        // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type=datetime-local):value-sanitization-algorithm
        var dateAndTime = parseLocalDateAndTimeString(val);
        val = dateAndTime !== null ? serializeNormalizedDateAndTime(dateAndTime) : "";
        break;
      }

    case "email":
      // https://html.spec.whatwg.org/multipage/forms.html#e-mail-state-(type=email):value-sanitization-algorithm
      // https://html.spec.whatwg.org/multipage/forms.html#e-mail-state-(type=email):value-sanitization-algorithm-2
      if (input.hasAttributeNS(null, "multiple")) {
        val = val.split(",").map(function (token) {
          return stripLeadingAndTrailingASCIIWhitespace(token);
        }).join(",");
      } else {
        val = stripNewlines(val);
        val = stripLeadingAndTrailingASCIIWhitespace(val);
      }

      break;

    case "month":
      // https://html.spec.whatwg.org/multipage/input.html#month-state-(type=month):value-sanitization-algorithm
      if (!isValidMonthString(val)) {
        val = "";
      }

      break;

    case "number":
      // https://html.spec.whatwg.org/multipage/input.html#number-state-(type=number):value-sanitization-algorithm
      // TODO: using parseFloatingPointNumber in addition to isValidFloatingPointNumber to pass number.html WPT.
      // Possible spec bug.
      if (!isValidFloatingPointNumber(val) || parseFloatingPointNumber(val) === null) {
        val = "";
      }

      break;

    case "range":
      // https://html.spec.whatwg.org/multipage/input.html#range-state-(type=range):value-sanitization-algorithm
      // TODO: using parseFloatingPointNumber in addition to isValidFloatingPointNumber to pass number.html WPT.
      // Possible spec bug.
      if (!isValidFloatingPointNumber(val) || parseFloatingPointNumber(val) === null) {
        var minimum = input._minimum;
        var maximum = input._maximum;
        var defaultValue = maximum < minimum ? minimum : (minimum + maximum) / 2;
        val = "".concat(defaultValue);
      } else if (val < input._minimum) {
        val = "".concat(input._minimum);
      } else if (val > input._maximum) {
        val = "".concat(input._maximum);
      }

      break;

    case "time":
      // https://html.spec.whatwg.org/multipage/input.html#time-state-(type=time):value-sanitization-algorithm
      if (!isValidTimeString(val)) {
        val = "";
      }

      break;

    case "url":
      // https://html.spec.whatwg.org/multipage/forms.html#url-state-(type=url):value-sanitization-algorithm
      val = stripNewlines(val);
      val = stripLeadingAndTrailingASCIIWhitespace(val);
      break;

    case "week":
      // https://html.spec.whatwg.org/multipage/input.html#week-state-(type=week):value-sanitization-algorithm
      if (!isValidWeekString(val)) {
        val = "";
      }

  }

  return val;
}; // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#form-owner
// TODO: The spec describes an imperative process for assigning/resetting an element's form
// owner based on activities involving form-associated elements. This simpler implementation
// instead calculates the current form owner only when the property is accessed. This is not
// sufficient to pass all the web platform tests, but is good enough for most purposes. We
// should eventually update it to use the correct version, though. See
// https://github.com/whatwg/html/issues/4050 for some discussion.


exports.formOwner = function (formControl) {
  var formAttr = formControl.getAttributeNS(null, "form");

  if (formAttr === "") {
    return null;
  }

  if (formAttr === null) {
    return closest(formControl, "form");
  }

  var root = formControl.getRootNode({});
  var firstElementWithId;
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = domSymbolTree.treeIterator(root)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var descendant = _step2.value;

      if (descendant.nodeType === NODE_TYPE.ELEMENT_NODE && descendant.getAttributeNS(null, "id") === formAttr) {
        firstElementWithId = descendant;
        break;
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  if (firstElementWithId && firstElementWithId.namespaceURI === HTML_NS && firstElementWithId.localName === "form") {
    return firstElementWithId;
  }

  return null;
};