"use strict"; // https://infra.spec.whatwg.org/#sets
//
// Only use this class if a Set cannot be used, e.g. when "replace" operation is needed, since there's no way to replace
// an element while keep the relative order using a Set, only remove and then add something at the end.

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

module.exports =
/*#__PURE__*/
function () {
  function OrderedSet() {
    _classCallCheck(this, OrderedSet);

    this._items = [];
  }

  _createClass(OrderedSet, [{
    key: "append",
    value: function append(item) {
      if (!this.contains(item)) {
        this._items.push(item);
      }
    }
  }, {
    key: "prepend",
    value: function prepend(item) {
      if (!this.contains(item)) {
        this._items.unshift(item);
      }
    }
  }, {
    key: "replace",
    value: function replace(item, replacement) {
      var seen = false;

      for (var i = 0; i < this._items.length;) {
        var isInstance = this._items[i] === item || this._items[i] === replacement;

        if (seen && isInstance) {
          this._items.splice(i, 1);
        } else {
          if (isInstance) {
            this._items[i] = replacement;
            seen = true;
          }

          i++;
        }
      }
    }
  }, {
    key: "remove",
    value: function remove() {
      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
        items[_key] = arguments[_key];
      }

      this.removePredicate(function (item) {
        return items.includes(item);
      });
    }
  }, {
    key: "removePredicate",
    value: function removePredicate(predicate) {
      for (var i = 0; i < this._items.length;) {
        if (predicate(this._items[i])) {
          this._items.splice(i, 1);
        } else {
          i++;
        }
      }
    }
  }, {
    key: "empty",
    value: function empty() {
      this._items.length = 0;
    }
  }, {
    key: "contains",
    value: function contains(item) {
      return this._items.includes(item);
    }
  }, {
    key: "isEmpty",
    value: function isEmpty() {
      return this._items.length === 0;
    } // Useful for other parts of jsdom

  }, {
    key: Symbol.iterator,
    value: function value() {
      return this._items[Symbol.iterator]();
    }
  }, {
    key: "keys",
    value: function keys() {
      return this._items.keys();
    }
  }, {
    key: "get",
    value: function get(index) {
      return this._items[index];
    }
  }, {
    key: "some",
    value: function some(func) {
      return this._items.some(func);
    } // https://dom.spec.whatwg.org/#concept-ordered-set-parser

  }, {
    key: "serialize",
    // https://dom.spec.whatwg.org/#concept-ordered-set-serializer
    value: function serialize() {
      return this._items.join(" ");
    }
  }, {
    key: "size",
    get: function get() {
      return this._items.length;
    }
  }], [{
    key: "parse",
    value: function parse(input) {
      var tokens = new OrderedSet();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = input.split(/[\t\n\f\r ]+/)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var token = _step.value;

          if (token) {
            tokens.append(token);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return tokens;
    }
  }]);

  return OrderedSet;
}();