"use strict";

var _marked =
/*#__PURE__*/
regeneratorRuntime.mark(shadowIncludingInclusiveDescendantsIterator),
    _marked2 =
/*#__PURE__*/
regeneratorRuntime.mark(shadowIncludingDescendantsIterator);

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var NODE_TYPE = require("../node-type");

var _require = require("./node"),
    nodeRoot = _require.nodeRoot;

var _require2 = require("./namespaces"),
    HTML_NS = _require2.HTML_NS;

var _require3 = require("./internal-constants"),
    domSymbolTree = _require3.domSymbolTree;

var _require4 = require("./mutation-observers"),
    signalSlotList = _require4.signalSlotList,
    queueMutationObserverMicrotask = _require4.queueMutationObserverMicrotask; // Valid host element for ShadowRoot.
// Defined in: https://dom.spec.whatwg.org/#dom-element-attachshadow


var VALID_HOST_ELEMENT_NAME = new Set(["article", "aside", "blockquote", "body", "div", "footer", "h1", "h2", "h3", "h4", "h5", "h6", "header", "main", "nav", "p", "section", "span"]);

function isValidHostElementName(name) {
  return VALID_HOST_ELEMENT_NAME.has(name);
} // Use an approximation by checking the presence of nodeType instead of instead of using the isImpl from
// "../generated/Node" to avoid introduction of circular dependencies.


function isNode(nodeImpl) {
  return Boolean(nodeImpl && "nodeType" in nodeImpl);
} // Use an approximation by checking the value of nodeType and presence of nodeType host instead of instead
// of using the isImpl from "../generated/ShadowRoot" to avoid introduction of circular dependencies.


function isShadowRoot(nodeImpl) {
  return Boolean(nodeImpl && nodeImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE && "host" in nodeImpl);
} // https://dom.spec.whatwg.org/#concept-slotable


function isSlotable(nodeImpl) {
  return nodeImpl && (nodeImpl.nodeType === NODE_TYPE.ELEMENT_NODE || nodeImpl.nodeType === NODE_TYPE.TEXT_NODE);
}

function isSlot(nodeImpl) {
  return nodeImpl && nodeImpl.localName === "slot" && nodeImpl._namespaceURI === HTML_NS;
} // https://dom.spec.whatwg.org/#concept-shadow-including-inclusive-ancestor


function isShadowInclusiveAncestor(ancestor, node) {
  while (isNode(node)) {
    if (node === ancestor) {
      return true;
    }

    if (isShadowRoot(node)) {
      node = node.host;
    } else {
      node = domSymbolTree.parent(node);
    }
  }

  return false;
} // https://dom.spec.whatwg.org/#retarget


function retarget(a, b) {
  while (true) {
    if (!isNode(a)) {
      return a;
    }

    var aRoot = nodeRoot(a);

    if (!isShadowRoot(aRoot) || isNode(b) && isShadowInclusiveAncestor(aRoot, b)) {
      return a;
    }

    a = nodeRoot(a).host;
  }
} // https://dom.spec.whatwg.org/#get-the-parent


function getEventTargetParent(eventTarget, event) {
  // _getTheParent will be missing for Window, since it doesn't have an impl class and we don't want to pollute the
  // user-visible global scope with a _getTheParent value. TODO: remove this entire function and use _getTheParent
  // directly, once Window gets split into impl/wrapper.
  return eventTarget._getTheParent ? eventTarget._getTheParent(event) : null;
} // https://dom.spec.whatwg.org/#concept-shadow-including-root


function shadowIncludingRoot(node) {
  var root = nodeRoot(node);
  return isShadowRoot(root) ? shadowIncludingRoot(root.host) : root;
} // https://dom.spec.whatwg.org/#assign-a-slot


function assignSlot(slotable) {
  var slot = findSlot(slotable);

  if (slot) {
    assignSlotable(slot);
  }
} // https://dom.spec.whatwg.org/#assign-slotables


function assignSlotable(slot) {
  var slotables = findSlotable(slot);
  var shouldFireSlotChange = false;

  if (slotables.length !== slot._assignedNodes.length) {
    shouldFireSlotChange = true;
  } else {
    for (var i = 0; i < slotables.length; i++) {
      if (slotables[i] !== slot._assignedNodes[i]) {
        shouldFireSlotChange = true;
        break;
      }
    }
  }

  if (shouldFireSlotChange) {
    signalSlotChange(slot);
  }

  slot._assignedNodes = slotables;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = slotables[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var slotable = _step.value;
      slotable._assignedSlot = slot;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
} // https://dom.spec.whatwg.org/#assign-slotables-for-a-tree


function assignSlotableForTree(root) {
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = domSymbolTree.treeIterator(root)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var slot = _step2.value;

      if (isSlot(slot)) {
        assignSlotable(slot);
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
} // https://dom.spec.whatwg.org/#find-slotables


function findSlotable(slot) {
  var result = [];
  var root = nodeRoot(slot);

  if (!isShadowRoot(root)) {
    return result;
  }

  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = domSymbolTree.treeIterator(root.host)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var slotable = _step3.value;
      var foundSlot = findSlot(slotable);

      if (foundSlot === slot) {
        result.push(slotable);
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return result;
} // https://dom.spec.whatwg.org/#find-flattened-slotables


function findFlattenedSlotables(slot) {
  var result = [];
  var root = nodeRoot(slot);

  if (!isShadowRoot(root)) {
    return result;
  }

  var slotables = findSlotable(slot);

  if (slotables.length === 0) {
    var _iteratorNormalCompletion4 = true;
    var _didIteratorError4 = false;
    var _iteratorError4 = undefined;

    try {
      for (var _iterator4 = domSymbolTree.childrenIterator(slot)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
        var child = _step4.value;

        if (isSlotable(child)) {
          slotables.push(child);
        }
      }
    } catch (err) {
      _didIteratorError4 = true;
      _iteratorError4 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
          _iterator4["return"]();
        }
      } finally {
        if (_didIteratorError4) {
          throw _iteratorError4;
        }
      }
    }
  }

  var _iteratorNormalCompletion5 = true;
  var _didIteratorError5 = false;
  var _iteratorError5 = undefined;

  try {
    for (var _iterator5 = slotables[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
      var node = _step5.value;

      if (isSlot(node) && isShadowRoot(nodeRoot(node))) {
        var temporaryResult = findFlattenedSlotables(node);
        result.push.apply(result, _toConsumableArray(temporaryResult));
      } else {
        result.push(node);
      }
    }
  } catch (err) {
    _didIteratorError5 = true;
    _iteratorError5 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
        _iterator5["return"]();
      }
    } finally {
      if (_didIteratorError5) {
        throw _iteratorError5;
      }
    }
  }

  return result;
} // https://dom.spec.whatwg.org/#find-a-slot


function findSlot(slotable, openFlag) {
  var parent = slotable.parentNode;

  if (!parent) {
    return null;
  }

  var shadow = parent._shadowRoot;

  if (!shadow || openFlag && shadow.mode !== "open") {
    return null;
  }

  var _iteratorNormalCompletion6 = true;
  var _didIteratorError6 = false;
  var _iteratorError6 = undefined;

  try {
    for (var _iterator6 = domSymbolTree.treeIterator(shadow)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
      var child = _step6.value;

      if (isSlot(child) && child.name === slotable._slotableName) {
        return child;
      }
    }
  } catch (err) {
    _didIteratorError6 = true;
    _iteratorError6 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
        _iterator6["return"]();
      }
    } finally {
      if (_didIteratorError6) {
        throw _iteratorError6;
      }
    }
  }

  return null;
} // https://dom.spec.whatwg.org/#signal-a-slot-change


function signalSlotChange(slot) {
  if (!signalSlotList.some(function (entry) {
    return entry === slot;
  })) {
    signalSlotList.push(slot);
  }

  queueMutationObserverMicrotask();
} // https://dom.spec.whatwg.org/#concept-shadow-including-descendant


function shadowIncludingInclusiveDescendantsIterator(node) {
  var _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, child;

  return regeneratorRuntime.wrap(function shadowIncludingInclusiveDescendantsIterator$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return node;

        case 2:
          if (!node._shadowRoot) {
            _context.next = 4;
            break;
          }

          return _context.delegateYield(shadowIncludingInclusiveDescendantsIterator(node._shadowRoot), "t0", 4);

        case 4:
          _iteratorNormalCompletion7 = true;
          _didIteratorError7 = false;
          _iteratorError7 = undefined;
          _context.prev = 7;
          _iterator7 = domSymbolTree.childrenIterator(node)[Symbol.iterator]();

        case 9:
          if (_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done) {
            _context.next = 15;
            break;
          }

          child = _step7.value;
          return _context.delegateYield(shadowIncludingInclusiveDescendantsIterator(child), "t1", 12);

        case 12:
          _iteratorNormalCompletion7 = true;
          _context.next = 9;
          break;

        case 15:
          _context.next = 21;
          break;

        case 17:
          _context.prev = 17;
          _context.t2 = _context["catch"](7);
          _didIteratorError7 = true;
          _iteratorError7 = _context.t2;

        case 21:
          _context.prev = 21;
          _context.prev = 22;

          if (!_iteratorNormalCompletion7 && _iterator7["return"] != null) {
            _iterator7["return"]();
          }

        case 24:
          _context.prev = 24;

          if (!_didIteratorError7) {
            _context.next = 27;
            break;
          }

          throw _iteratorError7;

        case 27:
          return _context.finish(24);

        case 28:
          return _context.finish(21);

        case 29:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, null, [[7, 17, 21, 29], [22,, 24, 28]]);
} // https://dom.spec.whatwg.org/#concept-shadow-including-descendant


function shadowIncludingDescendantsIterator(node) {
  var _iteratorNormalCompletion8, _didIteratorError8, _iteratorError8, _iterator8, _step8, child;

  return regeneratorRuntime.wrap(function shadowIncludingDescendantsIterator$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          if (!node._shadowRoot) {
            _context2.next = 2;
            break;
          }

          return _context2.delegateYield(shadowIncludingInclusiveDescendantsIterator(node._shadowRoot), "t0", 2);

        case 2:
          _iteratorNormalCompletion8 = true;
          _didIteratorError8 = false;
          _iteratorError8 = undefined;
          _context2.prev = 5;
          _iterator8 = domSymbolTree.childrenIterator(node)[Symbol.iterator]();

        case 7:
          if (_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done) {
            _context2.next = 13;
            break;
          }

          child = _step8.value;
          return _context2.delegateYield(shadowIncludingInclusiveDescendantsIterator(child), "t1", 10);

        case 10:
          _iteratorNormalCompletion8 = true;
          _context2.next = 7;
          break;

        case 13:
          _context2.next = 19;
          break;

        case 15:
          _context2.prev = 15;
          _context2.t2 = _context2["catch"](5);
          _didIteratorError8 = true;
          _iteratorError8 = _context2.t2;

        case 19:
          _context2.prev = 19;
          _context2.prev = 20;

          if (!_iteratorNormalCompletion8 && _iterator8["return"] != null) {
            _iterator8["return"]();
          }

        case 22:
          _context2.prev = 22;

          if (!_didIteratorError8) {
            _context2.next = 25;
            break;
          }

          throw _iteratorError8;

        case 25:
          return _context2.finish(22);

        case 26:
          return _context2.finish(19);

        case 27:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2, null, [[5, 15, 19, 27], [20,, 22, 26]]);
}

module.exports = {
  isValidHostElementName: isValidHostElementName,
  isNode: isNode,
  isSlotable: isSlotable,
  isSlot: isSlot,
  isShadowRoot: isShadowRoot,
  isShadowInclusiveAncestor: isShadowInclusiveAncestor,
  retarget: retarget,
  getEventTargetParent: getEventTargetParent,
  shadowIncludingRoot: shadowIncludingRoot,
  assignSlot: assignSlot,
  assignSlotable: assignSlotable,
  assignSlotableForTree: assignSlotableForTree,
  findSlot: findSlot,
  findFlattenedSlotables: findFlattenedSlotables,
  signalSlotChange: signalSlotChange,
  shadowIncludingInclusiveDescendantsIterator: shadowIncludingInclusiveDescendantsIterator,
  shadowIncludingDescendantsIterator: shadowIncludingDescendantsIterator
};