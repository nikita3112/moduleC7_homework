"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var conversions = require("webidl-conversions");

var idlUtils = require("../generated/utils");

var ErrorEvent = require("../generated/ErrorEvent");

var reportException = require("./runtime-script-errors");

exports.appendHandler = function appendHandler(el, eventName) {
  // tryImplForWrapper() is currently required due to use in Window.js
  idlUtils.tryImplForWrapper(el).addEventListener(eventName, function (event) {
    // https://html.spec.whatwg.org/#the-event-handler-processing-algorithm
    var callback = el["on" + eventName];

    if (callback === null) {
      return;
    }

    var specialError = ErrorEvent.isImpl(event) && event.type === "error" && event.currentTarget.constructor.name === "Window";
    var returnValue = null;
    var thisValue = idlUtils.tryWrapperForImpl(event.currentTarget); // https://heycam.github.io/webidl/#es-invoking-callback-functions

    if (typeof callback === "function") {
      if (specialError) {
        returnValue = callback.call(thisValue, event.message, event.filename, event.lineno, event.colno, event.error);
      } else {
        // This will no longer be necessary once EventHandler and Window are implemented in IDL:
        var eventWrapper = idlUtils.wrapperForImpl(event);
        returnValue = callback.call(thisValue, eventWrapper);
      }
    }

    if (event.type === "beforeunload") {
      // TODO: we don't implement BeforeUnloadEvent so we can't brand-check here
      // Perform conversion which in the spec is done by the event handler return type being DOMString?
      returnValue = returnValue === undefined || returnValue === null ? null : conversions.DOMString(returnValue);

      if (returnValue !== null) {
        event._canceledFlag = true;

        if (event.returnValue === "") {
          event.returnValue = returnValue;
        }
      }
    } else if (specialError) {
      if (returnValue === true) {
        event._canceledFlag = true;
      }
    } else if (returnValue === false) {
      event._canceledFlag = true;
    }
  });
}; // "Simple" in this case means "no content attributes involved"


exports.setupForSimpleEventAccessors = function (prototype, events) {
  prototype._getEventHandlerFor = function (event) {
    return this._eventHandlers ? this._eventHandlers[event] : undefined;
  };

  prototype._setEventHandlerFor = function (event, handler) {
    if (!this._registeredHandlers) {
      this._registeredHandlers = new Set();
      this._eventHandlers = Object.create(null);
    }

    if (!this._registeredHandlers.has(event) && handler !== null) {
      this._registeredHandlers.add(event);

      exports.appendHandler(this, event);
    }

    this._eventHandlers[event] = handler;
  };

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = events[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var event = _step.value;
      exports.createEventAccessor(prototype, event);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}; // https://html.spec.whatwg.org/#event-handler-idl-attributes


exports.createEventAccessor = function createEventAccessor(obj, event) {
  Object.defineProperty(obj, "on" + event, {
    configurable: true,
    enumerable: true,
    get: function get() {
      // https://html.spec.whatwg.org/#getting-the-current-value-of-the-event-handler
      var value = this._getEventHandlerFor(event);

      if (!value) {
        return null;
      }

      if (value.body !== undefined) {
        var element;
        var document;

        if (this.constructor.name === "Window") {
          element = null;
          document = idlUtils.implForWrapper(this.document);
        } else {
          element = this;
          document = element.ownerDocument;
        }

        var body = value.body;
        var formOwner = element !== null && element.form ? element.form : null;
        var window = this.constructor.name === "Window" && this._document ? this : document.defaultView;

        try {
          // eslint-disable-next-line no-new-func
          Function(body); // properly error out on syntax errors
          // Note: this won't execute body; that would require `Function(body)()`.
        } catch (e) {
          if (window) {
            reportException(window, e);
          }

          this._setEventHandlerFor(event, null);

          return null;
        } // Note: the with (window) { } is not necessary in Node, but is necessary in a browserified environment.


        var fn;
        var createFunction = document.defaultView.Function;

        if (event === "error" && element === null) {
          var wrapperBody = document ? body + "\n//# sourceURL=".concat(document.URL) : body; // eslint-disable-next-line no-new-func

          fn = createFunction("window", "with (window) { return function onerror(event, source, lineno, colno, error) {\n  ".concat(wrapperBody, "\n}; }"))(window);
        } else {
          var argNames = [];
          var args = [];
          argNames.push("window");
          args.push(window);

          if (element !== null) {
            argNames.push("document");
            args.push(idlUtils.wrapperForImpl(document));
          }

          if (formOwner !== null) {
            argNames.push("formOwner");
            args.push(idlUtils.wrapperForImpl(formOwner));
          }

          if (element !== null) {
            argNames.push("element");
            args.push(idlUtils.wrapperForImpl(element));
          }

          var _wrapperBody = "\nreturn function on".concat(event, "(event) {\n  ").concat(body, "\n};");

          for (var i = argNames.length - 1; i >= 0; --i) {
            _wrapperBody = "with (".concat(argNames[i], ") { ").concat(_wrapperBody, " }");
          }

          if (document) {
            _wrapperBody += "\n//# sourceURL=".concat(document.URL);
          }

          argNames.push(_wrapperBody);
          fn = createFunction.apply(void 0, argNames).apply(void 0, args);
        }

        this._setEventHandlerFor(event, fn);
      }

      return this._getEventHandlerFor(event);
    },
    set: function set(val) {
      val = eventHandlerArgCoercion(val);

      this._setEventHandlerFor(event, val);
    }
  });
};

function typeIsObject(v) {
  return _typeof(v) === "object" && v !== null || typeof v === "function";
} // Implements:
//     [TreatNonObjectAsNull]
//     callback EventHandlerNonNull = any (Event event);
//     typedef EventHandlerNonNull? EventHandler;
// Also implements the part of https://heycam.github.io/webidl/#es-invoking-callback-functions which treats
// non-callable callback functions as callback functions that return undefined.
// TODO: replace with webidl2js typechecking when it has sufficient callback support


function eventHandlerArgCoercion(val) {
  if (!typeIsObject(val)) {
    return null;
  }

  return val;
}