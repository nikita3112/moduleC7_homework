"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var _require = require("./namespaces"),
    HTML_NS = _require.HTML_NS;

var _require2 = require("./create-element"),
    createElement = _require2.createElement,
    getValidTagNames = _require2.getValidTagNames;

var _require3 = require("../generated/utils"),
    implForWrapper = _require3.implForWrapper,
    wrapperForImpl = _require3.wrapperForImpl; // https://html.spec.whatwg.org/multipage/custom-elements.html#concept-already-constructed-marker


var ALREADY_CONSTRUCTED_MARKER = Symbol("already-constructed-marker"); // https://html.spec.whatwg.org/multipage/dom.html#htmlconstructor

function HTMLConstructor(globalObject, constructorName, newTarget) {
  var registry = implForWrapper(globalObject.customElements);

  if (newTarget === HTMLConstructor) {
    throw new TypeError("Invalid constructor");
  }

  var definition = registry._customElementDefinitions.find(function (entry) {
    return entry.ctor === newTarget;
  });

  if (definition === undefined) {
    throw new TypeError("Invalid constructor, the constructor is not part of the custom element registry");
  }

  var isValue = null;

  if (definition.localName === definition.name) {
    if (constructorName !== "HTMLElement") {
      throw new TypeError("Invalid constructor, autonomous custom element should extend from HTMLElement");
    }
  } else {
    var validLocalNames = getValidTagNames(HTML_NS, constructorName);

    if (!validLocalNames.includes(definition.localName)) {
      throw new TypeError("".concat(definition.localName, " is not valid local name for ").concat(constructorName));
    }

    isValue = definition.name;
  }

  var prototype = newTarget.prototype;

  if (prototype === null || _typeof(prototype) !== "object") {
    // The following line deviates from the specification. The HTMLElement prototype should be retrieved from the realm
    // associated with the "new.target". Because it is impossible to get such information in jsdom, we fallback to the
    // HTMLElement prototype associated with the current object.
    prototype = globalObject.HTMLElement.prototype;
  }

  if (definition.constructionStack.length === 0) {
    var documentImpl = implForWrapper(globalObject.document);

    var _elementImpl = createElement(documentImpl, definition.localName, HTML_NS);

    var _element = wrapperForImpl(_elementImpl);

    Object.setPrototypeOf(_element, prototype);
    _elementImpl._ceState = "custom";
    _elementImpl._ceDefinition = definition;
    _elementImpl._isValue = isValue;
    return _element;
  }

  var elementImpl = definition.constructionStack[definition.constructionStack.length - 1];
  var element = wrapperForImpl(elementImpl);

  if (elementImpl === ALREADY_CONSTRUCTED_MARKER) {
    throw new TypeError("This instance is already constructed");
  }

  Object.setPrototypeOf(element, prototype);
  definition.constructionStack[definition.constructionStack.length - 1] = ALREADY_CONSTRUCTED_MARKER;
  return element;
}

module.exports = {
  HTMLConstructor: HTMLConstructor
};