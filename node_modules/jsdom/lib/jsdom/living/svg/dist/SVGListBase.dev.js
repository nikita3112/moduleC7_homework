"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DOMException = require("domexception/webidl2js-wrapper");

var idlUtils = require("../generated/utils");

var _require = require("../helpers/svg/basic-types"),
    attach = _require.attach,
    detach = _require.detach; // https://svgwg.org/svg2-draft/types.html#ListInterfaces
// Child classes must implement _reserialize()


var List =
/*#__PURE__*/
function () {
  function List() {
    _classCallCheck(this, List);
  }

  _createClass(List, [{
    key: "_initList",
    value: function _initList(_ref) {
      var element = _ref.element,
          attribute = _ref.attribute,
          _ref$readOnly = _ref.readOnly,
          readOnly = _ref$readOnly === void 0 ? false : _ref$readOnly;
      this._element = element;
      this._attribute = attribute;
      this._attributeRegistryEntry = element.constructor.attributeRegistry.get(attribute);
      this._readOnly = readOnly;
      this._list = [];
      this._version = -1;
    }
  }, {
    key: "_synchronize",
    value: function _synchronize() {
      if (!this._needsResync) {
        return;
      }

      var value = [];

      if (this._element.hasAttributeNS(null, this._attribute)) {
        value = this._attributeRegistryEntry.getValue(this._element.getAttributeNS(null, this._attribute));
      }

      if (value.length === 0 && this._attributeRegistryEntry.initialValue !== undefined) {
        value = this._attributeRegistryEntry.getValue(this._attributeRegistryEntry.initialValue);
      } // TODO: support non-DOMString lists.


      this._list = value;
      this._version = this._element._version;
    }
  }, {
    key: "_reserialize",
    value: function _reserialize() {
      var elements = this._list;

      this._element.setAttributeNS(null, this._attribute, this._attributeRegistryEntry.serialize(elements)); // Prevent ping-ponging back and forth between _reserialize() and _synchronize().


      this._version = this._element._version;
    }
  }, {
    key: idlUtils.supportsPropertyIndex,
    value: function value(index) {
      this._synchronize();

      return index >= 0 && index < this.length;
    }
  }, {
    key: "clear",
    value: function clear() {
      this._synchronize();

      if (this._readOnly) {
        throw DOMException.create(this._globalObject, ["Attempting to modify a read-only list", "NoModificationAllowedError"]);
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._list[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var item = _step.value;
          detach(item);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this._list.length = 0;

      this._reserialize();
    }
  }, {
    key: "initialize",
    value: function initialize(newItem) {
      this._synchronize();

      if (this._readOnly) {
        throw DOMException.create(this._globalObject, ["Attempting to modify a read-only list", "NoModificationAllowedError"]);
      }

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = this._list[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var item = _step2.value;
          detach(item);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      this._list.length = 0; // TODO: clone non-DOMString list elements.

      attach(newItem, this);

      this._list.push(newItem);

      this._reserialize();
    }
  }, {
    key: "getItem",
    value: function getItem(index) {
      this._synchronize();

      if (index >= this._list.length) {
        throw DOMException.create(this._globalObject, ["The index provided (".concat(index, ") is greater than or equal to the maximum bound (").concat(this._list.length, ")."), "IndexSizeError"]);
      }

      return this._list[index];
    }
  }, {
    key: "insertItemBefore",
    value: function insertItemBefore(newItem, index) {
      this._synchronize();

      if (this._readOnly) {
        throw DOMException.create(this._globalObject, ["Attempting to modify a read-only list", "NoModificationAllowedError"]);
      } // TODO: clone non-DOMString list elements.


      if (index > this._list.length) {
        index = this._list.length;
      }

      this._list.splice(index, 0, newItem);

      attach(newItem, this);

      this._reserialize();

      return newItem;
    }
  }, {
    key: "replaceItem",
    value: function replaceItem(newItem, index) {
      this._synchronize();

      if (this._readOnly) {
        throw DOMException.create(this._globalObject, ["Attempting to modify a read-only list", "NoModificationAllowedError"]);
      }

      if (index >= this._list.length) {
        throw DOMException.create(this._globalObject, ["The index provided (".concat(index, ") is greater than or equal to the maximum bound (").concat(this._list.length, ")."), "IndexSizeError"]);
      } // TODO: clone non-DOMString list elements.


      detach(this._list[index]);
      this._list[index] = newItem;
      attach(newItem, this);

      this._reserialize();

      return newItem;
    }
  }, {
    key: "removeItem",
    value: function removeItem(index) {
      this._synchronize();

      if (this._readOnly) {
        throw DOMException.create(this._globalObject, ["Attempting to modify a read-only list", "NoModificationAllowedError"]);
      }

      if (index >= this._list.length) {
        throw DOMException.create(this._globalObject, ["The index provided (".concat(index, ") is greater than or equal to the maximum bound (").concat(this._list.length, ")."), "IndexSizeError"]);
      }

      var item = this._list[index];
      detach(item);

      this._list.splice(index, 1);

      this._reserialize();

      return item;
    }
  }, {
    key: "appendItem",
    value: function appendItem(newItem) {
      this._synchronize(); // TODO: clone non-DOMString list elements.


      this._list.push(newItem);

      attach(newItem, this);

      this._reserialize();

      return newItem;
    }
  }, {
    key: idlUtils.indexedSetNew,
    value: function value(index, _value) {
      // Note: this will always throw a IndexSizeError.
      this.replaceItem(_value, index);
    }
  }, {
    key: idlUtils.indexedSetExisting,
    value: function value(index, _value2) {
      this.replaceItem(_value2, index);
    }
  }, {
    key: "_needsResync",
    get: function get() {
      return this._version < this._element._version;
    }
  }, {
    key: idlUtils.supportedPropertyIndices,
    get: function get() {
      this._synchronize();

      return this._list.keys();
    }
  }, {
    key: "length",
    get: function get() {
      this._synchronize();

      return this._list.length;
    }
  }, {
    key: "numberOfItems",
    get: function get() {
      this._synchronize();

      return this._list.length;
    }
  }]);

  return List;
}();

module.exports = List;