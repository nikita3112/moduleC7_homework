"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var HTMLElementImpl = require("./HTMLElement-impl").implementation;

var DefaultConstraintValidationImpl = require("../constraint-validation/DefaultConstraintValidation-impl").implementation;

var ValidityState = require("../generated/ValidityState");

var _require = require("../../utils"),
    mixin = _require.mixin;

var DOMException = require("domexception/webidl2js-wrapper");

var _require2 = require("../helpers/internal-constants"),
    cloningSteps = _require2.cloningSteps;

var _require3 = require("../helpers/form-controls"),
    isDisabled = _require3.isDisabled,
    normalizeToCRLF = _require3.normalizeToCRLF,
    getLabelsForLabelable = _require3.getLabelsForLabelable,
    formOwner = _require3.formOwner;

var _require4 = require("../helpers/text"),
    childTextContent = _require4.childTextContent;

var _require5 = require("../helpers/events"),
    fireAnEvent = _require5.fireAnEvent;

var HTMLTextAreaElementImpl =
/*#__PURE__*/
function (_HTMLElementImpl) {
  _inherits(HTMLTextAreaElementImpl, _HTMLElementImpl);

  function HTMLTextAreaElementImpl(globalObject, args, privateData) {
    var _this;

    _classCallCheck(this, HTMLTextAreaElementImpl);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(HTMLTextAreaElementImpl).call(this, globalObject, args, privateData));
    _this._selectionStart = _this._selectionEnd = 0;
    _this._selectionDirection = "none";
    _this._rawValue = "";
    _this._dirtyValue = false;
    _this._customValidityErrorMessage = "";
    _this._labels = null;
    return _this;
  }

  _createClass(HTMLTextAreaElementImpl, [{
    key: "_formReset",
    value: function _formReset() {
      this._rawValue = childTextContent(this);
      this._dirtyValue = false;
    }
  }, {
    key: "_getAPIValue",
    value: function _getAPIValue() {
      return this._rawValue.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    } // https://html.spec.whatwg.org/multipage/form-elements.html#textarea-wrapping-transformation

  }, {
    key: "_getValue",
    value: function _getValue() {
      // Hard-wrapping omitted, for now.
      return normalizeToCRLF(this._rawValue);
    }
  }, {
    key: "_childTextContentChangeSteps",
    value: function _childTextContentChangeSteps() {
      _get(_getPrototypeOf(HTMLTextAreaElementImpl.prototype), "_childTextContentChangeSteps", this).call(this);

      if (this._dirtyValue === false) {
        this._rawValue = childTextContent(this);
      }
    }
  }, {
    key: "_dispatchSelectEvent",
    value: function _dispatchSelectEvent() {
      fireAnEvent("select", this, undefined, {
        bubbles: true,
        cancelable: true
      });
    }
  }, {
    key: "_getValueLength",
    value: function _getValueLength() {
      return typeof this.value === "string" ? this.value.length : 0;
    }
  }, {
    key: "select",
    value: function select() {
      this._selectionStart = 0;
      this._selectionEnd = this._getValueLength();
      this._selectionDirection = "none";

      this._dispatchSelectEvent();
    }
  }, {
    key: "setSelectionRange",
    value: function setSelectionRange(start, end, dir) {
      this._selectionEnd = Math.min(end, this._getValueLength());
      this._selectionStart = Math.min(start, this._selectionEnd);
      this._selectionDirection = dir === "forward" || dir === "backward" ? dir : "none";

      this._dispatchSelectEvent();
    }
  }, {
    key: "setRangeText",
    value: function setRangeText(repl, start, end) {
      var selectionMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "preserve";

      if (arguments.length < 2) {
        start = this._selectionStart;
        end = this._selectionEnd;
      } else if (start > end) {
        throw DOMException.create(this._globalObject, ["The index is not in the allowed range.", "IndexSizeError"]);
      }

      start = Math.min(start, this._getValueLength());
      end = Math.min(end, this._getValueLength());
      var val = this.value;
      var selStart = this._selectionStart;
      var selEnd = this._selectionEnd;
      this.value = val.slice(0, start) + repl + val.slice(end);
      var newEnd = start + this.value.length;

      if (selectionMode === "select") {
        this.setSelectionRange(start, newEnd);
      } else if (selectionMode === "start") {
        this.setSelectionRange(start, start);
      } else if (selectionMode === "end") {
        this.setSelectionRange(newEnd, newEnd);
      } else {
        // preserve
        var delta = repl.length - (end - start);

        if (selStart > end) {
          selStart += delta;
        } else if (selStart > start) {
          selStart = start;
        }

        if (selEnd > end) {
          selEnd += delta;
        } else if (selEnd > start) {
          selEnd = newEnd;
        }

        this.setSelectionRange(selStart, selEnd);
      }
    }
  }, {
    key: "_barredFromConstraintValidationSpecialization",
    value: function _barredFromConstraintValidationSpecialization() {
      return this.hasAttributeNS(null, "readonly");
    }
  }, {
    key: cloningSteps,
    value: function value(copy, node) {
      copy._dirtyValue = node._dirtyValue;
      copy._rawValue = node._rawValue;
    }
  }, {
    key: "labels",
    get: function get() {
      return getLabelsForLabelable(this);
    }
  }, {
    key: "form",
    get: function get() {
      return formOwner(this);
    }
  }, {
    key: "defaultValue",
    get: function get() {
      return childTextContent(this);
    },
    set: function set(val) {
      this.textContent = val;
    }
  }, {
    key: "value",
    get: function get() {
      return this._getAPIValue();
    },
    set: function set(val) {
      // https://html.spec.whatwg.org/multipage/form-elements.html#dom-textarea-value
      var oldAPIValue = this._getAPIValue();

      this._rawValue = val;
      this._dirtyValue = true;

      if (oldAPIValue !== this._getAPIValue()) {
        this._selectionStart = this._selectionEnd = this._getValueLength();
        this._selectionDirection = "none";
      }
    }
  }, {
    key: "textLength",
    get: function get() {
      return this.value.length; // code unit length (16 bit)
    }
  }, {
    key: "type",
    get: function get() {
      return "textarea";
    }
  }, {
    key: "selectionStart",
    get: function get() {
      return this._selectionStart;
    },
    set: function set(start) {
      this.setSelectionRange(start, Math.max(start, this._selectionEnd), this._selectionDirection);
    }
  }, {
    key: "selectionEnd",
    get: function get() {
      return this._selectionEnd;
    },
    set: function set(end) {
      this.setSelectionRange(this._selectionStart, end, this._selectionDirection);
    }
  }, {
    key: "selectionDirection",
    get: function get() {
      return this._selectionDirection;
    },
    set: function set(dir) {
      this.setSelectionRange(this._selectionStart, this._selectionEnd, dir);
    }
  }, {
    key: "cols",
    get: function get() {
      if (!this.hasAttributeNS(null, "cols")) {
        return 20;
      }

      return parseInt(this.getAttributeNS(null, "cols"));
    },
    set: function set(value) {
      if (value <= 0) {
        throw DOMException.create(this._globalObject, ["The index is not in the allowed range.", "IndexSizeError"]);
      }

      this.setAttributeNS(null, "cols", String(value));
    }
  }, {
    key: "rows",
    get: function get() {
      if (!this.hasAttributeNS(null, "rows")) {
        return 2;
      }

      return parseInt(this.getAttributeNS(null, "rows"));
    },
    set: function set(value) {
      if (value <= 0) {
        throw DOMException.create(this._globalObject, ["The index is not in the allowed range.", "IndexSizeError"]);
      }

      this.setAttributeNS(null, "rows", String(value));
    }
  }, {
    key: "_mutable",
    get: function get() {
      return !isDisabled(this) && !this.hasAttributeNS(null, "readonly");
    } // https://html.spec.whatwg.org/multipage/form-elements.html#attr-textarea-required

  }, {
    key: "validity",
    get: function get() {
      var _this2 = this;

      if (!this._validity) {
        var state = {
          valueMissing: function valueMissing() {
            return _this2.hasAttributeNS(null, "required") && _this2._mutable && _this2.value === "";
          }
        };
        this._validity = ValidityState.createImpl(this._globalObject, [], {
          element: this,
          state: state
        });
      }

      return this._validity;
    }
  }]);

  return HTMLTextAreaElementImpl;
}(HTMLElementImpl);

mixin(HTMLTextAreaElementImpl.prototype, DefaultConstraintValidationImpl.prototype);
module.exports = {
  implementation: HTMLTextAreaElementImpl
};