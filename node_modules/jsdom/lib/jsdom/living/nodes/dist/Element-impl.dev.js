"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var _require = require("../helpers/selectors"),
    addNwsapi = _require.addNwsapi;

var _require2 = require("../helpers/namespaces"),
    HTML_NS = _require2.HTML_NS;

var _require3 = require("../../utils"),
    mixin = _require3.mixin,
    memoizeQuery = _require3.memoizeQuery;

var idlUtils = require("../generated/utils");

var NodeImpl = require("./Node-impl").implementation;

var ParentNodeImpl = require("./ParentNode-impl").implementation;

var ChildNodeImpl = require("./ChildNode-impl").implementation;

var attributes = require("../attributes");

var namedPropertiesWindow = require("../named-properties-window");

var NODE_TYPE = require("../node-type");

var _require4 = require("../../browser/parser"),
    parseFragment = _require4.parseFragment;

var _require5 = require("../domparsing/serialization"),
    fragmentSerialization = _require5.fragmentSerialization;

var _require6 = require("../helpers/internal-constants"),
    domSymbolTree = _require6.domSymbolTree;

var DOMException = require("domexception/webidl2js-wrapper");

var DOMTokenList = require("../generated/DOMTokenList");

var NamedNodeMap = require("../generated/NamedNodeMap");

var validateNames = require("../helpers/validate-names");

var _require7 = require("../helpers/strings"),
    asciiLowercase = _require7.asciiLowercase,
    asciiUppercase = _require7.asciiUppercase;

var _require8 = require("../node"),
    listOfElementsWithQualifiedName = _require8.listOfElementsWithQualifiedName,
    listOfElementsWithNamespaceAndLocalName = _require8.listOfElementsWithNamespaceAndLocalName,
    listOfElementsWithClassNames = _require8.listOfElementsWithClassNames;

var SlotableMixinImpl = require("./Slotable-impl").implementation;

var NonDocumentTypeChildNode = require("./NonDocumentTypeChildNode-impl").implementation;

var ShadowRoot = require("../generated/ShadowRoot");

var Text = require("../generated/Text");

var _require9 = require("../helpers/shadow-dom"),
    isValidHostElementName = _require9.isValidHostElementName;

var _require10 = require("../helpers/custom-elements"),
    isValidCustomElementName = _require10.isValidCustomElementName,
    lookupCEDefinition = _require10.lookupCEDefinition;

function attachId(id, elm, doc) {
  if (id && elm && doc) {
    if (!doc._ids[id]) {
      doc._ids[id] = [];
    }

    doc._ids[id].push(elm);
  }
}

function detachId(id, elm, doc) {
  if (id && elm && doc) {
    if (doc._ids && doc._ids[id]) {
      var elms = doc._ids[id];

      for (var i = 0; i < elms.length; i++) {
        if (elms[i] === elm) {
          elms.splice(i, 1);
          --i;
        }
      }

      if (elms.length === 0) {
        delete doc._ids[id];
      }
    }
  }
}

var ElementImpl =
/*#__PURE__*/
function (_NodeImpl) {
  _inherits(ElementImpl, _NodeImpl);

  function ElementImpl(globalObject, args, privateData) {
    var _this;

    _classCallCheck(this, ElementImpl);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ElementImpl).call(this, globalObject, args, privateData));

    _this._initSlotableMixin();

    _this._namespaceURI = privateData.namespace;
    _this._prefix = privateData.prefix;
    _this._localName = privateData.localName;
    _this._ceState = privateData.ceState;
    _this._ceDefinition = privateData.ceDefinition;
    _this._isValue = privateData.isValue;
    _this._shadowRoot = null;
    _this._ceReactionQueue = [];
    _this.nodeType = NODE_TYPE.ELEMENT_NODE;
    _this.scrollTop = 0;
    _this.scrollLeft = 0;
    _this._attributeList = []; // Used for caching.

    _this._attributesByNameMap = new Map();
    _this._attributes = NamedNodeMap.createImpl(_this._globalObject, [], {
      element: _assertThisInitialized(_this)
    });
    _this._cachedTagName = null;
    return _this;
  }

  _createClass(ElementImpl, [{
    key: "_attach",
    value: function _attach() {
      namedPropertiesWindow.nodeAttachedToDocument(this);
      var id = this.getAttributeNS(null, "id");

      if (id) {
        attachId(id, this, this._ownerDocument);
      }

      _get(_getPrototypeOf(ElementImpl.prototype), "_attach", this).call(this);
    }
  }, {
    key: "_detach",
    value: function _detach() {
      _get(_getPrototypeOf(ElementImpl.prototype), "_detach", this).call(this);

      namedPropertiesWindow.nodeDetachedFromDocument(this);
      var id = this.getAttributeNS(null, "id");

      if (id) {
        detachId(id, this, this._ownerDocument);
      }
    }
  }, {
    key: "_attrModified",
    value: function _attrModified(name, value, oldValue) {
      this._modified();

      namedPropertiesWindow.elementAttributeModified(this, name, value, oldValue);

      if (name === "id" && this._attached) {
        var doc = this._ownerDocument;
        detachId(oldValue, this, doc);
        attachId(value, this, doc);
      } // update classList


      if (name === "class" && this._classList !== undefined) {
        this._classList.attrModified();
      }

      this._attrModifiedSlotableMixin(name, value, oldValue);
    }
  }, {
    key: "hasAttributes",
    value: function hasAttributes() {
      return attributes.hasAttributes(this);
    }
  }, {
    key: "getAttributeNames",
    value: function getAttributeNames() {
      return attributes.attributeNames(this);
    }
  }, {
    key: "getAttribute",
    value: function getAttribute(name) {
      var attr = attributes.getAttributeByName(this, name);

      if (!attr) {
        return null;
      }

      return attr._value;
    }
  }, {
    key: "getAttributeNS",
    value: function getAttributeNS(namespace, localName) {
      var attr = attributes.getAttributeByNameNS(this, namespace, localName);

      if (!attr) {
        return null;
      }

      return attr._value;
    }
  }, {
    key: "setAttribute",
    value: function setAttribute(name, value) {
      validateNames.name(this._globalObject, name);

      if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === "html") {
        name = asciiLowercase(name);
      }

      var attribute = attributes.getAttributeByName(this, name);

      if (attribute === null) {
        var newAttr = this._ownerDocument._createAttribute({
          localName: name,
          value: value
        });

        attributes.appendAttribute(this, newAttr);
        return;
      }

      attributes.changeAttribute(this, attribute, value);
    }
  }, {
    key: "setAttributeNS",
    value: function setAttributeNS(namespace, name, value) {
      var extracted = validateNames.validateAndExtract(this._globalObject, namespace, name); // Because of widespread use of this method internally, e.g. to manually implement attribute/content reflection, we
      // centralize the conversion to a string here, so that all call sites don't have to do it.

      value = "".concat(value);
      attributes.setAttributeValue(this, extracted.localName, value, extracted.prefix, extracted.namespace);
    }
  }, {
    key: "removeAttribute",
    value: function removeAttribute(name) {
      attributes.removeAttributeByName(this, name);
    }
  }, {
    key: "removeAttributeNS",
    value: function removeAttributeNS(namespace, localName) {
      attributes.removeAttributeByNameNS(this, namespace, localName);
    }
  }, {
    key: "toggleAttribute",
    value: function toggleAttribute(qualifiedName, force) {
      validateNames.name(this._globalObject, qualifiedName);

      if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === "html") {
        qualifiedName = asciiLowercase(qualifiedName);
      }

      var attribute = attributes.getAttributeByName(this, qualifiedName);

      if (attribute === null) {
        if (force === undefined || force === true) {
          var newAttr = this._ownerDocument._createAttribute({
            localName: qualifiedName,
            value: ""
          });

          attributes.appendAttribute(this, newAttr);
          return true;
        }

        return false;
      }

      if (force === undefined || force === false) {
        attributes.removeAttributeByName(this, qualifiedName);
        return false;
      }

      return true;
    }
  }, {
    key: "hasAttribute",
    value: function hasAttribute(name) {
      if (this._namespaceURI === HTML_NS && this._ownerDocument._parsingMode === "html") {
        name = asciiLowercase(name);
      }

      return attributes.hasAttributeByName(this, name);
    }
  }, {
    key: "hasAttributeNS",
    value: function hasAttributeNS(namespace, localName) {
      if (namespace === "") {
        namespace = null;
      }

      return attributes.hasAttributeByNameNS(this, namespace, localName);
    }
  }, {
    key: "getAttributeNode",
    value: function getAttributeNode(name) {
      return attributes.getAttributeByName(this, name);
    }
  }, {
    key: "getAttributeNodeNS",
    value: function getAttributeNodeNS(namespace, localName) {
      return attributes.getAttributeByNameNS(this, namespace, localName);
    }
  }, {
    key: "setAttributeNode",
    value: function setAttributeNode(attr) {
      // eslint-disable-next-line no-restricted-properties
      return attributes.setAttribute(this, attr);
    }
  }, {
    key: "setAttributeNodeNS",
    value: function setAttributeNodeNS(attr) {
      // eslint-disable-next-line no-restricted-properties
      return attributes.setAttribute(this, attr);
    }
  }, {
    key: "removeAttributeNode",
    value: function removeAttributeNode(attr) {
      // eslint-disable-next-line no-restricted-properties
      if (!attributes.hasAttribute(this, attr)) {
        throw DOMException.create(this._globalObject, ["Tried to remove an attribute that was not present", "NotFoundError"]);
      } // eslint-disable-next-line no-restricted-properties


      attributes.removeAttribute(this, attr);
      return attr;
    }
  }, {
    key: "getBoundingClientRect",
    value: function getBoundingClientRect() {
      return {
        bottom: 0,
        height: 0,
        left: 0,
        right: 0,
        top: 0,
        width: 0
      };
    }
  }, {
    key: "getClientRects",
    value: function getClientRects() {
      return [];
    }
  }, {
    key: "attachShadow",
    // https://dom.spec.whatwg.org/#dom-element-attachshadow
    value: function attachShadow(init) {
      var _ownerDocument = this._ownerDocument,
          _namespaceURI = this._namespaceURI,
          _localName = this._localName,
          _isValue = this._isValue;

      if (this.namespaceURI !== HTML_NS) {
        throw DOMException.create(this._globalObject, ["This element does not support attachShadow. This element is not part of the HTML namespace.", "NotSupportedError"]);
      }

      if (!isValidHostElementName(_localName) && !isValidCustomElementName(_localName)) {
        var message = "This element does not support attachShadow. This element is not a custom element nor " + "a standard element supporting a shadow root.";
        throw DOMException.create(this._globalObject, [message, "NotSupportedError"]);
      }

      if (isValidCustomElementName(_localName) || _isValue) {
        var definition = lookupCEDefinition(_ownerDocument, _namespaceURI, _localName, _isValue);

        if (definition && definition.disableShadow) {
          throw DOMException.create(this._globalObject, ["Shadow root cannot be create on a custom element with disabled shadow", "NotSupportedError"]);
        }
      }

      if (this._shadowRoot !== null) {
        throw DOMException.create(this._globalObject, ["Shadow root cannot be created on a host which already hosts a shadow tree.", "NotSupportedError"]);
      }

      var shadow = ShadowRoot.createImpl(this._globalObject, [], {
        ownerDocument: this.ownerDocument,
        mode: init.mode,
        host: this
      });
      this._shadowRoot = shadow;
      return shadow;
    } // https://dom.spec.whatwg.org/#dom-element-shadowroot

  }, {
    key: "_insertAdjacent",
    // https://dom.spec.whatwg.org/#insert-adjacent
    value: function _insertAdjacent(element, where, node) {
      where = asciiLowercase(where);

      if (where === "beforebegin") {
        if (element.parentNode === null) {
          return null;
        }

        return element.parentNode._preInsert(node, element);
      }

      if (where === "afterbegin") {
        return element._preInsert(node, element.firstChild);
      }

      if (where === "beforeend") {
        return element._preInsert(node, null);
      }

      if (where === "afterend") {
        if (element.parentNode === null) {
          return null;
        }

        return element.parentNode._preInsert(node, element.nextSibling);
      }

      throw DOMException.create(this._globalObject, ['Must provide one of "beforebegin", "afterbegin", "beforeend", or "afterend".', "SyntaxError"]);
    }
  }, {
    key: "insertAdjacentElement",
    value: function insertAdjacentElement(where, element) {
      return this._insertAdjacent(this, where, element);
    }
  }, {
    key: "insertAdjacentText",
    value: function insertAdjacentText(where, data) {
      var text = Text.createImpl(this._globalObject, [], {
        data: data,
        ownerDocument: this._ownerDocument
      });

      this._insertAdjacent(this, where, text);
    } // https://w3c.github.io/DOM-Parsing/#dom-element-insertadjacenthtml

  }, {
    key: "insertAdjacentHTML",
    value: function insertAdjacentHTML(position, text) {
      position = asciiLowercase(position);
      var context;

      switch (position) {
        case "beforebegin":
        case "afterend":
          {
            context = this.parentNode;

            if (context === null || context.nodeType === NODE_TYPE.DOCUMENT_NODE) {
              throw DOMException.create(this._globalObject, ["Cannot insert HTML adjacent to parent-less nodes or children of document nodes.", "NoModificationAllowedError"]);
            }

            break;
          }

        case "afterbegin":
        case "beforeend":
          {
            context = this;
            break;
          }

        default:
          {
            throw DOMException.create(this._globalObject, ['Must provide one of "beforebegin", "afterbegin", "beforeend", or "afterend".', "SyntaxError"]);
          }
      }

      if (context.nodeType !== NODE_TYPE.ELEMENT_NODE || context._ownerDocument._parsingMode === "html" && context._localName === "html" && context._namespaceURI === HTML_NS) {
        context = context._ownerDocument.createElement("body");
      }

      var fragment = parseFragment(text, context);

      switch (position) {
        case "beforebegin":
          {
            this.parentNode._insert(fragment, this);

            break;
          }

        case "afterbegin":
          {
            this._insert(fragment, this.firstChild);

            break;
          }

        case "beforeend":
          {
            this._append(fragment);

            break;
          }

        case "afterend":
          {
            this.parentNode._insert(fragment, this.nextSibling);

            break;
          }
      }
    }
  }, {
    key: "closest",
    value: function closest(selectors) {
      var matcher = addNwsapi(this);
      return matcher.closest(selectors, idlUtils.wrapperForImpl(this));
    }
  }, {
    key: "namespaceURI",
    get: function get() {
      return this._namespaceURI;
    }
  }, {
    key: "prefix",
    get: function get() {
      return this._prefix;
    }
  }, {
    key: "localName",
    get: function get() {
      return this._localName;
    }
  }, {
    key: "_qualifiedName",
    get: function get() {
      return this._prefix !== null ? this._prefix + ":" + this._localName : this._localName;
    }
  }, {
    key: "tagName",
    get: function get() {
      // This getter can be a hotpath in getComputedStyle.
      // All these are invariants during the instance lifetime so we can safely cache the computed tagName.
      // We could create it during construction but since we already identified this as potentially slow we do it lazily.
      if (this._cachedTagName === null) {
        if (this.namespaceURI === HTML_NS && this._ownerDocument._parsingMode === "html") {
          this._cachedTagName = asciiUppercase(this._qualifiedName);
        } else {
          this._cachedTagName = this._qualifiedName;
        }
      }

      return this._cachedTagName;
    }
  }, {
    key: "attributes",
    get: function get() {
      return this._attributes;
    } // https://w3c.github.io/DOM-Parsing/#dom-element-outerhtml

  }, {
    key: "outerHTML",
    get: function get() {
      // TODO: maybe parse5 can give us a hook where it serializes the node itself too:
      // https://github.com/inikulin/parse5/issues/230
      // Alternatively, if we can create a virtual node in domSymbolTree, that'd also work.
      // It's currently prevented by the fact that a node can't be duplicated in the same tree.
      // Then we could get rid of all the code for childNodesForSerializing.
      return fragmentSerialization({
        childNodesForSerializing: [this],
        _ownerDocument: this._ownerDocument
      }, {
        requireWellFormed: true,
        globalObject: this._globalObject
      });
    },
    set: function set(markup) {
      var parent = domSymbolTree.parent(this);
      var document = this._ownerDocument;

      if (!parent) {
        return;
      }

      if (parent.nodeType === NODE_TYPE.DOCUMENT_NODE) {
        throw DOMException.create(this._globalObject, ["Modifications are not allowed for this document", "NoModificationAllowedError"]);
      }

      if (parent.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {
        parent = document.createElementNS(HTML_NS, "body");
      }

      var fragment = parseFragment(markup, parent);
      var contextObjectParent = domSymbolTree.parent(this);

      contextObjectParent._replace(fragment, this);
    } // https://w3c.github.io/DOM-Parsing/#dfn-innerhtml

  }, {
    key: "innerHTML",
    get: function get() {
      return fragmentSerialization(this, {
        requireWellFormed: true,
        globalObject: this._globalObject
      });
    },
    set: function set(markup) {
      var fragment = parseFragment(markup, this);
      var contextObject = this;

      if (this.localName === "template" && this.namespaceURI === HTML_NS) {
        contextObject = contextObject._templateContents;
      }

      contextObject._replaceAll(fragment);
    }
  }, {
    key: "classList",
    get: function get() {
      if (this._classList === undefined) {
        this._classList = DOMTokenList.createImpl(this._globalObject, [], {
          element: this,
          attributeLocalName: "class"
        });
      }

      return this._classList;
    }
  }, {
    key: "scrollWidth",
    get: function get() {
      return 0;
    }
  }, {
    key: "scrollHeight",
    get: function get() {
      return 0;
    }
  }, {
    key: "clientTop",
    get: function get() {
      return 0;
    }
  }, {
    key: "clientLeft",
    get: function get() {
      return 0;
    }
  }, {
    key: "clientWidth",
    get: function get() {
      return 0;
    }
  }, {
    key: "clientHeight",
    get: function get() {
      return 0;
    }
  }, {
    key: "shadowRoot",
    get: function get() {
      var shadow = this._shadowRoot;

      if (shadow === null || shadow.mode === "closed") {
        return null;
      }

      return shadow;
    }
  }]);

  return ElementImpl;
}(NodeImpl);

mixin(ElementImpl.prototype, NonDocumentTypeChildNode.prototype);
mixin(ElementImpl.prototype, ParentNodeImpl.prototype);
mixin(ElementImpl.prototype, ChildNodeImpl.prototype);
mixin(ElementImpl.prototype, SlotableMixinImpl.prototype);
ElementImpl.prototype.getElementsByTagName = memoizeQuery(function (qualifiedName) {
  return listOfElementsWithQualifiedName(qualifiedName, this);
});
ElementImpl.prototype.getElementsByTagNameNS = memoizeQuery(function (namespace, localName) {
  return listOfElementsWithNamespaceAndLocalName(namespace, localName, this);
});
ElementImpl.prototype.getElementsByClassName = memoizeQuery(function (classNames) {
  return listOfElementsWithClassNames(classNames, this);
});

ElementImpl.prototype.matches = function (selectors) {
  var matcher = addNwsapi(this);
  return matcher.match(selectors, idlUtils.wrapperForImpl(this));
};

ElementImpl.prototype.webkitMatchesSelector = ElementImpl.prototype.matches;
module.exports = {
  implementation: ElementImpl
};