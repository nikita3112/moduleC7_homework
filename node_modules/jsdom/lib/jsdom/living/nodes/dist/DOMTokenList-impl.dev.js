"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DOMException = require("domexception/webidl2js-wrapper");

var OrderedSet = require("../helpers/ordered-set.js");

var _require = require("../helpers/strings.js"),
    asciiLowercase = _require.asciiLowercase;

var idlUtils = require("../generated/utils.js");

var _require2 = require("../attributes.js"),
    getAttributeValue = _require2.getAttributeValue,
    setAttributeValue = _require2.setAttributeValue,
    hasAttributeByName = _require2.hasAttributeByName;

function validateTokens(globalObject) {
  for (var _len = arguments.length, tokens = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    tokens[_key - 1] = arguments[_key];
  }

  for (var _i = 0, _tokens = tokens; _i < _tokens.length; _i++) {
    var token = _tokens[_i];

    if (token === "") {
      throw DOMException.create(globalObject, ["The token provided must not be empty.", "SyntaxError"]);
    }
  }

  for (var _i2 = 0, _tokens2 = tokens; _i2 < _tokens2.length; _i2++) {
    var _token = _tokens2[_i2];

    if (/[\t\n\f\r ]/.test(_token)) {
      throw DOMException.create(globalObject, ["The token provided contains HTML space characters, which are not valid in tokens.", "InvalidCharacterError"]);
    }
  }
} // https://dom.spec.whatwg.org/#domtokenlist


var DOMTokenListImpl =
/*#__PURE__*/
function () {
  function DOMTokenListImpl(globalObject, args, privateData) {
    _classCallCheck(this, DOMTokenListImpl);

    this._globalObject = globalObject; // _syncWithElement() must always be called before any _tokenSet access.

    this._tokenSet = new OrderedSet();
    this._element = privateData.element;
    this._attributeLocalName = privateData.attributeLocalName;
    this._supportedTokens = privateData.supportedTokens; // Needs synchronization with element if token set is to be accessed.

    this._dirty = true;
  }

  _createClass(DOMTokenListImpl, [{
    key: "attrModified",
    value: function attrModified() {
      this._dirty = true;
    }
  }, {
    key: "_syncWithElement",
    value: function _syncWithElement() {
      if (!this._dirty) {
        return;
      }

      var val = getAttributeValue(this._element, this._attributeLocalName);

      if (val === null) {
        this._tokenSet.empty();
      } else {
        this._tokenSet = OrderedSet.parse(val);
      }

      this._dirty = false;
    }
  }, {
    key: "_validationSteps",
    value: function _validationSteps(token) {
      if (!this._supportedTokens) {
        throw new TypeError("".concat(this._attributeLocalName, " attribute has no supported tokens"));
      }

      var lowerToken = asciiLowercase(token);
      return this._supportedTokens.has(lowerToken);
    }
  }, {
    key: "_updateSteps",
    value: function _updateSteps() {
      if (!hasAttributeByName(this._element, this._attributeLocalName) && this._tokenSet.isEmpty()) {
        return;
      }

      setAttributeValue(this._element, this._attributeLocalName, this._tokenSet.serialize());
    }
  }, {
    key: "_serializeSteps",
    value: function _serializeSteps() {
      return getAttributeValue(this._element, this._attributeLocalName);
    } // Used by other parts of jsdom

  }, {
    key: "item",
    value: function item(index) {
      this._syncWithElement();

      if (index >= this._tokenSet.size) {
        return null;
      }

      return this._tokenSet.get(index);
    }
  }, {
    key: "contains",
    value: function contains(token) {
      this._syncWithElement();

      return this._tokenSet.contains(token);
    }
  }, {
    key: "add",
    value: function add() {
      for (var _len2 = arguments.length, tokens = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        tokens[_key2] = arguments[_key2];
      }

      for (var _i3 = 0, _tokens3 = tokens; _i3 < _tokens3.length; _i3++) {
        var token = _tokens3[_i3];
        validateTokens(this._globalObject, token);
      }

      this._syncWithElement();

      for (var _i4 = 0, _tokens4 = tokens; _i4 < _tokens4.length; _i4++) {
        var _token2 = _tokens4[_i4];

        this._tokenSet.append(_token2);
      }

      this._updateSteps();
    }
  }, {
    key: "remove",
    value: function remove() {
      var _this$_tokenSet;

      for (var _len3 = arguments.length, tokens = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        tokens[_key3] = arguments[_key3];
      }

      for (var _i5 = 0, _tokens5 = tokens; _i5 < _tokens5.length; _i5++) {
        var token = _tokens5[_i5];
        validateTokens(this._globalObject, token);
      }

      this._syncWithElement();

      (_this$_tokenSet = this._tokenSet).remove.apply(_this$_tokenSet, tokens);

      this._updateSteps();
    }
  }, {
    key: "toggle",
    value: function toggle(token) {
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      validateTokens(this._globalObject, token);

      this._syncWithElement();

      if (this._tokenSet.contains(token)) {
        if (force === undefined || force === false) {
          this._tokenSet.remove(token);

          this._updateSteps();

          return false;
        }

        return true;
      }

      if (force === undefined || force === true) {
        this._tokenSet.append(token);

        this._updateSteps();

        return true;
      }

      return false;
    }
  }, {
    key: "replace",
    value: function replace(token, newToken) {
      validateTokens(this._globalObject, token, newToken);

      this._syncWithElement();

      if (!this._tokenSet.contains(token)) {
        return false;
      }

      this._tokenSet.replace(token, newToken);

      this._updateSteps();

      return true;
    }
  }, {
    key: "supports",
    value: function supports(token) {
      return this._validationSteps(token);
    }
  }, {
    key: "tokenSet",
    get: function get() {
      this._syncWithElement();

      return this._tokenSet;
    }
  }, {
    key: "length",
    get: function get() {
      this._syncWithElement();

      return this._tokenSet.size;
    }
  }, {
    key: idlUtils.supportedPropertyIndices,
    get: function get() {
      this._syncWithElement();

      return this._tokenSet.keys();
    }
  }, {
    key: "value",
    get: function get() {
      return this._serializeSteps();
    },
    set: function set(V) {
      setAttributeValue(this._element, this._attributeLocalName, V);
    }
  }]);

  return DOMTokenListImpl;
}();

exports.implementation = DOMTokenListImpl;