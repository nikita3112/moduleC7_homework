"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var DOMException = require("domexception/webidl2js-wrapper");

var HTMLElementImpl = require("./HTMLElement-impl").implementation;

var notImplemented = require("../../browser/not-implemented");

var _require = require("../helpers/events"),
    fireAnEvent = _require.fireAnEvent;

function getTimeRangeDummy() {
  return {
    length: 0,
    start: function start() {
      return 0;
    },
    end: function end() {
      return 0;
    }
  };
}

var HTMLMediaElementImpl =
/*#__PURE__*/
function (_HTMLElementImpl) {
  _inherits(HTMLMediaElementImpl, _HTMLElementImpl);

  function HTMLMediaElementImpl(globalObject, args, privateData) {
    var _this;

    _classCallCheck(this, HTMLMediaElementImpl);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(HTMLMediaElementImpl).call(this, globalObject, args, privateData));
    _this._muted = false;
    _this._volume = 1.0;
    _this.readyState = 0;
    _this.networkState = 0;
    _this.currentTime = 0;
    _this.currentSrc = "";
    _this.buffered = getTimeRangeDummy();
    _this.seeking = false;
    _this.duration = NaN;
    _this.paused = true;
    _this.played = getTimeRangeDummy();
    _this.seekable = getTimeRangeDummy();
    _this.ended = false;
    _this.audioTracks = [];
    _this.videoTracks = [];
    _this.textTracks = [];
    return _this;
  } // Implemented accoring to W3C Draft 22 August 2012


  _createClass(HTMLMediaElementImpl, [{
    key: "_dispatchRateChange",
    value: function _dispatchRateChange() {
      fireAnEvent("ratechange", this);
    }
  }, {
    key: "_dispatchVolumeChange",
    value: function _dispatchVolumeChange() {
      fireAnEvent("volumechange", this);
    }
  }, {
    key: "load",
    // Not (yet) implemented according to spec
    // Should return sane default values
    value: function load() {
      notImplemented("HTMLMediaElement.prototype.load", this._ownerDocument._defaultView);
    }
  }, {
    key: "canPlayType",
    value: function canPlayType() {
      return "";
    }
  }, {
    key: "play",
    value: function play() {
      notImplemented("HTMLMediaElement.prototype.play", this._ownerDocument._defaultView);
    }
  }, {
    key: "pause",
    value: function pause() {
      notImplemented("HTMLMediaElement.prototype.pause", this._ownerDocument._defaultView);
    }
  }, {
    key: "addTextTrack",
    value: function addTextTrack() {
      notImplemented("HTMLMediaElement.prototype.addTextTrack", this._ownerDocument._defaultView);
    }
  }, {
    key: "defaultPlaybackRate",
    set: function set(v) {
      if (v === 0.0) {
        throw DOMException.create(this._globalObject, ["The operation is not supported.", "NotSupportedError"]);
      }

      if (this._defaultPlaybackRate !== v) {
        this._defaultPlaybackRate = v;

        this._dispatchRateChange();
      }
    },
    get: function get() {
      if (this._defaultPlaybackRate === undefined) {
        return 1.0;
      }

      return this._defaultPlaybackRate;
    }
  }, {
    key: "playbackRate",
    get: function get() {
      if (this._playbackRate === undefined) {
        return 1.0;
      }

      return this._playbackRate;
    },
    set: function set(v) {
      if (v !== this._playbackRate) {
        this._playbackRate = v;

        this._dispatchRateChange();
      }
    }
  }, {
    key: "muted",
    get: function get() {
      return this._muted;
    },
    set: function set(v) {
      if (v !== this._muted) {
        this._muted = v;

        this._dispatchVolumeChange();
      }
    }
  }, {
    key: "defaultMuted",
    get: function get() {
      return this.getAttributeNS(null, "muted") !== null;
    },
    set: function set(v) {
      if (v) {
        this.setAttributeNS(null, "muted", v);
      } else {
        this.removeAttributeNS(null, "muted");
      }
    }
  }, {
    key: "volume",
    get: function get() {
      return this._volume;
    },
    set: function set(v) {
      if (v < 0 || v > 1) {
        throw DOMException.create(this._globalObject, ["The index is not in the allowed range.", "IndexSizeError"]);
      }

      if (this._volume !== v) {
        this._volume = v;

        this._dispatchVolumeChange();
      }
    }
  }]);

  return HTMLMediaElementImpl;
}(HTMLElementImpl);

module.exports = {
  implementation: HTMLMediaElementImpl
};