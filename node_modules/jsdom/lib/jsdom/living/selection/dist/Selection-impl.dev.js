"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var DOMException = require("domexception/webidl2js-wrapper");

var NODE_TYPE = require("../node-type");

var _require = require("../helpers/node"),
    nodeLength = _require.nodeLength,
    nodeRoot = _require.nodeRoot;

var _require2 = require("../helpers/internal-constants"),
    domSymbolTree = _require2.domSymbolTree;

var _require3 = require("../range/boundary-point"),
    compareBoundaryPointsPosition = _require3.compareBoundaryPointsPosition;

var _require4 = require("../range/Range-impl"),
    setBoundaryPointStart = _require4.setBoundaryPointStart,
    setBoundaryPointEnd = _require4.setBoundaryPointEnd;

var Range = require("../generated/Range");

var _require5 = require("../generated/utils"),
    implForWrapper = _require5.implForWrapper; // https://w3c.github.io/selection-api/#dfn-direction


var SELECTION_DIRECTION = {
  FORWARDS: 1,
  BACKWARDS: -1,
  DIRECTIONLESS: 0
}; // https://w3c.github.io/selection-api/#dom-selection

var SelectionImpl =
/*#__PURE__*/
function () {
  function SelectionImpl(globalObject) {
    _classCallCheck(this, SelectionImpl);

    this._range = null;
    this._direction = SELECTION_DIRECTION.DIRECTIONLESS;
    this._globalObject = globalObject;
  } // https://w3c.github.io/selection-api/#dom-selection-anchornode


  _createClass(SelectionImpl, [{
    key: "getRangeAt",
    // https://w3c.github.io/selection-api/#dom-selection-getrangeat
    value: function getRangeAt(index) {
      if (index !== 0 || this._isEmpty()) {
        throw DOMException.create(this._globalObject, ["Invalid range index.", "IndexSizeError"]);
      }

      return this._range;
    } // https://w3c.github.io/selection-api/#dom-selection-addrange

  }, {
    key: "addRange",
    value: function addRange(range) {
      if (range._root === implForWrapper(this._globalObject._document) && this.rangeCount === 0) {
        this._associateRange(range);
      }
    } // https://w3c.github.io/selection-api/#dom-selection-removerange

  }, {
    key: "removeRange",
    value: function removeRange(range) {
      if (range !== this._range) {
        throw DOMException.create(this._globalObject, ["Invalid range.", "NotFoundError"]);
      }

      this._associateRange(null);
    } // https://w3c.github.io/selection-api/#dom-selection-removeallranges

  }, {
    key: "removeAllRanges",
    value: function removeAllRanges() {
      this._associateRange(null);
    } // https://w3c.github.io/selection-api/#dom-selection-empty

  }, {
    key: "empty",
    value: function empty() {
      this.removeAllRanges();
    } // https://w3c.github.io/selection-api/#dom-selection-collapse

  }, {
    key: "collapse",
    value: function collapse(node, offset) {
      if (node === null) {
        this.removeAllRanges();
        return;
      }

      if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {
        throw DOMException.create(this._globalObject, ["DocumentType Node can't be used as boundary point.", "InvalidNodeTypeError"]);
      }

      if (offset > nodeLength(node)) {
        throw DOMException.create(this._globalObject, ["Invalid range index.", "IndexSizeError"]);
      }

      if (nodeRoot(node) !== implForWrapper(this._globalObject._document)) {
        return;
      }

      var newRange = Range.createImpl(this._globalObject, [], {
        start: {
          node: node,
          offset: 0
        },
        end: {
          node: node,
          offset: 0
        }
      });
      setBoundaryPointStart(newRange, node, offset);
      setBoundaryPointEnd(newRange, node, offset);

      this._associateRange(newRange);
    } // https://w3c.github.io/selection-api/#dom-selection-setposition

  }, {
    key: "setPosition",
    value: function setPosition(node, offset) {
      this.collapse(node, offset);
    } // https://w3c.github.io/selection-api/#dom-selection-collapsetostart

  }, {
    key: "collapseToStart",
    value: function collapseToStart() {
      if (this._isEmpty()) {
        throw DOMException.create(this._globalObject, ["There is no selection to collapse.", "InvalidStateError"]);
      }

      var _this$_range$_start = this._range._start,
          node = _this$_range$_start.node,
          offset = _this$_range$_start.offset;
      var newRange = Range.createImpl(this._globalObject, [], {
        start: {
          node: node,
          offset: offset
        },
        end: {
          node: node,
          offset: offset
        }
      });

      this._associateRange(newRange);
    } // https://w3c.github.io/selection-api/#dom-selection-collapsetoend

  }, {
    key: "collapseToEnd",
    value: function collapseToEnd() {
      if (this._isEmpty()) {
        throw DOMException.create(this._globalObject, ["There is no selection to collapse.", "InvalidStateError"]);
      }

      var _this$_range$_end = this._range._end,
          node = _this$_range$_end.node,
          offset = _this$_range$_end.offset;
      var newRange = Range.createImpl(this._globalObject, [], {
        start: {
          node: node,
          offset: offset
        },
        end: {
          node: node,
          offset: offset
        }
      });

      this._associateRange(newRange);
    } // https://w3c.github.io/selection-api/#dom-selection-extend

  }, {
    key: "extend",
    value: function extend(node, offset) {
      if (nodeRoot(node) !== implForWrapper(this._globalObject._document)) {
        return;
      }

      if (this._isEmpty()) {
        throw DOMException.create(this._globalObject, ["There is no selection to extend.", "InvalidStateError"]);
      }

      var oldAnchor = this._anchor;
      var newFocus = {
        node: node,
        offset: offset
      };
      var newRange = Range.createImpl(this._globalObject, [], {
        start: {
          node: node,
          offset: 0
        },
        end: {
          node: node,
          offset: 0
        }
      });

      if (nodeRoot(node) !== this._range._root) {
        setBoundaryPointStart(newRange, newFocus.node, newFocus.offset);
        setBoundaryPointEnd(newRange, newFocus.node, newFocus.offset);
      } else if (compareBoundaryPointsPosition(oldAnchor, newFocus) <= 0) {
        setBoundaryPointStart(newRange, oldAnchor.node, oldAnchor.offset);
        setBoundaryPointEnd(newRange, newFocus.node, newFocus.offset);
      } else {
        setBoundaryPointStart(newRange, newFocus.node, newFocus.offset);
        setBoundaryPointEnd(newRange, oldAnchor.node, oldAnchor.offset);
      }

      this._associateRange(newRange);

      this._direction = compareBoundaryPointsPosition(newFocus, oldAnchor) === -1 ? SELECTION_DIRECTION.BACKWARDS : SELECTION_DIRECTION.FORWARDS;
    } // https://w3c.github.io/selection-api/#dom-selection-setbaseandextent

  }, {
    key: "setBaseAndExtent",
    value: function setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset) {
      if (anchorOffset > nodeLength(anchorNode) || focusOffset > nodeLength(focusNode)) {
        throw DOMException.create(this._globalObject, ["Invalid anchor or focus offset.", "IndexSizeError"]);
      }

      var document = implForWrapper(this._globalObject._document);

      if (document !== nodeRoot(anchorNode) || document !== nodeRoot(focusNode)) {
        return;
      }

      var anchor = {
        node: anchorNode,
        offset: anchorOffset
      };
      var focus = {
        node: focusNode,
        offset: focusOffset
      };
      var newRange;

      if (compareBoundaryPointsPosition(anchor, focus) === -1) {
        newRange = Range.createImpl(this._globalObject, [], {
          start: {
            node: anchor.node,
            offset: anchor.offset
          },
          end: {
            node: focus.node,
            offset: focus.offset
          }
        });
      } else {
        newRange = Range.createImpl(this._globalObject, [], {
          start: {
            node: focus.node,
            offset: focus.offset
          },
          end: {
            node: anchor.node,
            offset: anchor.offset
          }
        });
      }

      this._associateRange(newRange);

      this._direction = compareBoundaryPointsPosition(focus, anchor) === -1 ? SELECTION_DIRECTION.BACKWARDS : SELECTION_DIRECTION.FORWARDS;
    } // https://w3c.github.io/selection-api/#dom-selection-selectallchildren

  }, {
    key: "selectAllChildren",
    value: function selectAllChildren(node) {
      if (node.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {
        throw DOMException.create(this._globalObject, ["DocumentType Node can't be used as boundary point.", "InvalidNodeTypeError"]);
      }

      var document = implForWrapper(this._globalObject._document);

      if (document !== nodeRoot(node)) {
        return;
      }

      var length = domSymbolTree.childrenCount(node);
      var newRange = Range.createImpl(this._globalObject, [], {
        start: {
          node: node,
          offset: 0
        },
        end: {
          node: node,
          offset: 0
        }
      });
      setBoundaryPointStart(newRange, node, 0);
      setBoundaryPointEnd(newRange, node, length);

      this._associateRange(newRange);
    } // https://w3c.github.io/selection-api/#dom-selection-deletefromdocument

  }, {
    key: "deleteFromDocument",
    value: function deleteFromDocument() {
      if (!this._isEmpty()) {
        this._range.deleteContents();
      }
    } // https://w3c.github.io/selection-api/#dom-selection-containsnode

  }, {
    key: "containsNode",
    value: function containsNode(node, allowPartialContainment) {
      if (this._isEmpty() || nodeRoot(node) !== implForWrapper(this._globalObject._document)) {
        return false;
      }

      var _this$_range = this._range,
          _start = _this$_range._start,
          _end = _this$_range._end;
      var startIsBeforeNode = compareBoundaryPointsPosition(_start, {
        node: node,
        offset: 0
      }) === -1;
      var endIsAfterNode = compareBoundaryPointsPosition(_end, {
        node: node,
        offset: nodeLength(node)
      }) === 1;
      return allowPartialContainment ? startIsBeforeNode || endIsAfterNode : startIsBeforeNode && endIsAfterNode;
    } // https://w3c.github.io/selection-api/#dom-selection-stringifier

  }, {
    key: "toString",
    value: function toString() {
      return this._range ? this._range.toString() : "";
    } // https://w3c.github.io/selection-api/#dfn-empty

  }, {
    key: "_isEmpty",
    value: function _isEmpty() {
      return this._range === null;
    } // https://w3c.github.io/selection-api/#dfn-anchor

  }, {
    key: "_associateRange",
    value: function _associateRange(newRange) {
      this._range = newRange;
      this._direction = newRange === null ? SELECTION_DIRECTION.DIRECTIONLESS : SELECTION_DIRECTION.FORWARDS; // TODO: Emit "selectionchange" event. At this time, there is currently no test in WPT covering this.
      // https://w3c.github.io/selection-api/#selectionchange-event
    }
  }, {
    key: "anchorNode",
    get: function get() {
      var anchor = this._anchor;
      return anchor ? anchor.node : null;
    } // https://w3c.github.io/selection-api/#dom-selection-anchoroffset

  }, {
    key: "anchorOffset",
    get: function get() {
      var anchor = this._anchor;
      return anchor ? anchor.offset : 0;
    } // https://w3c.github.io/selection-api/#dom-selection-focusnode

  }, {
    key: "focusNode",
    get: function get() {
      var focus = this._focus;
      return focus ? focus.node : null;
    } // https://w3c.github.io/selection-api/#dom-selection-focusoffset

  }, {
    key: "focusOffset",
    get: function get() {
      var focus = this._focus;
      return focus ? focus.offset : 0;
    } // https://w3c.github.io/selection-api/#dom-selection-iscollapsed

  }, {
    key: "isCollapsed",
    get: function get() {
      return this._range === null || this._range.collapsed;
    } // https://w3c.github.io/selection-api/#dom-selection-rangecount

  }, {
    key: "rangeCount",
    get: function get() {
      return this._isEmpty() ? 0 : 1;
    } // https://w3c.github.io/selection-api/#dom-selection-type

  }, {
    key: "type",
    get: function get() {
      if (this._isEmpty()) {
        return "None";
      } else if (this._range.collapsed) {
        return "Caret";
      }

      return "Range";
    }
  }, {
    key: "_anchor",
    get: function get() {
      if (!this._range) {
        return null;
      }

      return this._direction === SELECTION_DIRECTION.FORWARDS ? this._range._start : this._range._end;
    } // https://w3c.github.io/selection-api/#dfn-focus

  }, {
    key: "_focus",
    get: function get() {
      if (!this._range) {
        return null;
      }

      return this._direction === SELECTION_DIRECTION.FORWARDS ? this._range._end : this._range._start;
    }
  }]);

  return SelectionImpl;
}();

module.exports = {
  implementation: SelectionImpl
};