"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var parse = require("./parser.js");

var serialize = require("./serializer.js");

var _require = require("./utils.js"),
    asciiLowercase = _require.asciiLowercase,
    solelyContainsHTTPTokenCodePoints = _require.solelyContainsHTTPTokenCodePoints,
    soleyContainsHTTPQuotedStringTokenCodePoints = _require.soleyContainsHTTPQuotedStringTokenCodePoints;

module.exports =
/*#__PURE__*/
function () {
  function MIMEType(string) {
    _classCallCheck(this, MIMEType);

    string = String(string);
    var result = parse(string);

    if (result === null) {
      throw new Error("Could not parse MIME type string \"".concat(string, "\""));
    }

    this._type = result.type;
    this._subtype = result.subtype;
    this._parameters = new MIMETypeParameters(result.parameters);
  }

  _createClass(MIMEType, [{
    key: "toString",
    value: function toString() {
      // The serialize function works on both "MIME type records" (i.e. the results of parse) and on this class, since
      // this class's interface is identical.
      return serialize(this);
    }
  }, {
    key: "isJavaScript",
    value: function isJavaScript() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$allowParameters = _ref.allowParameters,
          allowParameters = _ref$allowParameters === void 0 ? false : _ref$allowParameters;

      switch (this._type) {
        case "text":
          {
            switch (this._subtype) {
              case "ecmascript":
              case "javascript":
              case "javascript1.0":
              case "javascript1.1":
              case "javascript1.2":
              case "javascript1.3":
              case "javascript1.4":
              case "javascript1.5":
              case "jscript":
              case "livescript":
              case "x-ecmascript":
              case "x-javascript":
                {
                  return allowParameters || this._parameters.size === 0;
                }

              default:
                {
                  return false;
                }
            }
          }

        case "application":
          {
            switch (this._subtype) {
              case "ecmascript":
              case "javascript":
              case "x-ecmascript":
              case "x-javascript":
                {
                  return allowParameters || this._parameters.size === 0;
                }

              default:
                {
                  return false;
                }
            }
          }

        default:
          {
            return false;
          }
      }
    }
  }, {
    key: "isXML",
    value: function isXML() {
      return this._subtype === "xml" && (this._type === "text" || this._type === "application") || this._subtype.endsWith("+xml");
    }
  }, {
    key: "isHTML",
    value: function isHTML() {
      return this._subtype === "html" && this._type === "text";
    }
  }, {
    key: "essence",
    get: function get() {
      return "".concat(this.type, "/").concat(this.subtype);
    }
  }, {
    key: "type",
    get: function get() {
      return this._type;
    },
    set: function set(value) {
      value = asciiLowercase(String(value));

      if (value.length === 0) {
        throw new Error("Invalid type: must be a non-empty string");
      }

      if (!solelyContainsHTTPTokenCodePoints(value)) {
        throw new Error("Invalid type ".concat(value, ": must contain only HTTP token code points"));
      }

      this._type = value;
    }
  }, {
    key: "subtype",
    get: function get() {
      return this._subtype;
    },
    set: function set(value) {
      value = asciiLowercase(String(value));

      if (value.length === 0) {
        throw new Error("Invalid subtype: must be a non-empty string");
      }

      if (!solelyContainsHTTPTokenCodePoints(value)) {
        throw new Error("Invalid subtype ".concat(value, ": must contain only HTTP token code points"));
      }

      this._subtype = value;
    }
  }, {
    key: "parameters",
    get: function get() {
      return this._parameters;
    }
  }], [{
    key: "parse",
    value: function parse(string) {
      try {
        return new this(string);
      } catch (e) {
        return null;
      }
    }
  }]);

  return MIMEType;
}();

var MIMETypeParameters =
/*#__PURE__*/
function () {
  function MIMETypeParameters(map) {
    _classCallCheck(this, MIMETypeParameters);

    this._map = map;
  }

  _createClass(MIMETypeParameters, [{
    key: "get",
    value: function get(name) {
      name = asciiLowercase(String(name));
      return this._map.get(name);
    }
  }, {
    key: "has",
    value: function has(name) {
      name = asciiLowercase(String(name));
      return this._map.has(name);
    }
  }, {
    key: "set",
    value: function set(name, value) {
      name = asciiLowercase(String(name));
      value = String(value);

      if (!solelyContainsHTTPTokenCodePoints(name)) {
        throw new Error("Invalid MIME type parameter name \"".concat(name, "\": only HTTP token code points are valid."));
      }

      if (!soleyContainsHTTPQuotedStringTokenCodePoints(value)) {
        throw new Error("Invalid MIME type parameter value \"".concat(value, "\": only HTTP quoted-string token code points are ") + "valid.");
      }

      return this._map.set(name, value);
    }
  }, {
    key: "clear",
    value: function clear() {
      this._map.clear();
    }
  }, {
    key: "delete",
    value: function _delete(name) {
      name = asciiLowercase(String(name));
      return this._map["delete"](name);
    }
  }, {
    key: "forEach",
    value: function forEach(callbackFn, thisArg) {
      this._map.forEach(callbackFn, thisArg);
    }
  }, {
    key: "keys",
    value: function keys() {
      return this._map.keys();
    }
  }, {
    key: "values",
    value: function values() {
      return this._map.values();
    }
  }, {
    key: "entries",
    value: function entries() {
      return this._map.entries();
    }
  }, {
    key: Symbol.iterator,
    value: function value() {
      return this._map[Symbol.iterator]();
    }
  }, {
    key: "size",
    get: function get() {
      return this._map.size;
    }
  }]);

  return MIMETypeParameters;
}();