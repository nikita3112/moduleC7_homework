'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.saveInlineSnapshots = saveInlineSnapshots;

var path = _interopRequireWildcard(require('path'));

var _types = require('@babel/types');

var fs = _interopRequireWildcard(require('graceful-fs'));

var _semver = _interopRequireDefault(require('semver'));

var _utils = require('./utils');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== 'function') return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var _Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;

var _Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;

var jestWriteFile = global[_Symbol["for"]('jest-native-write-file')] || fs.writeFileSync;

var _Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;

var jestReadFile = global[_Symbol["for"]('jest-native-read-file')] || fs.readFileSync;

function saveInlineSnapshots(snapshots, prettier, babelTraverse) {
  if (!prettier) {
    throw new Error("Jest: Inline Snapshots requires Prettier.\n" + "Please ensure \"prettier\" is installed in your project.");
  } // Custom parser API was added in 1.5.0


  if (_semver["default"].lt(prettier.version, '1.5.0')) {
    throw new Error("Jest: Inline Snapshots require prettier>=1.5.0.\n" + "Please upgrade \"prettier\".");
  }

  var snapshotsByFile = groupSnapshotsByFile(snapshots);

  for (var _i = 0, _Object$keys = Object.keys(snapshotsByFile); _i < _Object$keys.length; _i++) {
    var sourceFilePath = _Object$keys[_i];
    saveSnapshotsForFile(snapshotsByFile[sourceFilePath], sourceFilePath, prettier, babelTraverse);
  }
}

var saveSnapshotsForFile = function saveSnapshotsForFile(snapshots, sourceFilePath, prettier, babelTraverse) {
  var sourceFile = jestReadFile(sourceFilePath, 'utf8'); // Resolve project configuration.
  // For older versions of Prettier, do not load configuration.

  var config = prettier.resolveConfig ? prettier.resolveConfig.sync(sourceFilePath, {
    editorconfig: true
  }) : null; // Detect the parser for the test file.
  // For older versions of Prettier, fallback to a simple parser detection.
  // @ts-expect-error

  var inferredParser = prettier.getFileInfo ? prettier.getFileInfo.sync(sourceFilePath).inferredParser : config && config.parser || simpleDetectParser(sourceFilePath); // Record the matcher names seen in insertion parser and pass them down one
  // by one to formatting parser.

  var snapshotMatcherNames = []; // Insert snapshots using the custom parser API. After insertion, the code is
  // formatted, except snapshot indentation. Snapshots cannot be formatted until
  // after the initial format because we don't know where the call expression
  // will be placed (specifically its indentation).

  var newSourceFile = prettier.format(sourceFile, _objectSpread({}, config, {
    filepath: sourceFilePath,
    parser: createInsertionParser(snapshots, snapshotMatcherNames, inferredParser, babelTraverse)
  })); // Format the snapshots using the custom parser API.

  var formattedNewSourceFile = prettier.format(newSourceFile, _objectSpread({}, config, {
    filepath: sourceFilePath,
    parser: createFormattingParser(snapshotMatcherNames, inferredParser, babelTraverse)
  }));

  if (formattedNewSourceFile !== sourceFile) {
    jestWriteFile(sourceFilePath, formattedNewSourceFile);
  }
};

var groupSnapshotsBy = function groupSnapshotsBy(createKey) {
  return function (snapshots) {
    return snapshots.reduce(function (object, inlineSnapshot) {
      var key = createKey(inlineSnapshot);
      return _objectSpread({}, object, _defineProperty({}, key, (object[key] || []).concat(inlineSnapshot)));
    }, {});
  };
};

var groupSnapshotsByFrame = groupSnapshotsBy(function (_ref) {
  var _ref$frame = _ref.frame,
      line = _ref$frame.line,
      column = _ref$frame.column;
  return typeof line === 'number' && typeof column === 'number' ? "".concat(line, ":").concat(column - 1) : '';
});
var groupSnapshotsByFile = groupSnapshotsBy(function (_ref2) {
  var file = _ref2.frame.file;
  return file;
});

var indent = function indent(snapshot, numIndents, indentation) {
  var lines = snapshot.split('\n'); // Prevent re-indentation of inline snapshots.

  if (lines.length >= 2 && lines[1].startsWith(indentation.repeat(numIndents + 1))) {
    return snapshot;
  }

  return lines.map(function (line, index) {
    if (index === 0) {
      // First line is either a 1-line snapshot or a blank line.
      return line;
    } else if (index !== lines.length - 1) {
      // Do not indent empty lines.
      if (line === '') {
        return line;
      } // Not last line, indent one level deeper than expect call.


      return indentation.repeat(numIndents + 1) + line;
    } else {
      // The last line should be placed on the same level as the expect call.
      return indentation.repeat(numIndents) + line;
    }
  }).join('\n');
};

var getAst = function getAst(parsers, inferredParser, text) {
  // Flow uses a 'Program' parent node, babel expects a 'File'.
  var ast = parsers[inferredParser](text);

  if (ast.type !== 'File') {
    ast = (0, _types.file)(ast, ast.comments, ast.tokens);
    delete ast.program.comments;
  }

  return ast;
}; // This parser inserts snapshots into the AST.


var createInsertionParser = function createInsertionParser(snapshots, snapshotMatcherNames, inferredParser, babelTraverse) {
  return function (text, parsers, options) {
    // Workaround for https://github.com/prettier/prettier/issues/3150
    options.parser = inferredParser;
    var groupedSnapshots = groupSnapshotsByFrame(snapshots);
    var remainingSnapshots = new Set(snapshots.map(function (_ref3) {
      var snapshot = _ref3.snapshot;
      return snapshot;
    }));
    var ast = getAst(parsers, inferredParser, text);
    babelTraverse(ast, {
      CallExpression: function CallExpression(_ref4) {
        var _ref4$node = _ref4.node,
            args = _ref4$node.arguments,
            callee = _ref4$node.callee;

        if (callee.type !== 'MemberExpression' || callee.property.type !== 'Identifier' || callee.property.loc == null) {
          return;
        }

        var _callee$property$loc$ = callee.property.loc.start,
            line = _callee$property$loc$.line,
            column = _callee$property$loc$.column;
        var snapshotsForFrame = groupedSnapshots["".concat(line, ":").concat(column)];

        if (!snapshotsForFrame) {
          return;
        }

        if (snapshotsForFrame.length > 1) {
          throw new Error('Jest: Multiple inline snapshots for the same call are not supported.');
        }

        snapshotMatcherNames.push(callee.property.name);
        var snapshotIndex = args.findIndex(function (_ref5) {
          var type = _ref5.type;
          return type === 'TemplateLiteral';
        });
        var values = snapshotsForFrame.map(function (_ref6) {
          var snapshot = _ref6.snapshot;
          remainingSnapshots["delete"](snapshot);
          return (0, _types.templateLiteral)([(0, _types.templateElement)({
            raw: (0, _utils.escapeBacktickString)(snapshot)
          })], []);
        });
        var replacementNode = values[0];

        if (snapshotIndex > -1) {
          args[snapshotIndex] = replacementNode;
        } else {
          args.push(replacementNode);
        }
      }
    });

    if (remainingSnapshots.size) {
      throw new Error("Jest: Couldn't locate all inline snapshots.");
    }

    return ast;
  };
}; // This parser formats snapshots to the correct indentation.


var createFormattingParser = function createFormattingParser(snapshotMatcherNames, inferredParser, babelTraverse) {
  return function (text, parsers, options) {
    // Workaround for https://github.com/prettier/prettier/issues/3150
    options.parser = inferredParser;
    var ast = getAst(parsers, inferredParser, text);
    babelTraverse(ast, {
      CallExpression: function CallExpression(_ref7) {
        var _ref7$node = _ref7.node,
            args = _ref7$node.arguments,
            callee = _ref7$node.callee;

        var _options$tabWidth, _options$tabWidth2;

        if (callee.type !== 'MemberExpression' || callee.property.type !== 'Identifier' || !snapshotMatcherNames.includes(callee.property.name) || !callee.loc || callee.computed) {
          return;
        }

        var snapshotIndex;
        var snapshot;

        for (var i = 0; i < args.length; i++) {
          var node = args[i];

          if (node.type === 'TemplateLiteral') {
            snapshotIndex = i;
            snapshot = node.quasis[0].value.raw;
          }
        }

        if (snapshot === undefined || snapshotIndex === undefined) {
          return;
        }

        var useSpaces = !options.useTabs;
        snapshot = indent(snapshot, Math.ceil(useSpaces ? callee.loc.start.column / ((_options$tabWidth = options.tabWidth) !== null && _options$tabWidth !== void 0 ? _options$tabWidth : 1) : callee.loc.start.column / 2 // Each tab is 2 characters.
        ), useSpaces ? ' '.repeat((_options$tabWidth2 = options.tabWidth) !== null && _options$tabWidth2 !== void 0 ? _options$tabWidth2 : 1) : '\t');
        var replacementNode = (0, _types.templateLiteral)([(0, _types.templateElement)({
          raw: snapshot
        })], []);
        args[snapshotIndex] = replacementNode;
      }
    });
    return ast;
  };
};

var simpleDetectParser = function simpleDetectParser(filePath) {
  var extname = path.extname(filePath);

  if (/tsx?$/.test(extname)) {
    return 'typescript';
  }

  return 'babel';
};