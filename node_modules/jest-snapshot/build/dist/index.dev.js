'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var fs = _interopRequireWildcard(require('graceful-fs'));

var _jestMatcherUtils = require('jest-matcher-utils');

var _SnapshotResolver = require('./SnapshotResolver');

var _State = _interopRequireDefault(require('./State'));

var _plugins = require('./plugins');

var _printSnapshot = require('./printSnapshot');

var utils = _interopRequireWildcard(require('./utils'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== 'function') return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var _Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;

var _Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;

var jestExistsFile = global[_Symbol["for"]('jest-native-exists-file')] || fs.existsSync;
var DID_NOT_THROW = 'Received function did not throw'; // same as toThrow

var NOT_SNAPSHOT_MATCHERS = "Snapshot matchers cannot be used with ".concat((0, _jestMatcherUtils.BOLD_WEIGHT)('not'));
var INDENTATION_REGEX = /^([^\S\n]*)\S/m; // Display name in report when matcher fails same as in snapshot file,
// but with optional hint argument in bold weight.

var printSnapshotName = function printSnapshotName() {
  var concatenatedBlockNames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var hint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var count = arguments.length > 2 ? arguments[2] : undefined;
  var hasNames = concatenatedBlockNames.length !== 0;
  var hasHint = hint.length !== 0;
  return 'Snapshot name: `' + (hasNames ? utils.escapeBacktickString(concatenatedBlockNames) : '') + (hasNames && hasHint ? ': ' : '') + (hasHint ? (0, _jestMatcherUtils.BOLD_WEIGHT)(utils.escapeBacktickString(hint)) : '') + ' ' + count + '`';
};

function stripAddedIndentation(inlineSnapshot) {
  // Find indentation if exists.
  var match = inlineSnapshot.match(INDENTATION_REGEX);

  if (!match || !match[1]) {
    // No indentation.
    return inlineSnapshot;
  }

  var indentation = match[1];
  var lines = inlineSnapshot.split('\n');

  if (lines.length <= 2) {
    // Must be at least 3 lines.
    return inlineSnapshot;
  }

  if (lines[0].trim() !== '' || lines[lines.length - 1].trim() !== '') {
    // If not blank first and last lines, abort.
    return inlineSnapshot;
  }

  for (var i = 1; i < lines.length - 1; i++) {
    if (lines[i] !== '') {
      if (lines[i].indexOf(indentation) !== 0) {
        // All lines except first and last should either be blank or have the same
        // indent as the first line (or more). If this isn't the case we don't
        // want to touch the snapshot at all.
        return inlineSnapshot;
      }

      lines[i] = lines[i].substr(indentation.length);
    }
  } // Last line is a special case because it won't have the same indent as others
  // but may still have been given some indent to line up.


  lines[lines.length - 1] = ''; // Return inline snapshot, now at indent 0.

  inlineSnapshot = lines.join('\n');
  return inlineSnapshot;
}

var fileExists = function fileExists(filePath, hasteFS) {
  return hasteFS.exists(filePath) || jestExistsFile(filePath);
};

var cleanup = function cleanup(hasteFS, update, snapshotResolver, testPathIgnorePatterns) {
  var pattern = '\\.' + _SnapshotResolver.EXTENSION + '$';
  var files = hasteFS.matchFiles(pattern);
  var testIgnorePatternsRegex = null;

  if (testPathIgnorePatterns && testPathIgnorePatterns.length > 0) {
    testIgnorePatternsRegex = new RegExp(testPathIgnorePatterns.join('|'));
  }

  var list = files.filter(function (snapshotFile) {
    var testPath = snapshotResolver.resolveTestPath(snapshotFile); // ignore snapshots of ignored tests

    if (testIgnorePatternsRegex && testIgnorePatternsRegex.test(testPath)) {
      return false;
    }

    if (!fileExists(testPath, hasteFS)) {
      if (update === 'all') {
        fs.unlinkSync(snapshotFile);
      }

      return true;
    }

    return false;
  });
  return {
    filesRemoved: list.length,
    filesRemovedList: list
  };
};

var toMatchSnapshot = function toMatchSnapshot(received, propertiesOrHint, hint) {
  var matcherName = 'toMatchSnapshot';
  var properties;
  var length = arguments.length;

  if (length === 2 && typeof propertiesOrHint === 'string') {
    hint = propertiesOrHint;
  } else if (length >= 2) {
    if (_typeof(propertiesOrHint) !== 'object' || propertiesOrHint === null) {
      var options = {
        isNot: this.isNot,
        promise: this.promise
      };
      var printedWithType = (0, _jestMatcherUtils.printWithType)('Expected properties', propertiesOrHint, _printSnapshot.printExpected);

      if (length === 3) {
        options.secondArgument = 'hint';
        options.secondArgumentColor = _jestMatcherUtils.BOLD_WEIGHT;

        if (propertiesOrHint == null) {
          printedWithType += "\n\nTo provide a hint without properties: toMatchSnapshot('hint')";
        }
      }

      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, _printSnapshot.PROPERTIES_ARG, options), "Expected ".concat((0, _jestMatcherUtils.EXPECTED_COLOR)('properties'), " must be an object"), printedWithType));
    } // Future breaking change: Snapshot hint must be a string
    // if (arguments.length === 3 && typeof hint !== 'string') {}


    properties = propertiesOrHint;
  }

  return _toMatchSnapshot({
    context: this,
    hint: hint,
    isInline: false,
    matcherName: matcherName,
    properties: properties,
    received: received
  });
};

var toMatchInlineSnapshot = function toMatchInlineSnapshot(received, propertiesOrSnapshot, inlineSnapshot) {
  var matcherName = 'toMatchInlineSnapshot';
  var properties;
  var length = arguments.length;

  if (length === 2 && typeof propertiesOrSnapshot === 'string') {
    inlineSnapshot = propertiesOrSnapshot;
  } else if (length >= 2) {
    var options = {
      isNot: this.isNot,
      promise: this.promise
    };

    if (length === 3) {
      options.secondArgument = _printSnapshot.SNAPSHOT_ARG;
      options.secondArgumentColor = _printSnapshot.noColor;
    }

    if (_typeof(propertiesOrSnapshot) !== 'object' || propertiesOrSnapshot === null) {
      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, _printSnapshot.PROPERTIES_ARG, options), "Expected ".concat((0, _jestMatcherUtils.EXPECTED_COLOR)('properties'), " must be an object"), (0, _jestMatcherUtils.printWithType)('Expected properties', propertiesOrSnapshot, _printSnapshot.printExpected)));
    }

    if (length === 3 && typeof inlineSnapshot !== 'string') {
      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, _printSnapshot.PROPERTIES_ARG, options), "Inline snapshot must be a string", (0, _jestMatcherUtils.printWithType)('Inline snapshot', inlineSnapshot, utils.serialize)));
    }

    properties = propertiesOrSnapshot;
  }

  return _toMatchSnapshot({
    context: this,
    inlineSnapshot: inlineSnapshot !== undefined ? stripAddedIndentation(inlineSnapshot) : undefined,
    isInline: true,
    matcherName: matcherName,
    properties: properties,
    received: received
  });
};

var _toMatchSnapshot = function _toMatchSnapshot(config) {
  var context = config.context,
      hint = config.hint,
      inlineSnapshot = config.inlineSnapshot,
      isInline = config.isInline,
      matcherName = config.matcherName,
      properties = config.properties;
  var received = config.received;
  context.dontThrow && context.dontThrow();
  var currentTestName = context.currentTestName,
      isNot = context.isNot,
      snapshotState = context.snapshotState;

  if (isNot) {
    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _printSnapshot.matcherHintFromConfig)(config, false), NOT_SNAPSHOT_MATCHERS));
  }

  if (snapshotState == null) {
    // Because the state is the problem, this is not a matcher error.
    // Call generic stringify from jest-matcher-utils package
    // because uninitialized snapshot state does not need snapshot serializers.
    throw new Error((0, _printSnapshot.matcherHintFromConfig)(config, false) + '\n\n' + "Snapshot state must be initialized" + '\n\n' + (0, _jestMatcherUtils.printWithType)('Snapshot state', snapshotState, _jestMatcherUtils.stringify));
  }

  var fullTestName = currentTestName && hint ? "".concat(currentTestName, ": ").concat(hint) : currentTestName || ''; // future BREAKING change: || hint

  if (_typeof(properties) === 'object') {
    if (_typeof(received) !== 'object' || received === null) {
      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _printSnapshot.matcherHintFromConfig)(config, false), "".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), " value must be an object when the matcher has ").concat((0, _jestMatcherUtils.EXPECTED_COLOR)('properties')), (0, _jestMatcherUtils.printWithType)('Received', received, _printSnapshot.printReceived)));
    }

    var propertyPass = context.equals(received, properties, [context.utils.iterableEquality, context.utils.subsetEquality]);

    if (!propertyPass) {
      var key = snapshotState.fail(fullTestName, received);
      var matched = /(\d+)$/.exec(key);

      var _count = matched === null ? 1 : Number(matched[1]);

      var _message = function _message() {
        return (0, _printSnapshot.matcherHintFromConfig)(config, false) + '\n\n' + printSnapshotName(currentTestName, hint, _count) + '\n\n' + (0, _printSnapshot.printPropertiesAndReceived)(properties, received, snapshotState.expand);
      };

      return {
        message: _message,
        name: matcherName,
        pass: false
      };
    } else {
      received = utils.deepMerge(received, properties);
    }
  }

  var result = snapshotState.match({
    error: context.error,
    inlineSnapshot: inlineSnapshot,
    isInline: isInline,
    received: received,
    testName: fullTestName
  });
  var actual = result.actual,
      count = result.count,
      expected = result.expected,
      pass = result.pass;

  if (pass) {
    return {
      message: function message() {
        return '';
      },
      pass: true
    };
  }

  var message = expected === undefined ? function () {
    return (0, _printSnapshot.matcherHintFromConfig)(config, true) + '\n\n' + printSnapshotName(currentTestName, hint, count) + '\n\n' + "New snapshot was ".concat((0, _jestMatcherUtils.BOLD_WEIGHT)('not written'), ". The update flag ") + "must be explicitly passed to write a new snapshot.\n\n" + "This is likely because this test is run in a continuous integration " + "(CI) environment in which snapshots are not written by default.\n\n" + "Received:".concat(actual.includes('\n') ? '\n' : ' ').concat((0, _printSnapshot.bReceivedColor)(actual));
  } : function () {
    return (0, _printSnapshot.matcherHintFromConfig)(config, true) + '\n\n' + printSnapshotName(currentTestName, hint, count) + '\n\n' + (0, _printSnapshot.printSnapshotAndReceived)(expected, actual, received, snapshotState.expand);
  }; // Passing the actual and expected objects so that a custom reporter
  // could access them, for example in order to display a custom visual diff,
  // or create a different error message

  return {
    actual: actual,
    expected: expected,
    message: message,
    name: matcherName,
    pass: false
  };
};

var toThrowErrorMatchingSnapshot = function toThrowErrorMatchingSnapshot(received, hint, // because error TS1016 for hint?: string
fromPromise) {
  var matcherName = 'toThrowErrorMatchingSnapshot'; // Future breaking change: Snapshot hint must be a string
  // if (hint !== undefined && typeof hint !== string) {}

  return _toThrowErrorMatchingSnapshot({
    context: this,
    hint: hint,
    isInline: false,
    matcherName: matcherName,
    received: received
  }, fromPromise);
};

var toThrowErrorMatchingInlineSnapshot = function toThrowErrorMatchingInlineSnapshot(received, inlineSnapshot, fromPromise) {
  var matcherName = 'toThrowErrorMatchingInlineSnapshot';

  if (inlineSnapshot !== undefined && typeof inlineSnapshot !== 'string') {
    var options = {
      expectedColor: _printSnapshot.noColor,
      isNot: this.isNot,
      promise: this.promise
    };
    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, _printSnapshot.SNAPSHOT_ARG, options), "Inline snapshot must be a string", (0, _jestMatcherUtils.printWithType)('Inline snapshot', inlineSnapshot, utils.serialize)));
  }

  return _toThrowErrorMatchingSnapshot({
    context: this,
    inlineSnapshot: inlineSnapshot !== undefined ? stripAddedIndentation(inlineSnapshot) : undefined,
    isInline: true,
    matcherName: matcherName,
    received: received
  }, fromPromise);
};

var _toThrowErrorMatchingSnapshot = function _toThrowErrorMatchingSnapshot(config, fromPromise) {
  var context = config.context,
      hint = config.hint,
      inlineSnapshot = config.inlineSnapshot,
      isInline = config.isInline,
      matcherName = config.matcherName,
      received = config.received;
  context.dontThrow && context.dontThrow();
  var isNot = context.isNot,
      promise = context.promise;

  if (!fromPromise) {
    if (typeof received !== 'function') {
      var options = {
        isNot: isNot,
        promise: promise
      };
      throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _jestMatcherUtils.matcherHint)(matcherName, undefined, '', options), "".concat((0, _jestMatcherUtils.RECEIVED_COLOR)('received'), " value must be a function"), (0, _jestMatcherUtils.printWithType)('Received', received, _printSnapshot.printReceived)));
    }
  }

  if (isNot) {
    throw new Error((0, _jestMatcherUtils.matcherErrorMessage)((0, _printSnapshot.matcherHintFromConfig)(config, false), NOT_SNAPSHOT_MATCHERS));
  }

  var error;

  if (fromPromise) {
    error = received;
  } else {
    try {
      received();
    } catch (e) {
      error = e;
    }
  }

  if (error === undefined) {
    // Because the received value is a function, this is not a matcher error.
    throw new Error((0, _printSnapshot.matcherHintFromConfig)(config, false) + '\n\n' + DID_NOT_THROW);
  }

  return _toMatchSnapshot({
    context: context,
    hint: hint,
    inlineSnapshot: inlineSnapshot,
    isInline: isInline,
    matcherName: matcherName,
    received: error.message
  });
};

var JestSnapshot = {
  EXTENSION: _SnapshotResolver.EXTENSION,
  SnapshotState: _State["default"],
  addSerializer: _plugins.addSerializer,
  buildSnapshotResolver: _SnapshotResolver.buildSnapshotResolver,
  cleanup: cleanup,
  getSerializers: _plugins.getSerializers,
  isSnapshotPath: _SnapshotResolver.isSnapshotPath,
  toMatchInlineSnapshot: toMatchInlineSnapshot,
  toMatchSnapshot: toMatchSnapshot,
  toThrowErrorMatchingInlineSnapshot: toThrowErrorMatchingInlineSnapshot,
  toThrowErrorMatchingSnapshot: toThrowErrorMatchingSnapshot,
  utils: utils
};
module.exports = JestSnapshot;