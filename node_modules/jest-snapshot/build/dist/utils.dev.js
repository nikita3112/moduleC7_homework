'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, '__esModule', {
  value: true
});
exports.deepMerge = exports.saveSnapshotFile = exports.ensureDirectoryExists = exports.escapeBacktickString = exports.deserializeString = exports.minify = exports.serialize = exports.removeLinesBeforeExternalMatcherTrap = exports.removeExtraLineBreaks = exports.addExtraLineBreaks = exports.getSnapshotData = exports.keyToTestName = exports.testNameToKey = exports.SNAPSHOT_VERSION_WARNING = exports.SNAPSHOT_GUIDE_LINK = exports.SNAPSHOT_VERSION = void 0;

var path = _interopRequireWildcard(require('path'));

var _chalk = _interopRequireDefault(require('chalk'));

var fs = _interopRequireWildcard(require('graceful-fs'));

var _naturalCompare = _interopRequireDefault(require('natural-compare'));

var _prettyFormat = _interopRequireDefault(require('pretty-format'));

var _plugins = require('./plugins');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== 'function') return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

var _Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;

var _Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;

var jestWriteFile = global[_Symbol["for"]('jest-native-write-file')] || fs.writeFileSync;

var _Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;

var jestReadFile = global[_Symbol["for"]('jest-native-read-file')] || fs.readFileSync;

var _Symbol = global['jest-symbol-do-not-touch'] || global.Symbol;

var jestExistsFile = global[_Symbol["for"]('jest-native-exists-file')] || fs.existsSync;
var SNAPSHOT_VERSION = '1';
exports.SNAPSHOT_VERSION = SNAPSHOT_VERSION;
var SNAPSHOT_VERSION_REGEXP = /^\/\/ Jest Snapshot v(.+),/;
var SNAPSHOT_GUIDE_LINK = 'https://goo.gl/fbAQLP';
exports.SNAPSHOT_GUIDE_LINK = SNAPSHOT_GUIDE_LINK;

var SNAPSHOT_VERSION_WARNING = _chalk["default"].yellow("".concat(_chalk["default"].bold('Warning'), ": Before you upgrade snapshots, ") + "we recommend that you revert any local changes to tests or other code, " + "to ensure that you do not store invalid state.");

exports.SNAPSHOT_VERSION_WARNING = SNAPSHOT_VERSION_WARNING;

var writeSnapshotVersion = function writeSnapshotVersion() {
  return "// Jest Snapshot v".concat(SNAPSHOT_VERSION, ", ").concat(SNAPSHOT_GUIDE_LINK);
};

var validateSnapshotVersion = function validateSnapshotVersion(snapshotContents) {
  var versionTest = SNAPSHOT_VERSION_REGEXP.exec(snapshotContents);
  var version = versionTest && versionTest[1];

  if (!version) {
    return new Error(_chalk["default"].red("".concat(_chalk["default"].bold('Outdated snapshot'), ": No snapshot header found. ") + "Jest 19 introduced versioned snapshots to ensure all developers " + "on a project are using the same version of Jest. " + "Please update all snapshots during this upgrade of Jest.\n\n") + SNAPSHOT_VERSION_WARNING);
  }

  if (version < SNAPSHOT_VERSION) {
    return new Error(_chalk["default"].red("".concat(_chalk["default"].red.bold('Outdated snapshot'), ": The version of the snapshot ") + "file associated with this test is outdated. The snapshot file " + "version ensures that all developers on a project are using " + "the same version of Jest. " + "Please update all snapshots during this upgrade of Jest.\n\n") + "Expected: v".concat(SNAPSHOT_VERSION, "\n") + "Received: v".concat(version, "\n\n") + SNAPSHOT_VERSION_WARNING);
  }

  if (version > SNAPSHOT_VERSION) {
    return new Error(_chalk["default"].red("".concat(_chalk["default"].red.bold('Outdated Jest version'), ": The version of this ") + "snapshot file indicates that this project is meant to be used " + "with a newer version of Jest. The snapshot file version ensures " + "that all developers on a project are using the same version of " + "Jest. Please update your version of Jest and re-run the tests.\n\n") + "Expected: v".concat(SNAPSHOT_VERSION, "\n") + "Received: v".concat(version));
  }

  return null;
};

function isObject(item) {
  return item && _typeof(item) === 'object' && !Array.isArray(item);
}

var testNameToKey = function testNameToKey(testName, count) {
  return testName + ' ' + count;
};

exports.testNameToKey = testNameToKey;

var keyToTestName = function keyToTestName(key) {
  if (!/ \d+$/.test(key)) {
    throw new Error('Snapshot keys must end with a number.');
  }

  return key.replace(/ \d+$/, '');
};

exports.keyToTestName = keyToTestName;

var getSnapshotData = function getSnapshotData(snapshotPath, update) {
  var data = Object.create(null);
  var snapshotContents = '';
  var dirty = false;

  if (jestExistsFile(snapshotPath)) {
    try {
      snapshotContents = jestReadFile(snapshotPath, 'utf8'); // eslint-disable-next-line no-new-func

      var populate = new Function('exports', snapshotContents);
      populate(data);
    } catch (_unused) {}
  }

  var validationResult = validateSnapshotVersion(snapshotContents);
  var isInvalid = snapshotContents && validationResult;

  if (update === 'none' && isInvalid) {
    throw validationResult;
  }

  if ((update === 'all' || update === 'new') && isInvalid) {
    dirty = true;
  }

  return {
    data: data,
    dirty: dirty
  };
}; // Add extra line breaks at beginning and end of multiline snapshot
// to make the content easier to read.


exports.getSnapshotData = getSnapshotData;

var addExtraLineBreaks = function addExtraLineBreaks(string) {
  return string.includes('\n') ? "\n".concat(string, "\n") : string;
}; // Remove extra line breaks at beginning and end of multiline snapshot.
// Instead of trim, which can remove additional newlines or spaces
// at beginning or end of the content from a custom serializer.


exports.addExtraLineBreaks = addExtraLineBreaks;

var removeExtraLineBreaks = function removeExtraLineBreaks(string) {
  return string.length > 2 && string.startsWith('\n') && string.endsWith('\n') ? string.slice(1, -1) : string;
};

exports.removeExtraLineBreaks = removeExtraLineBreaks;

var removeLinesBeforeExternalMatcherTrap = function removeLinesBeforeExternalMatcherTrap(stack) {
  var lines = stack.split('\n');

  for (var i = 0; i < lines.length; i += 1) {
    // It's a function name specified in `packages/expect/src/index.ts`
    // for external custom matchers.
    if (lines[i].includes('__EXTERNAL_MATCHER_TRAP__')) {
      return lines.slice(i + 1).join('\n');
    }
  }

  return stack;
};

exports.removeLinesBeforeExternalMatcherTrap = removeLinesBeforeExternalMatcherTrap;
var escapeRegex = true;
var printFunctionName = false;

var serialize = function serialize(val) {
  var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
  return normalizeNewlines((0, _prettyFormat["default"])(val, {
    escapeRegex: escapeRegex,
    indent: indent,
    plugins: (0, _plugins.getSerializers)(),
    printFunctionName: printFunctionName
  }));
};

exports.serialize = serialize;

var minify = function minify(val) {
  return (0, _prettyFormat["default"])(val, {
    escapeRegex: escapeRegex,
    min: true,
    plugins: (0, _plugins.getSerializers)(),
    printFunctionName: printFunctionName
  });
}; // Remove double quote marks and unescape double quotes and backslashes.


exports.minify = minify;

var deserializeString = function deserializeString(stringified) {
  return stringified.slice(1, -1).replace(/\\("|\\)/g, '$1');
};

exports.deserializeString = deserializeString;

var escapeBacktickString = function escapeBacktickString(str) {
  return str.replace(/`|\\|\${/g, '\\$&');
};

exports.escapeBacktickString = escapeBacktickString;

var printBacktickString = function printBacktickString(str) {
  return '`' + escapeBacktickString(str) + '`';
};

var ensureDirectoryExists = function ensureDirectoryExists(filePath) {
  try {
    fs.mkdirSync(path.join(path.dirname(filePath)), {
      recursive: true
    });
  } catch (_unused2) {}
};

exports.ensureDirectoryExists = ensureDirectoryExists;

var normalizeNewlines = function normalizeNewlines(string) {
  return string.replace(/\r\n|\r/g, '\n');
};

var saveSnapshotFile = function saveSnapshotFile(snapshotData, snapshotPath) {
  var snapshots = Object.keys(snapshotData).sort(_naturalCompare["default"]).map(function (key) {
    return 'exports[' + printBacktickString(key) + '] = ' + printBacktickString(normalizeNewlines(snapshotData[key])) + ';';
  });
  ensureDirectoryExists(snapshotPath);
  jestWriteFile(snapshotPath, writeSnapshotVersion() + '\n\n' + snapshots.join('\n\n') + '\n');
};

exports.saveSnapshotFile = saveSnapshotFile;

var deepMergeArray = function deepMergeArray(target, source) {
  var mergedOutput = Array.from(target);
  source.forEach(function (sourceElement, index) {
    var targetElement = mergedOutput[index];

    if (Array.isArray(target[index])) {
      mergedOutput[index] = deepMergeArray(target[index], sourceElement);
    } else if (isObject(targetElement)) {
      mergedOutput[index] = deepMerge(target[index], sourceElement);
    } else {
      // Source does not exist in target or target is primitive and cannot be deep merged
      mergedOutput[index] = sourceElement;
    }
  });
  return mergedOutput;
}; // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types


var deepMerge = function deepMerge(target, source) {
  if (isObject(target) && isObject(source)) {
    var mergedOutput = _objectSpread({}, target);

    Object.keys(source).forEach(function (key) {
      if (isObject(source[key]) && !source[key].$$typeof) {
        if (!(key in target)) Object.assign(mergedOutput, _defineProperty({}, key, source[key]));else mergedOutput[key] = deepMerge(target[key], source[key]);
      } else if (Array.isArray(source[key])) {
        mergedOutput[key] = deepMergeArray(target[key], source[key]);
      } else {
        Object.assign(mergedOutput, _defineProperty({}, key, source[key]));
      }
    });
    return mergedOutput;
  } else if (Array.isArray(target) && Array.isArray(source)) {
    return deepMergeArray(target, source);
  }

  return target;
};

exports.deepMerge = deepMerge;