"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _path = _interopRequireDefault(require("path"));

var _fs = require("fs");

var _child_process = require("child_process");

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _istanbulLibInstrument = require("istanbul-lib-instrument");

var _testExclude = _interopRequireDefault(require("test-exclude"));

var _schema = _interopRequireDefault(require("@istanbuljs/schema"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function getRealpath(n) {
  try {
    return (0, _fs.realpathSync)(n) ||
    /* istanbul ignore next */
    n;
  } catch (e) {
    /* istanbul ignore next */
    return n;
  }
}

var memoize = new Map();
/* istanbul ignore next */

var memosep = _path["default"].sep === '/' ? ':' : ';';

function loadNycConfig(cwd, opts) {
  var memokey = cwd;
  var args = [_path["default"].resolve(__dirname, 'load-nyc-config-sync.js'), cwd];

  if ('nycrcPath' in opts) {
    args.push(opts.nycrcPath);
    memokey += memosep + opts.nycrcPath;
  }
  /* execFileSync is expensive, avoid it if possible! */


  if (memoize.has(memokey)) {
    return memoize.get(memokey);
  }

  var result = JSON.parse((0, _child_process.execFileSync)(process.execPath, args));
  var error = result['load-nyc-config-sync-error'];

  if (error) {
    throw new Error(error);
  }

  var config = _objectSpread({}, _schema["default"].defaults.babelPluginIstanbul, {
    cwd: cwd
  }, result);

  memoize.set(memokey, config);
  return config;
}

function findConfig(opts) {
  var cwd = getRealpath(opts.cwd || process.env.NYC_CWD ||
  /* istanbul ignore next */
  process.cwd());
  var keys = Object.keys(opts);
  var ignored = Object.keys(opts).filter(function (s) {
    return s === 'nycrcPath' || s === 'cwd';
  });

  if (keys.length > ignored.length) {
    // explicitly configuring options in babel
    // takes precedence.
    return _objectSpread({}, _schema["default"].defaults.babelPluginIstanbul, {
      cwd: cwd
    }, opts);
  }

  if (ignored.length === 0 && process.env.NYC_CONFIG) {
    // defaults were already applied by nyc
    return JSON.parse(process.env.NYC_CONFIG);
  }

  return loadNycConfig(cwd, opts);
}

function makeShouldSkip() {
  var exclude;
  return function shouldSkip(file, nycConfig) {
    if (!exclude || exclude.cwd !== nycConfig.cwd) {
      exclude = new _testExclude["default"]({
        cwd: nycConfig.cwd,
        include: nycConfig.include,
        exclude: nycConfig.exclude,
        extension: nycConfig.extension,
        // Make sure this is true unless explicitly set to `false`. `undefined` is still `true`.
        excludeNodeModules: nycConfig.excludeNodeModules !== false
      });
    }

    return !exclude.shouldInstrument(file);
  };
}

var _default = (0, _helperPluginUtils.declare)(function (api) {
  api.assertVersion(7);
  var shouldSkip = makeShouldSkip();
  var t = api.types;
  return {
    visitor: {
      Program: {
        enter: function enter(path) {
          var _this = this;

          this.__dv__ = null;
          this.nycConfig = findConfig(this.opts);
          var realPath = getRealpath(this.file.opts.filename);

          if (shouldSkip(realPath, this.nycConfig)) {
            return;
          }

          var inputSourceMap = this.opts.inputSourceMap;

          if (this.opts.useInlineSourceMaps !== false) {
            if (!inputSourceMap && this.file.inputMap) {
              inputSourceMap = this.file.inputMap.sourcemap;
            }
          }

          var visitorOptions = {};
          Object.entries(_schema["default"].defaults.instrumentVisitor).forEach(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
                name = _ref2[0],
                defaultValue = _ref2[1];

            if (name in _this.nycConfig) {
              visitorOptions[name] = _this.nycConfig[name];
            } else {
              visitorOptions[name] = _schema["default"].defaults.instrumentVisitor[name];
            }
          });
          this.__dv__ = (0, _istanbulLibInstrument.programVisitor)(t, realPath, _objectSpread({}, visitorOptions, {
            inputSourceMap: inputSourceMap
          }));

          this.__dv__.enter(path);
        },
        exit: function exit(path) {
          if (!this.__dv__) {
            return;
          }

          var result = this.__dv__.exit(path);

          if (this.opts.onCover) {
            this.opts.onCover(getRealpath(this.file.opts.filename), result.fileCoverage);
          }
        }
      }
    }
  };
});

exports["default"] = _default;