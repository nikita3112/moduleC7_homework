/*
 Copyright 2012-2015, Yahoo Inc.
 Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var _require = require('./file-coverage'),
    FileCoverage = _require.FileCoverage;

var _require2 = require('./coverage-summary'),
    CoverageSummary = _require2.CoverageSummary;

function maybeConstruct(obj, klass) {
  if (obj instanceof klass) {
    return obj;
  }

  return new klass(obj);
}

function loadMap(source) {
  var data = Object.create(null);

  if (!source) {
    return data;
  }

  Object.entries(source).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        k = _ref2[0],
        cov = _ref2[1];

    data[k] = maybeConstruct(cov, FileCoverage);
  });
  return data;
}
/** CoverageMap is a map of `FileCoverage` objects keyed by file paths. */


var CoverageMap =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {Object} [obj=undefined] obj A coverage map from which to initialize this
   * map's contents. This can be the raw global coverage object.
   */
  function CoverageMap(obj) {
    _classCallCheck(this, CoverageMap);

    if (obj instanceof CoverageMap) {
      this.data = obj.data;
    } else {
      this.data = loadMap(obj);
    }
  }
  /**
   * merges a second coverage map into this one
   * @param {CoverageMap} obj - a CoverageMap or its raw data. Coverage is merged
   *  correctly for the same files and additional file coverage keys are created
   *  as needed.
   */


  _createClass(CoverageMap, [{
    key: "merge",
    value: function merge(obj) {
      var _this = this;

      var other = maybeConstruct(obj, CoverageMap);
      Object.values(other.data).forEach(function (fc) {
        _this.addFileCoverage(fc);
      });
    }
    /**
     * filter the coveragemap based on the callback provided
     * @param {Function (filename)} callback - Returns true if the path
     *  should be included in the coveragemap. False if it should be
     *  removed.
     */

  }, {
    key: "filter",
    value: function filter(callback) {
      var _this2 = this;

      Object.keys(this.data).forEach(function (k) {
        if (!callback(k)) {
          delete _this2.data[k];
        }
      });
    }
    /**
     * returns a JSON-serializable POJO for this coverage map
     * @returns {Object}
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
    /**
     * returns an array for file paths for which this map has coverage
     * @returns {Array{string}} - array of files
     */

  }, {
    key: "files",
    value: function files() {
      return Object.keys(this.data);
    }
    /**
     * returns the file coverage for the specified file.
     * @param {String} file
     * @returns {FileCoverage}
     */

  }, {
    key: "fileCoverageFor",
    value: function fileCoverageFor(file) {
      var fc = this.data[file];

      if (!fc) {
        throw new Error("No file coverage available for: ".concat(file));
      }

      return fc;
    }
    /**
     * adds a file coverage object to this map. If the path for the object,
     * already exists in the map, it is merged with the existing coverage
     * otherwise a new key is added to the map.
     * @param {FileCoverage} fc the file coverage to add
     */

  }, {
    key: "addFileCoverage",
    value: function addFileCoverage(fc) {
      var cov = new FileCoverage(fc);
      var path = cov.path;

      if (this.data[path]) {
        this.data[path].merge(cov);
      } else {
        this.data[path] = cov;
      }
    }
    /**
     * returns the coverage summary for all the file coverage objects in this map.
     * @returns {CoverageSummary}
     */

  }, {
    key: "getCoverageSummary",
    value: function getCoverageSummary() {
      var ret = new CoverageSummary();
      Object.values(this.data).forEach(function (fc) {
        ret.merge(fc.toSummary());
      });
      return ret;
    }
  }]);

  return CoverageMap;
}();

module.exports = {
  CoverageMap: CoverageMap
};