/*
 Copyright 2012-2015, Yahoo Inc.
 Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var percent = require('./percent');

var dataProperties = require('./data-properties');

var _require = require('./coverage-summary'),
    CoverageSummary = _require.CoverageSummary; // returns a data object that represents empty coverage


function emptyCoverage(filePath) {
  return {
    path: filePath,
    statementMap: {},
    fnMap: {},
    branchMap: {},
    s: {},
    f: {},
    b: {}
  };
} // asserts that a data object "looks like" a coverage object


function assertValidObject(obj) {
  var valid = obj && obj.path && obj.statementMap && obj.fnMap && obj.branchMap && obj.s && obj.f && obj.b;

  if (!valid) {
    throw new Error('Invalid file coverage object, missing keys, found:' + Object.keys(obj).join(','));
  }
}
/**
 * provides a read-only view of coverage for a single file.
 * The deep structure of this object is documented elsewhere. It has the following
 * properties:
 *
 * * `path` - the file path for which coverage is being tracked
 * * `statementMap` - map of statement locations keyed by statement index
 * * `fnMap` - map of function metadata keyed by function index
 * * `branchMap` - map of branch metadata keyed by branch index
 * * `s` - hit counts for statements
 * * `f` - hit count for functions
 * * `b` - hit count for branches
 */


var FileCoverage =
/*#__PURE__*/
function () {
  /**
   * @constructor
   * @param {Object|FileCoverage|String} pathOrObj is a string that initializes
   * and empty coverage object with the specified file path or a data object that
   * has all the required properties for a file coverage object.
   */
  function FileCoverage(pathOrObj) {
    _classCallCheck(this, FileCoverage);

    if (!pathOrObj) {
      throw new Error('Coverage must be initialized with a path or an object');
    }

    if (typeof pathOrObj === 'string') {
      this.data = emptyCoverage(pathOrObj);
    } else if (pathOrObj instanceof FileCoverage) {
      this.data = pathOrObj.data;
    } else if (_typeof(pathOrObj) === 'object') {
      this.data = pathOrObj;
    } else {
      throw new Error('Invalid argument to coverage constructor');
    }

    assertValidObject(this.data);
  }
  /**
   * returns computed line coverage from statement coverage.
   * This is a map of hits keyed by line number in the source.
   */


  _createClass(FileCoverage, [{
    key: "getLineCoverage",
    value: function getLineCoverage() {
      var statementMap = this.data.statementMap;
      var statements = this.data.s;
      var lineMap = Object.create(null);
      Object.entries(statements).forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            st = _ref2[0],
            count = _ref2[1];

        /* istanbul ignore if: is this even possible? */
        if (!statementMap[st]) {
          return;
        }

        var line = statementMap[st].start.line;
        var prevVal = lineMap[line];

        if (prevVal === undefined || prevVal < count) {
          lineMap[line] = count;
        }
      });
      return lineMap;
    }
    /**
     * returns an array of uncovered line numbers.
     * @returns {Array} an array of line numbers for which no hits have been
     *  collected.
     */

  }, {
    key: "getUncoveredLines",
    value: function getUncoveredLines() {
      var lc = this.getLineCoverage();
      var ret = [];
      Object.entries(lc).forEach(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            l = _ref4[0],
            hits = _ref4[1];

        if (hits === 0) {
          ret.push(l);
        }
      });
      return ret;
    }
    /**
     * returns a map of branch coverage by source line number.
     * @returns {Object} an object keyed by line number. Each object
     * has a `covered`, `total` and `coverage` (percentage) property.
     */

  }, {
    key: "getBranchCoverageByLine",
    value: function getBranchCoverageByLine() {
      var branchMap = this.branchMap;
      var branches = this.b;
      var ret = {};
      Object.entries(branchMap).forEach(function (_ref5) {
        var _ret$line;

        var _ref6 = _slicedToArray(_ref5, 2),
            k = _ref6[0],
            map = _ref6[1];

        var line = map.line || map.loc.start.line;
        var branchData = branches[k];
        ret[line] = ret[line] || [];

        (_ret$line = ret[line]).push.apply(_ret$line, _toConsumableArray(branchData));
      });
      Object.entries(ret).forEach(function (_ref7) {
        var _ref8 = _slicedToArray(_ref7, 2),
            k = _ref8[0],
            dataArray = _ref8[1];

        var covered = dataArray.filter(function (item) {
          return item > 0;
        });
        var coverage = covered.length / dataArray.length * 100;
        ret[k] = {
          covered: covered.length,
          total: dataArray.length,
          coverage: coverage
        };
      });
      return ret;
    }
    /**
     * return a JSON-serializable POJO for this file coverage object
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
    /**
     * merges a second coverage object into this one, updating hit counts
     * @param {FileCoverage} other - the coverage object to be merged into this one.
     *  Note that the other object should have the same structure as this one (same file).
     */

  }, {
    key: "merge",
    value: function merge(other) {
      var _this = this;

      if (other.all === true) {
        return;
      }

      if (this.all === true) {
        this.data = other.data;
        return;
      }

      Object.entries(other.s).forEach(function (_ref9) {
        var _ref10 = _slicedToArray(_ref9, 2),
            k = _ref10[0],
            v = _ref10[1];

        _this.data.s[k] += v;
      });
      Object.entries(other.f).forEach(function (_ref11) {
        var _ref12 = _slicedToArray(_ref11, 2),
            k = _ref12[0],
            v = _ref12[1];

        _this.data.f[k] += v;
      });
      Object.entries(other.b).forEach(function (_ref13) {
        var _ref14 = _slicedToArray(_ref13, 2),
            k = _ref14[0],
            v = _ref14[1];

        var i;
        var retArray = _this.data.b[k];
        /* istanbul ignore if: is this even possible? */

        if (!retArray) {
          _this.data.b[k] = v;
          return;
        }

        for (i = 0; i < retArray.length; i += 1) {
          retArray[i] += v[i];
        }
      });
    }
  }, {
    key: "computeSimpleTotals",
    value: function computeSimpleTotals(property) {
      var stats = this[property];

      if (typeof stats === 'function') {
        stats = stats.call(this);
      }

      var ret = {
        total: Object.keys(stats).length,
        covered: Object.values(stats).filter(function (v) {
          return !!v;
        }).length,
        skipped: 0
      };
      ret.pct = percent(ret.covered, ret.total);
      return ret;
    }
  }, {
    key: "computeBranchTotals",
    value: function computeBranchTotals() {
      var stats = this.b;
      var ret = {
        total: 0,
        covered: 0,
        skipped: 0
      };
      Object.values(stats).forEach(function (branches) {
        ret.covered += branches.filter(function (hits) {
          return hits > 0;
        }).length;
        ret.total += branches.length;
      });
      ret.pct = percent(ret.covered, ret.total);
      return ret;
    }
    /**
     * resets hit counts for all statements, functions and branches
     * in this coverage object resulting in zero coverage.
     */

  }, {
    key: "resetHits",
    value: function resetHits() {
      var statements = this.s;
      var functions = this.f;
      var branches = this.b;
      Object.keys(statements).forEach(function (s) {
        statements[s] = 0;
      });
      Object.keys(functions).forEach(function (f) {
        functions[f] = 0;
      });
      Object.keys(branches).forEach(function (b) {
        branches[b].fill(0);
      });
    }
    /**
     * returns a CoverageSummary for this file coverage object
     * @returns {CoverageSummary}
     */

  }, {
    key: "toSummary",
    value: function toSummary() {
      var ret = {};
      ret.lines = this.computeSimpleTotals('getLineCoverage');
      ret.functions = this.computeSimpleTotals('f', 'fnMap');
      ret.statements = this.computeSimpleTotals('s', 'statementMap');
      ret.branches = this.computeBranchTotals();
      return new CoverageSummary(ret);
    }
  }]);

  return FileCoverage;
}(); // expose coverage data attributes


dataProperties(FileCoverage, ['path', 'statementMap', 'fnMap', 'branchMap', 's', 'f', 'b', 'all']);
module.exports = {
  FileCoverage: FileCoverage
};