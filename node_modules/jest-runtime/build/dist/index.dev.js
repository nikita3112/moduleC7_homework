'use strict';

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty2(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function nativeModule() {
  var data = _interopRequireWildcard(require('module'));

  nativeModule = function nativeModule() {
    return data;
  };

  return data;
}

function path() {
  var data = _interopRequireWildcard(require('path'));

  path = function path() {
    return data;
  };

  return data;
}

function _url() {
  var data = require('url');

  _url = function _url() {
    return data;
  };

  return data;
}

function _vm() {
  var data = require('vm');

  _vm = function _vm() {
    return data;
  };

  return data;
}

function _cjsModuleLexer() {
  var data = require('cjs-module-lexer');

  _cjsModuleLexer = function _cjsModuleLexer() {
    return data;
  };

  return data;
}

function _collectV8Coverage() {
  var data = require('collect-v8-coverage');

  _collectV8Coverage = function _collectV8Coverage() {
    return data;
  };

  return data;
}

function fs() {
  var data = _interopRequireWildcard(require('graceful-fs'));

  fs = function fs() {
    return data;
  };

  return data;
}

function _stripBom() {
  var data = _interopRequireDefault(require('strip-bom'));

  _stripBom = function _stripBom() {
    return data;
  };

  return data;
}

function _fakeTimers() {
  var data = require('@jest/fake-timers');

  _fakeTimers = function _fakeTimers() {
    return data;
  };

  return data;
}

function _transform() {
  var data = require('@jest/transform');

  _transform = function _transform() {
    return data;
  };

  return data;
}

function _jestHasteMap() {
  var data = _interopRequireDefault(require('jest-haste-map'));

  _jestHasteMap = function _jestHasteMap() {
    return data;
  };

  return data;
}

function _jestMessageUtil() {
  var data = require('jest-message-util');

  _jestMessageUtil = function _jestMessageUtil() {
    return data;
  };

  return data;
}

function _jestMock() {
  var data = _interopRequireDefault(require('jest-mock'));

  _jestMock = function _jestMock() {
    return data;
  };

  return data;
}

function _jestRegexUtil() {
  var data = require('jest-regex-util');

  _jestRegexUtil = function _jestRegexUtil() {
    return data;
  };

  return data;
}

function _jestResolve() {
  var data = _interopRequireDefault(require('jest-resolve'));

  _jestResolve = function _jestResolve() {
    return data;
  };

  return data;
}

function _jestSnapshot() {
  var data = _interopRequireDefault(require('jest-snapshot'));

  _jestSnapshot = function _jestSnapshot() {
    return data;
  };

  return data;
}

function _jestUtil() {
  var data = require('jest-util');

  _jestUtil = function _jestUtil() {
    return data;
  };

  return data;
}

var _cli = require('./cli');

var _args = require('./cli/args');

var _helpers = require('./helpers');

var _Object$fromEntries;

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _getRequireWildcardCache() {
  if (typeof WeakMap !== 'function') return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var esmIsAvailable = typeof _vm().SourceTextModule === 'function';
var defaultTransformOptions = {
  isInternalModule: false,
  supportsDynamicImport: esmIsAvailable,
  supportsExportNamespaceFrom: false,
  supportsStaticESM: false,
  supportsTopLevelAwait: false
};
var OUTSIDE_JEST_VM_RESOLVE_OPTION = Symbol["for"]('OUTSIDE_JEST_VM_RESOLVE_OPTION');
var fromEntries = (_Object$fromEntries = Object.fromEntries) !== null && _Object$fromEntries !== void 0 ? _Object$fromEntries : function fromEntries(iterable) {
  return _toConsumableArray(iterable).reduce(function (obj, _ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        key = _ref2[0],
        val = _ref2[1];

    obj[key] = val;
    return obj;
  }, {});
};
var testTimeoutSymbol = Symbol["for"]('TEST_TIMEOUT_SYMBOL');
var retryTimesSymbol = Symbol["for"]('RETRY_TIMES');
var NODE_MODULES = path().sep + 'node_modules' + path().sep;

var getModuleNameMapper = function getModuleNameMapper(config) {
  if (Array.isArray(config.moduleNameMapper) && config.moduleNameMapper.length) {
    return config.moduleNameMapper.map(function (_ref3) {
      var _ref4 = _slicedToArray(_ref3, 2),
          regex = _ref4[0],
          moduleName = _ref4[1];

      return {
        moduleName: moduleName,
        regex: new RegExp(regex)
      };
    });
  }

  return null;
};

var unmockRegExpCache = new WeakMap();
var EVAL_RESULT_VARIABLE = 'Object.<anonymous>';
var runtimeSupportsVmModules = typeof _vm().SyntheticModule === 'function';

var supportsTopLevelAwait = runtimeSupportsVmModules && function () {
  try {
    // eslint-disable-next-line no-new
    new (_vm().SourceTextModule)('await Promise.resolve()');
    return true;
  } catch (_unused) {
    return false;
  }
}();

var Runtime =
/*#__PURE__*/
function () {
  function Runtime(config, environment, resolver) {
    var _this = this;

    var cacheFS = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var coverageOptions = arguments.length > 4 ? arguments[4] : undefined;
    var // TODO: Make mandatory in Jest 27
    testPath = arguments.length > 5 ? arguments[5] : undefined;

    _classCallCheck(this, Runtime);

    _defineProperty(this, '_cacheFS', void 0);

    _defineProperty(this, '_config', void 0);

    _defineProperty(this, '_coverageOptions', void 0);

    _defineProperty(this, '_currentlyExecutingModulePath', void 0);

    _defineProperty(this, '_environment', void 0);

    _defineProperty(this, '_explicitShouldMock', void 0);

    _defineProperty(this, '_fakeTimersImplementation', void 0);

    _defineProperty(this, '_internalModuleRegistry', void 0);

    _defineProperty(this, '_isCurrentlyExecutingManualMock', void 0);

    _defineProperty(this, '_mainModule', void 0);

    _defineProperty(this, '_mockFactories', void 0);

    _defineProperty(this, '_mockMetaDataCache', void 0);

    _defineProperty(this, '_mockRegistry', void 0);

    _defineProperty(this, '_isolatedMockRegistry', void 0);

    _defineProperty(this, '_moduleMocker', void 0);

    _defineProperty(this, '_isolatedModuleRegistry', void 0);

    _defineProperty(this, '_moduleRegistry', void 0);

    _defineProperty(this, '_esmoduleRegistry', void 0);

    _defineProperty(this, '_testPath', void 0);

    _defineProperty(this, '_resolver', void 0);

    _defineProperty(this, '_shouldAutoMock', void 0);

    _defineProperty(this, '_shouldMockModuleCache', void 0);

    _defineProperty(this, '_shouldUnmockTransitiveDependenciesCache', void 0);

    _defineProperty(this, '_sourceMapRegistry', void 0);

    _defineProperty(this, '_scriptTransformer', void 0);

    _defineProperty(this, '_fileTransforms', void 0);

    _defineProperty(this, '_v8CoverageInstrumenter', void 0);

    _defineProperty(this, '_v8CoverageResult', void 0);

    _defineProperty(this, '_transitiveShouldMock', void 0);

    _defineProperty(this, '_unmockList', void 0);

    _defineProperty(this, '_virtualMocks', void 0);

    _defineProperty(this, '_moduleImplementation', void 0);

    _defineProperty(this, 'jestObjectCaches', void 0);

    _defineProperty(this, 'jestGlobals', void 0);

    _defineProperty(this, 'unstable_shouldLoadAsEsm', _jestResolve()["default"].unstable_shouldLoadAsEsm);

    this._cacheFS = new Map(Object.entries(cacheFS));
    this._config = config;
    this._coverageOptions = coverageOptions || {
      changedFiles: undefined,
      collectCoverage: false,
      collectCoverageFrom: [],
      collectCoverageOnlyFrom: undefined,
      coverageProvider: 'babel',
      sourcesRelatedToTestsInChangedFiles: undefined
    };
    this._currentlyExecutingModulePath = '';
    this._environment = environment;
    this._explicitShouldMock = new Map();
    this._internalModuleRegistry = new Map();
    this._isCurrentlyExecutingManualMock = null;
    this._mainModule = null;
    this._mockFactories = new Map();
    this._mockRegistry = new Map(); // during setup, this cannot be null (and it's fine to explode if it is)

    this._moduleMocker = this._environment.moduleMocker;
    this._isolatedModuleRegistry = null;
    this._isolatedMockRegistry = null;
    this._moduleRegistry = new Map();
    this._esmoduleRegistry = new Map();
    this._testPath = testPath;
    this._resolver = resolver;
    this._scriptTransformer = new (_transform().ScriptTransformer)(config);
    this._shouldAutoMock = config.automock;
    this._sourceMapRegistry = new Map();
    this._fileTransforms = new Map();
    this._virtualMocks = new Map();
    this.jestObjectCaches = new Map();
    this._mockMetaDataCache = new Map();
    this._shouldMockModuleCache = new Map();
    this._shouldUnmockTransitiveDependenciesCache = new Map();
    this._transitiveShouldMock = new Map();
    this._fakeTimersImplementation = config.timers === 'modern' ? this._environment.fakeTimersModern : this._environment.fakeTimers;
    this._unmockList = unmockRegExpCache.get(config);

    if (!this._unmockList && config.unmockedModulePathPatterns) {
      this._unmockList = new RegExp(config.unmockedModulePathPatterns.join('|'));
      unmockRegExpCache.set(config, this._unmockList);
    }

    if (config.automock) {
      var virtualMocks = fromEntries(this._virtualMocks);
      config.setupFiles.forEach(function (filePath) {
        if (filePath && filePath.includes(NODE_MODULES)) {
          var moduleID = _this._resolver.getModuleID(virtualMocks, filePath);

          _this._transitiveShouldMock.set(moduleID, false);
        }
      });
    }

    this.resetModules();
  }

  _createClass(Runtime, [{
    key: "loadEsmModule",
    // unstable as it should be replaced by https://github.com/nodejs/modules/issues/393, and we don't want people to use it
    value: function loadEsmModule(modulePath) {
      var _this2 = this;

      var query,
          cacheKey,
          context,
          core,
          transformedCode,
          _module,
          module,
          _args2 = arguments;

      return regeneratorRuntime.async(function loadEsmModule$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              query = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : '';
              cacheKey = modulePath + query;

              if (this._esmoduleRegistry.has(cacheKey)) {
                _context.next = 15;
                break;
              }

              invariant(typeof this._environment.getVmContext === 'function', 'ES Modules are only supported if your test environment has the `getVmContext` function');
              context = this._environment.getVmContext();
              invariant(context);

              if (!this._resolver.isCoreModule(modulePath)) {
                _context.next = 12;
                break;
              }

              _context.next = 9;
              return regeneratorRuntime.awrap(this._importCoreModule(modulePath, context));

            case 9:
              core = _context.sent;

              this._esmoduleRegistry.set(cacheKey, core);

              return _context.abrupt("return", core);

            case 12:
              transformedCode = this.transformFile(modulePath, {
                isInternalModule: false,
                supportsDynamicImport: true,
                supportsExportNamespaceFrom: true,
                supportsStaticESM: true,
                supportsTopLevelAwait: supportsTopLevelAwait
              });
              _module = new (_vm().SourceTextModule)(transformedCode, {
                context: context,
                identifier: modulePath,
                importModuleDynamically: function importModuleDynamically(specifier, referencingModule) {
                  return _this2.linkModules(specifier, referencingModule.identifier, referencingModule.context);
                },
                initializeImportMeta: function initializeImportMeta(meta) {
                  meta.url = (0, _url().pathToFileURL)(modulePath).href;
                }
              });

              this._esmoduleRegistry.set(cacheKey, // we wanna put the linking promise in the cache so modules loaded in
              // parallel can all await it. We then await it synchronously below, so
              // we shouldn't get any unhandled rejections
              _module.link(function (specifier, referencingModule) {
                return _this2.linkModules(specifier, referencingModule.identifier, referencingModule.context);
              }).then(function () {
                return _module.evaluate();
              }).then(function () {
                return _module;
              }));

            case 15:
              module = this._esmoduleRegistry.get(cacheKey);
              invariant(module);
              return _context.abrupt("return", module);

            case 18:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "linkModules",
    value: function linkModules(specifier, referencingIdentifier, context) {
      if (specifier === '@jest/globals') {
        var fromCache = this._esmoduleRegistry.get('@jest/globals');

        if (fromCache) {
          return fromCache;
        }

        var globals = this.getGlobalsForEsm(referencingIdentifier, context);

        this._esmoduleRegistry.set('@jest/globals', globals);

        return globals;
      }

      if (specifier.startsWith('file://')) {
        specifier = (0, _url().fileURLToPath)(specifier);
      }

      var _specifier$split = specifier.split('?'),
          _specifier$split2 = _slicedToArray(_specifier$split, 2),
          path = _specifier$split2[0],
          query = _specifier$split2[1];

      var resolved = this._resolveModule(referencingIdentifier, path);

      if (this._resolver.isCoreModule(resolved) || this.unstable_shouldLoadAsEsm(resolved)) {
        return this.loadEsmModule(resolved, query);
      }

      return this.loadCjsAsEsm(referencingIdentifier, resolved, context);
    }
  }, {
    key: "unstable_importModule",
    value: function unstable_importModule(from, moduleName) {
      var _split, _split2, path, query, modulePath;

      return regeneratorRuntime.async(function unstable_importModule$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              invariant(runtimeSupportsVmModules, 'You need to run with a version of node that supports ES Modules in the VM API.');
              _split = (moduleName !== null && moduleName !== void 0 ? moduleName : '').split('?'), _split2 = _slicedToArray(_split, 2), path = _split2[0], query = _split2[1];
              modulePath = this._resolveModule(from, path);
              return _context2.abrupt("return", this.loadEsmModule(modulePath, query));

            case 4:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "loadCjsAsEsm",
    value: function loadCjsAsEsm(from, modulePath, context) {
      // CJS loaded via `import` should share cache with other CJS: https://github.com/nodejs/modules/issues/503
      var cjs = this.requireModuleOrMock(from, modulePath);

      var transformedCode = this._fileTransforms.get(modulePath);

      var cjsExports = [];

      if (transformedCode) {
        var _ref5 = (0, _cjsModuleLexer().parse)(transformedCode.code),
            exports = _ref5.exports;

        cjsExports = exports.filter(function (exportName) {
          // we don't wanna respect any exports _names_ default as a named export
          if (exportName === 'default') {
            return false;
          }

          return Object.hasOwnProperty.call(cjs, exportName);
        });
      }

      var module = new (_vm().SyntheticModule)([].concat(_toConsumableArray(cjsExports), ['default']), function () {
        var _this3 = this;

        cjsExports.forEach(function (exportName) {
          // @ts-expect-error
          _this3.setExport(exportName, cjs[exportName]);
        }); // @ts-expect-error: TS doesn't know what `this` is

        this.setExport('default', cjs);
      }, {
        context: context,
        identifier: modulePath
      });
      return evaluateSyntheticModule(module);
    }
  }, {
    key: "requireModule",
    value: function requireModule(from, moduleName, options, isRequireActual) {
      var moduleID = this._resolver.getModuleID(fromEntries(this._virtualMocks), from, moduleName);

      var modulePath; // Some old tests rely on this mocking behavior. Ideally we'll change this
      // to be more explicit.

      var moduleResource = moduleName && this._resolver.getModule(moduleName);

      var manualMock = moduleName && this._resolver.getMockModule(from, moduleName);

      if (!(options === null || options === void 0 ? void 0 : options.isInternalModule) && !isRequireActual && !moduleResource && manualMock && manualMock !== this._isCurrentlyExecutingManualMock && this._explicitShouldMock.get(moduleID) !== false) {
        modulePath = manualMock;
      }

      if (moduleName && this._resolver.isCoreModule(moduleName)) {
        return this._requireCoreModule(moduleName);
      }

      if (!modulePath) {
        modulePath = this._resolveModule(from, moduleName);
      }

      var moduleRegistry;

      if (options === null || options === void 0 ? void 0 : options.isInternalModule) {
        moduleRegistry = this._internalModuleRegistry;
      } else {
        if (this._moduleRegistry.get(modulePath) || !this._isolatedModuleRegistry) {
          moduleRegistry = this._moduleRegistry;
        } else {
          moduleRegistry = this._isolatedModuleRegistry;
        }
      }

      var module = moduleRegistry.get(modulePath);

      if (module) {
        return module.exports;
      } // We must register the pre-allocated module object first so that any
      // circular dependencies that may arise while evaluating the module can
      // be satisfied.


      var localModule = {
        children: [],
        exports: {},
        filename: modulePath,
        id: modulePath,
        loaded: false,
        path: path().dirname(modulePath)
      };
      moduleRegistry.set(modulePath, localModule);

      this._loadModule(localModule, from, moduleName, modulePath, options, moduleRegistry);

      return localModule.exports;
    }
  }, {
    key: "requireInternalModule",
    value: function requireInternalModule(from, to) {
      if (to) {
        var outsideJestVmPath = (0, _helpers.decodePossibleOutsideJestVmPath)(to);

        if (outsideJestVmPath) {
          return require(outsideJestVmPath);
        }
      }

      return this.requireModule(from, to, {
        isInternalModule: true,
        supportsDynamicImport: esmIsAvailable,
        supportsExportNamespaceFrom: false,
        supportsStaticESM: false,
        supportsTopLevelAwait: false
      });
    }
  }, {
    key: "requireActual",
    value: function requireActual(from, moduleName) {
      return this.requireModule(from, moduleName, undefined, true);
    }
  }, {
    key: "requireMock",
    value: function requireMock(from, moduleName) {
      var moduleID = this._resolver.getModuleID(fromEntries(this._virtualMocks), from, moduleName);

      if (this._isolatedMockRegistry && this._isolatedMockRegistry.get(moduleID)) {
        return this._isolatedMockRegistry.get(moduleID);
      } else if (this._mockRegistry.get(moduleID)) {
        return this._mockRegistry.get(moduleID);
      }

      var mockRegistry = this._isolatedMockRegistry || this._mockRegistry;

      if (this._mockFactories.has(moduleID)) {
        // has check above makes this ok
        var _module2 = this._mockFactories.get(moduleID)();

        mockRegistry.set(moduleID, _module2);
        return _module2;
      }

      var manualMockOrStub = this._resolver.getMockModule(from, moduleName);

      var modulePath = this._resolver.getMockModule(from, moduleName) || this._resolveModule(from, moduleName);

      var isManualMock = manualMockOrStub && !this._resolver.resolveStubModuleName(from, moduleName);

      if (!isManualMock) {
        // If the actual module file has a __mocks__ dir sitting immediately next
        // to it, look to see if there is a manual mock for this file.
        //
        // subDir1/my_module.js
        // subDir1/__mocks__/my_module.js
        // subDir2/my_module.js
        // subDir2/__mocks__/my_module.js
        //
        // Where some other module does a relative require into each of the
        // respective subDir{1,2} directories and expects a manual mock
        // corresponding to that particular my_module.js file.
        var moduleDir = path().dirname(modulePath);
        var moduleFileName = path().basename(modulePath);
        var potentialManualMock = path().join(moduleDir, '__mocks__', moduleFileName);

        if (fs().existsSync(potentialManualMock)) {
          isManualMock = true;
          modulePath = potentialManualMock;
        }
      }

      if (isManualMock) {
        var localModule = {
          children: [],
          exports: {},
          filename: modulePath,
          id: modulePath,
          loaded: false,
          path: path().dirname(modulePath)
        };

        this._loadModule(localModule, from, moduleName, modulePath, undefined, mockRegistry);

        mockRegistry.set(moduleID, localModule.exports);
      } else {
        // Look for a real module to generate an automock from
        mockRegistry.set(moduleID, this._generateMock(from, moduleName));
      }

      return mockRegistry.get(moduleID);
    }
  }, {
    key: "_loadModule",
    value: function _loadModule(localModule, from, moduleName, modulePath, options, moduleRegistry) {
      if (path().extname(modulePath) === '.json') {
        var text = (0, _stripBom()["default"])(this.readFile(modulePath));

        var transformedFile = this._scriptTransformer.transformJson(modulePath, this._getFullTransformationOptions(options), text);

        localModule.exports = this._environment.global.JSON.parse(transformedFile);
      } else if (path().extname(modulePath) === '.node') {
        localModule.exports = require(modulePath);
      } else {
        // Only include the fromPath if a moduleName is given. Else treat as root.
        var fromPath = moduleName ? from : null;

        this._execModule(localModule, options, moduleRegistry, fromPath);
      }

      localModule.loaded = true;
    }
  }, {
    key: "_getFullTransformationOptions",
    value: function _getFullTransformationOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultTransformOptions;
      return _objectSpread({}, options, {}, this._coverageOptions);
    }
  }, {
    key: "requireModuleOrMock",
    value: function requireModuleOrMock(from, moduleName) {
      // this module is unmockable
      if (moduleName === '@jest/globals') {
        // @ts-expect-error: we don't care that it's not assignable to T
        return this.getGlobalsForCjs(from);
      }

      try {
        if (this._shouldMock(from, moduleName)) {
          return this.requireMock(from, moduleName);
        } else {
          return this.requireModule(from, moduleName);
        }
      } catch (e) {
        var moduleNotFound = _jestResolve()["default"].tryCastModuleNotFoundError(e);

        if (moduleNotFound) {
          if (moduleNotFound.siblingWithSimilarExtensionFound === null || moduleNotFound.siblingWithSimilarExtensionFound === undefined) {
            moduleNotFound.hint = (0, _helpers.findSiblingsWithFileExtension)(this._config.moduleFileExtensions, from, moduleNotFound.moduleName || moduleName);
            moduleNotFound.siblingWithSimilarExtensionFound = Boolean(moduleNotFound.hint);
          }

          moduleNotFound.buildMessage(this._config.rootDir);
          throw moduleNotFound;
        }

        throw e;
      }
    }
  }, {
    key: "isolateModules",
    value: function isolateModules(fn) {
      if (this._isolatedModuleRegistry || this._isolatedMockRegistry) {
        throw new Error('isolateModules cannot be nested inside another isolateModules.');
      }

      this._isolatedModuleRegistry = new Map();
      this._isolatedMockRegistry = new Map();

      try {
        fn();
      } finally {
        var _this$_isolatedModule, _this$_isolatedMockRe; // might be cleared within the callback


        (_this$_isolatedModule = this._isolatedModuleRegistry) === null || _this$_isolatedModule === void 0 ? void 0 : _this$_isolatedModule.clear();
        (_this$_isolatedMockRe = this._isolatedMockRegistry) === null || _this$_isolatedMockRe === void 0 ? void 0 : _this$_isolatedMockRe.clear();
        this._isolatedModuleRegistry = null;
        this._isolatedMockRegistry = null;
      }
    }
  }, {
    key: "resetModules",
    value: function resetModules() {
      var _this$_isolatedModule2, _this$_isolatedMockRe2;

      (_this$_isolatedModule2 = this._isolatedModuleRegistry) === null || _this$_isolatedModule2 === void 0 ? void 0 : _this$_isolatedModule2.clear();
      (_this$_isolatedMockRe2 = this._isolatedMockRegistry) === null || _this$_isolatedMockRe2 === void 0 ? void 0 : _this$_isolatedMockRe2.clear();
      this._isolatedModuleRegistry = null;
      this._isolatedMockRegistry = null;

      this._mockRegistry.clear();

      this._moduleRegistry.clear();

      this._esmoduleRegistry.clear();

      if (this._environment) {
        if (this._environment.global) {
          var envGlobal = this._environment.global;
          Object.keys(envGlobal).forEach(function (key) {
            var globalMock = envGlobal[key];

            if ((_typeof(globalMock) === 'object' && globalMock !== null || typeof globalMock === 'function') && globalMock._isMockFunction === true) {
              globalMock.mockClear();
            }
          });
        }

        if (this._environment.fakeTimers) {
          this._environment.fakeTimers.clearAllTimers();
        }
      }
    }
  }, {
    key: "collectV8Coverage",
    value: function collectV8Coverage() {
      return regeneratorRuntime.async(function collectV8Coverage$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              this._v8CoverageInstrumenter = new (_collectV8Coverage().CoverageInstrumenter)();
              _context3.next = 3;
              return regeneratorRuntime.awrap(this._v8CoverageInstrumenter.startInstrumenting());

            case 3:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "stopCollectingV8Coverage",
    value: function stopCollectingV8Coverage() {
      return regeneratorRuntime.async(function stopCollectingV8Coverage$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (this._v8CoverageInstrumenter) {
                _context4.next = 2;
                break;
              }

              throw new Error('You need to call `collectV8Coverage` first.');

            case 2:
              _context4.next = 4;
              return regeneratorRuntime.awrap(this._v8CoverageInstrumenter.stopInstrumenting());

            case 4:
              this._v8CoverageResult = _context4.sent;

            case 5:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "getAllCoverageInfoCopy",
    value: function getAllCoverageInfoCopy() {
      return (0, _jestUtil().deepCyclicCopy)(this._environment.global.__coverage__);
    }
  }, {
    key: "getAllV8CoverageInfoCopy",
    value: function getAllV8CoverageInfoCopy() {
      var _this4 = this;

      if (!this._v8CoverageResult) {
        throw new Error('You need to `stopCollectingV8Coverage` first');
      }

      return this._v8CoverageResult.filter(function (res) {
        return res.url.startsWith('file://');
      }).map(function (res) {
        return _objectSpread({}, res, {
          url: (0, _url().fileURLToPath)(res.url)
        });
      }).filter(function (res // TODO: will this work on windows? It might be better if `shouldInstrument` deals with it anyways
      ) {
        return res.url.startsWith(_this4._config.rootDir) && _this4._fileTransforms.has(res.url) && (0, _transform().shouldInstrument)(res.url, _this4._coverageOptions, _this4._config);
      }).map(function (result) {
        var transformedFile = _this4._fileTransforms.get(result.url);

        return {
          codeTransformResult: transformedFile,
          result: result
        };
      });
    } // TODO - remove in Jest 27

  }, {
    key: "getSourceMapInfo",
    value: function getSourceMapInfo(_coveredFiles) {
      return {};
    }
  }, {
    key: "getSourceMaps",
    value: function getSourceMaps() {
      return fromEntries(this._sourceMapRegistry);
    }
  }, {
    key: "setMock",
    value: function setMock(from, moduleName, mockFactory, options) {
      if (options === null || options === void 0 ? void 0 : options.virtual) {
        var mockPath = this._resolver.getModulePath(from, moduleName);

        this._virtualMocks.set(mockPath, true);
      }

      var moduleID = this._resolver.getModuleID(fromEntries(this._virtualMocks), from, moduleName);

      this._explicitShouldMock.set(moduleID, true);

      this._mockFactories.set(moduleID, mockFactory);
    }
  }, {
    key: "restoreAllMocks",
    value: function restoreAllMocks() {
      this._moduleMocker.restoreAllMocks();
    }
  }, {
    key: "resetAllMocks",
    value: function resetAllMocks() {
      this._moduleMocker.resetAllMocks();
    }
  }, {
    key: "clearAllMocks",
    value: function clearAllMocks() {
      this._moduleMocker.clearAllMocks();
    }
  }, {
    key: "teardown",
    value: function teardown() {
      this.restoreAllMocks();
      this.resetAllMocks();
      this.resetModules();

      this._internalModuleRegistry.clear();

      this._mainModule = null;

      this._mockFactories.clear();

      this._mockMetaDataCache.clear();

      this._shouldMockModuleCache.clear();

      this._shouldUnmockTransitiveDependenciesCache.clear();

      this._explicitShouldMock.clear();

      this._transitiveShouldMock.clear();

      this._virtualMocks.clear();

      this._cacheFS.clear();

      this._unmockList = undefined;

      this._sourceMapRegistry.clear();

      this._fileTransforms.clear();

      this.jestObjectCaches.clear();
      this._v8CoverageResult = [];
      this._v8CoverageInstrumenter = undefined;
      this._moduleImplementation = undefined;
    }
  }, {
    key: "_resolveModule",
    value: function _resolveModule(from, to) {
      return to ? this._resolver.resolveModule(from, to) : from;
    }
  }, {
    key: "_requireResolve",
    value: function _requireResolve(from, moduleName) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (moduleName == null) {
        throw new Error('The first argument to require.resolve must be a string. Received null or undefined.');
      }

      var paths = options.paths;

      if (paths) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = paths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var p = _step.value;
            var absolutePath = path().resolve(from, '..', p);

            var _module3 = this._resolver.resolveModuleFromDirIfExists(absolutePath, moduleName, // required to also resolve files without leading './' directly in the path
            {
              paths: [absolutePath]
            });

            if (_module3) {
              return _module3;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        throw new (_jestResolve()["default"].ModuleNotFoundError)("Cannot resolve module '".concat(moduleName, "' from paths ['").concat(paths.join("', '"), "'] from ").concat(from));
      }

      try {
        return this._resolveModule(from, moduleName);
      } catch (err) {
        var _module4 = this._resolver.getMockModule(from, moduleName);

        if (_module4) {
          return _module4;
        } else {
          throw err;
        }
      }
    }
  }, {
    key: "_requireResolvePaths",
    value: function _requireResolvePaths(from, moduleName) {
      if (moduleName == null) {
        throw new Error('The first argument to require.resolve.paths must be a string. Received null or undefined.');
      }

      if (!moduleName.length) {
        throw new Error('The first argument to require.resolve.paths must not be the empty string.');
      }

      if (moduleName[0] === '.') {
        return [path().resolve(from, '..')];
      }

      if (this._resolver.isCoreModule(moduleName)) {
        return null;
      }

      return this._resolver.getModulePaths(path().resolve(from, '..'));
    }
  }, {
    key: "_execModule",
    value: function _execModule(localModule, options, moduleRegistry, from) {
      var _this5 = this;

      // If the environment was disposed, prevent this module from being executed.
      if (!this._environment.global) {
        return;
      }

      var module = localModule;
      var filename = module.filename;
      var lastExecutingModulePath = this._currentlyExecutingModulePath;
      this._currentlyExecutingModulePath = filename;
      var origCurrExecutingManualMock = this._isCurrentlyExecutingManualMock;
      this._isCurrentlyExecutingManualMock = filename;
      module.children = [];
      Object.defineProperty(module, 'parent', {
        enumerable: true,
        get: function get() {
          var key = from || '';
          return moduleRegistry.get(key) || null;
        }
      });
      module.paths = this._resolver.getModulePaths(module.path);
      Object.defineProperty(module, 'require', {
        value: this._createRequireImplementation(module, options)
      });
      var transformedCode = this.transformFile(filename, options);
      var compiledFunction = null;
      var script = this.createScriptFromCode(transformedCode, filename);
      var runScript = null; // Use this if available instead of deprecated `JestEnvironment.runScript`

      if (typeof this._environment.getVmContext === 'function') {
        var vmContext = this._environment.getVmContext();

        if (vmContext) {
          runScript = script.runInContext(vmContext, {
            filename: filename
          });
        }
      } else {
        runScript = this._environment.runScript(script);
      }

      if (runScript !== null) {
        compiledFunction = runScript[EVAL_RESULT_VARIABLE];
      }

      if (compiledFunction === null) {
        this._logFormattedReferenceError('You are trying to `import` a file after the Jest environment has been torn down.');

        process.exitCode = 1;
        return;
      }

      var jestObject = this._createJestObjectFor(filename);

      this.jestObjectCaches.set(filename, jestObject);
      var lastArgs = [this._config.injectGlobals ? jestObject : undefined].concat(_toConsumableArray(this._config.extraGlobals.map(function (globalVariable) {
        if (_this5._environment.global[globalVariable]) {
          return _this5._environment.global[globalVariable];
        }

        throw new Error("You have requested '".concat(globalVariable, "' as a global variable, but it was not present. Please check your config or your global environment."));
      })));

      if (!this._mainModule && filename === this._testPath) {
        this._mainModule = module;
      }

      Object.defineProperty(module, 'main', {
        enumerable: true,
        value: this._mainModule
      });

      try {
        var _compiledFunction;

        (_compiledFunction = compiledFunction).call.apply(_compiledFunction, [module.exports, module, // module object
        module.exports, // module exports
        module.require, // require implementation
        module.path, // __dirname
        module.filename, // __filename
        this._environment.global].concat(_toConsumableArray(lastArgs.filter(notEmpty))));
      } catch (error) {
        this.handleExecutionError(error, module);
      }

      this._isCurrentlyExecutingManualMock = origCurrExecutingManualMock;
      this._currentlyExecutingModulePath = lastExecutingModulePath;
    }
  }, {
    key: "transformFile",
    value: function transformFile(filename, options) {
      var source = this.readFile(filename);

      if (options === null || options === void 0 ? void 0 : options.isInternalModule) {
        return source;
      }

      var transformedFile = this._scriptTransformer.transform(filename, this._getFullTransformationOptions(options), source);

      this._fileTransforms.set(filename, _objectSpread({}, transformedFile, {
        wrapperLength: this.constructModuleWrapperStart().length
      }));

      if (transformedFile.sourceMapPath) {
        this._sourceMapRegistry.set(filename, transformedFile.sourceMapPath);
      }

      return transformedFile.code;
    }
  }, {
    key: "createScriptFromCode",
    value: function createScriptFromCode(scriptSource, filename) {
      var _this6 = this;

      try {
        var scriptFilename = this._resolver.isCoreModule(filename) ? "jest-nodejs-core-".concat(filename) : filename;
        return new (_vm().Script)(this.wrapCodeInModuleWrapper(scriptSource), {
          displayErrors: true,
          filename: scriptFilename,
          // @ts-expect-error: Experimental ESM API
          importModuleDynamically: function importModuleDynamically(specifier) {
            var _this$_environment$ge, _this$_environment;

            var context = (_this$_environment$ge = (_this$_environment = _this6._environment).getVmContext) === null || _this$_environment$ge === void 0 ? void 0 : _this$_environment$ge.call(_this$_environment);
            invariant(context);
            return _this6.linkModules(specifier, scriptFilename, context);
          }
        });
      } catch (e) {
        throw (0, _transform().handlePotentialSyntaxError)(e);
      }
    }
  }, {
    key: "_requireCoreModule",
    value: function _requireCoreModule(moduleName) {
      if (moduleName === 'process') {
        return this._environment.global.process;
      }

      if (moduleName === 'module') {
        return this._getMockedNativeModule();
      }

      return require(moduleName);
    }
  }, {
    key: "_importCoreModule",
    value: function _importCoreModule(moduleName, context) {
      var required = this._requireCoreModule(moduleName);

      var module = new (_vm().SyntheticModule)(['default'].concat(_toConsumableArray(Object.keys(required))), function () {
        var _this7 = this;

        // @ts-expect-error: TS doesn't know what `this` is
        this.setExport('default', required);
        Object.entries(required).forEach(function (_ref6) {
          var _ref7 = _slicedToArray(_ref6, 2),
              key = _ref7[0],
              value = _ref7[1];

          // @ts-expect-error: TS doesn't know what `this` is
          _this7.setExport(key, value);
        });
      }, // should identifier be `node://${moduleName}`?
      {
        context: context,
        identifier: moduleName
      });
      return evaluateSyntheticModule(module);
    }
  }, {
    key: "_getMockedNativeModule",
    value: function _getMockedNativeModule() {
      var _this8 = this;

      if (this._moduleImplementation) {
        return this._moduleImplementation;
      }

      var createRequire = function createRequire(modulePath) {
        var filename = typeof modulePath === 'string' ? modulePath.startsWith('file:///') ? (0, _url().fileURLToPath)(new (_url().URL)(modulePath)) : modulePath : (0, _url().fileURLToPath)(modulePath);

        if (!path().isAbsolute(filename)) {
          var error = new TypeError("The argument 'filename' must be a file URL object, file URL string, or absolute path string. Received '".concat(filename, "'")); // @ts-expect-error

          error.code = 'ERR_INVALID_ARG_TYPE';
          throw error;
        }

        return _this8._createRequireImplementation({
          children: [],
          exports: {},
          filename: filename,
          id: filename,
          loaded: false,
          path: path().dirname(filename)
        });
      }; // should we implement the class ourselves?


      var Module =
      /*#__PURE__*/
      function (_nativeModule$Module) {
        _inherits(Module, _nativeModule$Module);

        function Module() {
          _classCallCheck(this, Module);

          return _possibleConstructorReturn(this, _getPrototypeOf(Module).apply(this, arguments));
        }

        return Module;
      }(nativeModule().Module);

      Object.entries(nativeModule().Module).forEach(function (_ref8) {
        var _ref9 = _slicedToArray(_ref8, 2),
            key = _ref9[0],
            value = _ref9[1];

        // @ts-expect-error
        Module[key] = value;
      });
      Module.Module = Module;

      if ('createRequire' in nativeModule()) {
        Module.createRequire = createRequire;
      }

      if ('createRequireFromPath' in nativeModule()) {
        Module.createRequireFromPath = function createRequireFromPath(filename) {
          if (typeof filename !== 'string') {
            var error = new TypeError("The argument 'filename' must be string. Received '".concat(filename, "'.").concat(filename instanceof _url().URL ? ' Use createRequire for URL filename.' : '')); // @ts-expect-error

            error.code = 'ERR_INVALID_ARG_TYPE';
            throw error;
          }

          return createRequire(filename);
        };
      }

      if ('syncBuiltinESMExports' in nativeModule()) {
        Module.syncBuiltinESMExports = function syncBuiltinESMExports() {};
      }

      this._moduleImplementation = Module;
      return Module;
    }
  }, {
    key: "_generateMock",
    value: function _generateMock(from, moduleName) {
      var modulePath = this._resolver.resolveStubModuleName(from, moduleName) || this._resolveModule(from, moduleName);

      if (!this._mockMetaDataCache.has(modulePath)) {
        // This allows us to handle circular dependencies while generating an
        // automock
        this._mockMetaDataCache.set(modulePath, this._moduleMocker.getMetadata({}) || {}); // In order to avoid it being possible for automocking to potentially
        // cause side-effects within the module environment, we need to execute
        // the module in isolation. This could cause issues if the module being
        // mocked has calls into side-effectful APIs on another module.


        var origMockRegistry = this._mockRegistry;
        var origModuleRegistry = this._moduleRegistry;
        this._mockRegistry = new Map();
        this._moduleRegistry = new Map();
        var moduleExports = this.requireModule(from, moduleName); // Restore the "real" module/mock registries

        this._mockRegistry = origMockRegistry;
        this._moduleRegistry = origModuleRegistry;

        var mockMetadata = this._moduleMocker.getMetadata(moduleExports);

        if (mockMetadata == null) {
          throw new Error("Failed to get mock metadata: ".concat(modulePath, "\n\n") + "See: https://jestjs.io/docs/manual-mocks.html#content");
        }

        this._mockMetaDataCache.set(modulePath, mockMetadata);
      }

      return this._moduleMocker.generateFromMetadata( // added above if missing
      this._mockMetaDataCache.get(modulePath));
    }
  }, {
    key: "_shouldMock",
    value: function _shouldMock(from, moduleName) {
      var explicitShouldMock = this._explicitShouldMock;

      var moduleID = this._resolver.getModuleID(fromEntries(this._virtualMocks), from, moduleName);

      var key = from + path().delimiter + moduleID;

      if (explicitShouldMock.has(moduleID)) {
        // guaranteed by `has` above
        return explicitShouldMock.get(moduleID);
      }

      if (!this._shouldAutoMock || this._resolver.isCoreModule(moduleName) || this._shouldUnmockTransitiveDependenciesCache.get(key)) {
        return false;
      }

      if (this._shouldMockModuleCache.has(moduleID)) {
        // guaranteed by `has` above
        return this._shouldMockModuleCache.get(moduleID);
      }

      var modulePath;

      try {
        modulePath = this._resolveModule(from, moduleName);
      } catch (e) {
        var manualMock = this._resolver.getMockModule(from, moduleName);

        if (manualMock) {
          this._shouldMockModuleCache.set(moduleID, true);

          return true;
        }

        throw e;
      }

      if (this._unmockList && this._unmockList.test(modulePath)) {
        this._shouldMockModuleCache.set(moduleID, false);

        return false;
      } // transitive unmocking for package managers that store flat packages (npm3)


      var currentModuleID = this._resolver.getModuleID(fromEntries(this._virtualMocks), from);

      if (this._transitiveShouldMock.get(currentModuleID) === false || from.includes(NODE_MODULES) && modulePath.includes(NODE_MODULES) && (this._unmockList && this._unmockList.test(from) || explicitShouldMock.get(currentModuleID) === false)) {
        this._transitiveShouldMock.set(moduleID, false);

        this._shouldUnmockTransitiveDependenciesCache.set(key, true);

        return false;
      }

      this._shouldMockModuleCache.set(moduleID, true);

      return true;
    }
  }, {
    key: "_createRequireImplementation",
    value: function _createRequireImplementation(from, options) {
      var _this9 = this;

      var resolve = function resolve(moduleName, resolveOptions) {
        var resolved = _this9._requireResolve(from.filename, moduleName, resolveOptions);

        if ((resolveOptions === null || resolveOptions === void 0 ? void 0 : resolveOptions[OUTSIDE_JEST_VM_RESOLVE_OPTION]) && (options === null || options === void 0 ? void 0 : options.isInternalModule)) {
          return (0, _helpers.createOutsideJestVmPath)(resolved);
        }

        return resolved;
      };

      resolve.paths = function (moduleName) {
        return _this9._requireResolvePaths(from.filename, moduleName);
      };

      var moduleRequire = (options === null || options === void 0 ? void 0 : options.isInternalModule) ? function (moduleName) {
        return _this9.requireInternalModule(from.filename, moduleName);
      } : this.requireModuleOrMock.bind(this, from.filename);
      moduleRequire.extensions = Object.create(null);
      moduleRequire.resolve = resolve;

      moduleRequire.cache = function () {
        // TODO: consider warning somehow that this does nothing. We should support deletions, anyways
        var notPermittedMethod = function notPermittedMethod() {
          return true;
        };

        return new Proxy(Object.create(null), {
          defineProperty: notPermittedMethod,
          deleteProperty: notPermittedMethod,
          get: function get(_target, key) {
            return typeof key === 'string' ? _this9._moduleRegistry.get(key) : undefined;
          },
          getOwnPropertyDescriptor: function getOwnPropertyDescriptor() {
            return {
              configurable: true,
              enumerable: true
            };
          },
          has: function has(_target, key) {
            return typeof key === 'string' && _this9._moduleRegistry.has(key);
          },
          ownKeys: function ownKeys() {
            return Array.from(_this9._moduleRegistry.keys());
          },
          set: notPermittedMethod
        });
      }();

      Object.defineProperty(moduleRequire, 'main', {
        enumerable: true,
        value: this._mainModule
      });
      return moduleRequire;
    }
  }, {
    key: "_createJestObjectFor",
    value: function _createJestObjectFor(from) {
      var _this10 = this;

      var disableAutomock = function disableAutomock() {
        _this10._shouldAutoMock = false;
        return jestObject;
      };

      var enableAutomock = function enableAutomock() {
        _this10._shouldAutoMock = true;
        return jestObject;
      };

      var unmock = function unmock(moduleName) {
        var moduleID = _this10._resolver.getModuleID(fromEntries(_this10._virtualMocks), from, moduleName);

        _this10._explicitShouldMock.set(moduleID, false);

        return jestObject;
      };

      var deepUnmock = function deepUnmock(moduleName) {
        var moduleID = _this10._resolver.getModuleID(fromEntries(_this10._virtualMocks), from, moduleName);

        _this10._explicitShouldMock.set(moduleID, false);

        _this10._transitiveShouldMock.set(moduleID, false);

        return jestObject;
      };

      var mock = function mock(moduleName, mockFactory, options) {
        if (mockFactory !== undefined) {
          return setMockFactory(moduleName, mockFactory, options);
        }

        var moduleID = _this10._resolver.getModuleID(fromEntries(_this10._virtualMocks), from, moduleName);

        _this10._explicitShouldMock.set(moduleID, true);

        return jestObject;
      };

      var setMockFactory = function setMockFactory(moduleName, mockFactory, options) {
        _this10.setMock(from, moduleName, mockFactory, options);

        return jestObject;
      };

      var clearAllMocks = function clearAllMocks() {
        _this10.clearAllMocks();

        return jestObject;
      };

      var resetAllMocks = function resetAllMocks() {
        _this10.resetAllMocks();

        return jestObject;
      };

      var restoreAllMocks = function restoreAllMocks() {
        _this10.restoreAllMocks();

        return jestObject;
      };

      var _getFakeTimers = function _getFakeTimers() {
        if (!(_this10._environment.fakeTimers || _this10._environment.fakeTimersModern)) {
          _this10._logFormattedReferenceError('You are trying to access a property or method of the Jest environment after it has been torn down.');

          process.exitCode = 1;
        }

        return _this10._fakeTimersImplementation;
      };

      var useFakeTimers = function useFakeTimers() {
        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'legacy';

        if (type === 'modern') {
          _this10._fakeTimersImplementation = _this10._environment.fakeTimersModern;
        } else {
          _this10._fakeTimersImplementation = _this10._environment.fakeTimers;
        }

        _this10._fakeTimersImplementation.useFakeTimers();

        return jestObject;
      };

      var useRealTimers = function useRealTimers() {
        _getFakeTimers().useRealTimers();

        return jestObject;
      };

      var resetModules = function resetModules() {
        _this10.resetModules();

        return jestObject;
      };

      var isolateModules = function isolateModules(fn) {
        _this10.isolateModules(fn);

        return jestObject;
      };

      var fn = this._moduleMocker.fn.bind(this._moduleMocker);

      var spyOn = this._moduleMocker.spyOn.bind(this._moduleMocker);

      var setTimeout = function setTimeout(timeout) {
        if (_this10._environment.global.jasmine) {
          _this10._environment.global.jasmine._DEFAULT_TIMEOUT_INTERVAL = timeout;
        } else {
          // @ts-expect-error: https://github.com/Microsoft/TypeScript/issues/24587
          _this10._environment.global[testTimeoutSymbol] = timeout;
        }

        return jestObject;
      };

      var retryTimes = function retryTimes(numTestRetries) {
        // @ts-expect-error: https://github.com/Microsoft/TypeScript/issues/24587
        _this10._environment.global[retryTimesSymbol] = numTestRetries;
        return jestObject;
      };

      var jestObject = {
        addMatchers: function addMatchers(matchers) {
          return _this10._environment.global.jasmine.addMatchers(matchers);
        },
        advanceTimersByTime: function advanceTimersByTime(msToRun) {
          return _getFakeTimers().advanceTimersByTime(msToRun);
        },
        advanceTimersToNextTimer: function advanceTimersToNextTimer(steps) {
          return _getFakeTimers().advanceTimersToNextTimer(steps);
        },
        autoMockOff: disableAutomock,
        autoMockOn: enableAutomock,
        clearAllMocks: clearAllMocks,
        clearAllTimers: function clearAllTimers() {
          return _getFakeTimers().clearAllTimers();
        },
        createMockFromModule: function createMockFromModule(moduleName) {
          return _this10._generateMock(from, moduleName);
        },
        deepUnmock: deepUnmock,
        disableAutomock: disableAutomock,
        doMock: mock,
        dontMock: unmock,
        enableAutomock: enableAutomock,
        fn: fn,
        genMockFromModule: function genMockFromModule(moduleName) {
          return _this10._generateMock(from, moduleName);
        },
        getRealSystemTime: function getRealSystemTime() {
          var fakeTimers = _getFakeTimers();

          if (fakeTimers instanceof _fakeTimers().ModernFakeTimers) {
            return fakeTimers.getRealSystemTime();
          } else {
            throw new TypeError('getRealSystemTime is not available when not using modern timers');
          }
        },
        getTimerCount: function getTimerCount() {
          return _getFakeTimers().getTimerCount();
        },
        isMockFunction: this._moduleMocker.isMockFunction,
        isolateModules: isolateModules,
        mock: mock,
        requireActual: this.requireActual.bind(this, from),
        requireMock: this.requireMock.bind(this, from),
        resetAllMocks: resetAllMocks,
        resetModuleRegistry: resetModules,
        resetModules: resetModules,
        restoreAllMocks: restoreAllMocks,
        retryTimes: retryTimes,
        runAllImmediates: function runAllImmediates() {
          var fakeTimers = _getFakeTimers();

          if (fakeTimers instanceof _fakeTimers().LegacyFakeTimers) {
            fakeTimers.runAllImmediates();
          } else {
            throw new TypeError('runAllImmediates is not available when using modern timers');
          }
        },
        runAllTicks: function runAllTicks() {
          return _getFakeTimers().runAllTicks();
        },
        runAllTimers: function runAllTimers() {
          return _getFakeTimers().runAllTimers();
        },
        runOnlyPendingTimers: function runOnlyPendingTimers() {
          return _getFakeTimers().runOnlyPendingTimers();
        },
        runTimersToTime: function runTimersToTime(msToRun) {
          return _getFakeTimers().advanceTimersByTime(msToRun);
        },
        setMock: function setMock(moduleName, mock) {
          return setMockFactory(moduleName, function () {
            return mock;
          });
        },
        setSystemTime: function setSystemTime(now) {
          var fakeTimers = _getFakeTimers();

          if (fakeTimers instanceof _fakeTimers().ModernFakeTimers) {
            fakeTimers.setSystemTime(now);
          } else {
            throw new TypeError('setSystemTime is not available when not using modern timers');
          }
        },
        setTimeout: setTimeout,
        spyOn: spyOn,
        unmock: unmock,
        useFakeTimers: useFakeTimers,
        useRealTimers: useRealTimers
      };
      return jestObject;
    }
  }, {
    key: "_logFormattedReferenceError",
    value: function _logFormattedReferenceError(errorMessage) {
      var originalStack = new ReferenceError(errorMessage).stack.split('\n') // Remove this file from the stack (jest-message-utils will keep one line)
      .filter(function (line) {
        return line.indexOf(__filename) === -1;
      }).join('\n');

      var _ref10 = (0, _jestMessageUtil().separateMessageFromStack)(originalStack),
          message = _ref10.message,
          stack = _ref10.stack;

      console.error("\n".concat(message, "\n") + (0, _jestMessageUtil().formatStackTrace)(stack, this._config, {
        noStackTrace: false
      }));
    }
  }, {
    key: "wrapCodeInModuleWrapper",
    value: function wrapCodeInModuleWrapper(content) {
      return this.constructModuleWrapperStart() + content + '\n}});';
    }
  }, {
    key: "constructModuleWrapperStart",
    value: function constructModuleWrapperStart() {
      var args = this.constructInjectedModuleParameters();
      return '({"' + EVAL_RESULT_VARIABLE + "\":function(".concat(args.join(','), "){");
    }
  }, {
    key: "constructInjectedModuleParameters",
    value: function constructInjectedModuleParameters() {
      return ['module', 'exports', 'require', '__dirname', '__filename', 'global', this._config.injectGlobals ? 'jest' : undefined].concat(_toConsumableArray(this._config.extraGlobals)).filter(notEmpty);
    }
  }, {
    key: "handleExecutionError",
    value: function handleExecutionError(e, module) {
      var moduleNotFoundError = _jestResolve()["default"].tryCastModuleNotFoundError(e);

      if (moduleNotFoundError) {
        if (!moduleNotFoundError.requireStack) {
          moduleNotFoundError.requireStack = [module.filename || module.id];

          for (var cursor = module.parent; cursor; cursor = cursor.parent) {
            moduleNotFoundError.requireStack.push(cursor.filename || cursor.id);
          }

          moduleNotFoundError.buildMessage(this._config.rootDir);
        }

        throw moduleNotFoundError;
      }

      throw e;
    }
  }, {
    key: "getGlobalsForCjs",
    value: function getGlobalsForCjs(from) {
      var jest = this.jestObjectCaches.get(from);
      invariant(jest, 'There should always be a Jest object already');
      return _objectSpread({}, this.getGlobalsFromEnvironment(), {
        jest: jest
      });
    }
  }, {
    key: "getGlobalsForEsm",
    value: function getGlobalsForEsm(from, context) {
      var jest = this.jestObjectCaches.get(from);

      if (!jest) {
        jest = this._createJestObjectFor(from);
        this.jestObjectCaches.set(from, jest);
      }

      var globals = _objectSpread({}, this.getGlobalsFromEnvironment(), {
        jest: jest
      });

      var module = new (_vm().SyntheticModule)(Object.keys(globals), function () {
        var _this11 = this;

        Object.entries(globals).forEach(function (_ref11) {
          var _ref12 = _slicedToArray(_ref11, 2),
              key = _ref12[0],
              value = _ref12[1];

          // @ts-expect-error: TS doesn't know what `this` is
          _this11.setExport(key, value);
        });
      }, {
        context: context,
        identifier: '@jest/globals'
      });
      return evaluateSyntheticModule(module);
    }
  }, {
    key: "getGlobalsFromEnvironment",
    value: function getGlobalsFromEnvironment() {
      if (this.jestGlobals) {
        return _objectSpread({}, this.jestGlobals);
      }

      return {
        afterAll: this._environment.global.afterAll,
        afterEach: this._environment.global.afterEach,
        beforeAll: this._environment.global.beforeAll,
        beforeEach: this._environment.global.beforeEach,
        describe: this._environment.global.describe,
        expect: this._environment.global.expect,
        fdescribe: this._environment.global.fdescribe,
        fit: this._environment.global.fit,
        it: this._environment.global.it,
        test: this._environment.global.test,
        xdescribe: this._environment.global.xdescribe,
        xit: this._environment.global.xit,
        xtest: this._environment.global.xtest
      };
    }
  }, {
    key: "readFile",
    value: function readFile(filename) {
      var source = this._cacheFS.get(filename);

      if (!source) {
        source = fs().readFileSync(filename, 'utf8');

        this._cacheFS.set(filename, source);
      }

      return source;
    }
  }, {
    key: "setGlobalsForRuntime",
    value: function setGlobalsForRuntime(globals) {
      this.jestGlobals = globals;
    }
  }], [{
    key: "createContext",
    value: function createContext(config, options) {
      (0, _jestUtil().createDirectory)(config.cacheDirectory);
      var instance = Runtime.createHasteMap(config, {
        console: options.console,
        maxWorkers: options.maxWorkers,
        resetCache: !config.cache,
        watch: options.watch,
        watchman: options.watchman
      });
      return instance.build().then(function (hasteMap) {
        return {
          config: config,
          hasteFS: hasteMap.hasteFS,
          moduleMap: hasteMap.moduleMap,
          resolver: Runtime.createResolver(config, hasteMap.moduleMap)
        };
      }, function (error) {
        throw error;
      });
    }
  }, {
    key: "createHasteMap",
    value: function createHasteMap(config, options) {
      var ignorePatternParts = [].concat(_toConsumableArray(config.modulePathIgnorePatterns), _toConsumableArray(options && options.watch ? config.watchPathIgnorePatterns : []), [config.cacheDirectory.startsWith(config.rootDir + path().sep) && config.cacheDirectory]).filter(Boolean);
      var ignorePattern = ignorePatternParts.length > 0 ? new RegExp(ignorePatternParts.join('|')) : undefined;
      return new (_jestHasteMap()["default"])({
        cacheDirectory: config.cacheDirectory,
        computeSha1: config.haste.computeSha1,
        console: options && options.console,
        dependencyExtractor: config.dependencyExtractor,
        extensions: [_jestSnapshot()["default"].EXTENSION].concat(config.moduleFileExtensions),
        hasteImplModulePath: config.haste.hasteImplModulePath,
        ignorePattern: ignorePattern,
        maxWorkers: options && options.maxWorkers || 1,
        mocksPattern: (0, _jestRegexUtil().escapePathForRegex)(path().sep + '__mocks__' + path().sep),
        name: config.name,
        platforms: config.haste.platforms || ['ios', 'android'],
        resetCache: options && options.resetCache,
        retainAllFiles: false,
        rootDir: config.rootDir,
        roots: config.roots,
        throwOnModuleCollision: config.haste.throwOnModuleCollision,
        useWatchman: options && options.watchman,
        watch: options && options.watch
      });
    }
  }, {
    key: "createResolver",
    value: function createResolver(config, moduleMap) {
      return new (_jestResolve()["default"])(moduleMap, {
        defaultPlatform: config.haste.defaultPlatform,
        extensions: config.moduleFileExtensions.map(function (extension) {
          return '.' + extension;
        }),
        hasCoreModules: true,
        moduleDirectories: config.moduleDirectories,
        moduleNameMapper: getModuleNameMapper(config),
        modulePaths: config.modulePaths,
        platforms: config.haste.platforms,
        resolver: config.resolver,
        rootDir: config.rootDir
      });
    }
  }, {
    key: "runCLI",
    value: function runCLI(args, info) {
      return (0, _cli.run)(args, info);
    }
  }, {
    key: "getCLIOptions",
    value: function getCLIOptions() {
      return _args.options;
    }
  }]);

  return Runtime;
}();

_defineProperty(Runtime, 'shouldInstrument', _transform().shouldInstrument);

function invariant(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}

function notEmpty(value) {
  return value !== null && value !== undefined;
}

function evaluateSyntheticModule(module) {
  return regeneratorRuntime.async(function evaluateSyntheticModule$(_context5) {
    while (1) {
      switch (_context5.prev = _context5.next) {
        case 0:
          _context5.next = 2;
          return regeneratorRuntime.awrap(module.link(function () {
            throw new Error('This should never happen');
          }));

        case 2:
          _context5.next = 4;
          return regeneratorRuntime.awrap(module.evaluate());

        case 4:
          return _context5.abrupt("return", module);

        case 5:
        case "end":
          return _context5.stop();
      }
    }
  });
}

module.exports = Runtime;